<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Activiti学习1]]></title>
    <url>%2F2019%2F07%2F14%2FActiviti%E5%AD%A6%E4%B9%A01%2F</url>
    <content type="text"><![CDATA[新建maven工程，添加Activiti的插件，如何添加插件网上有maven依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;activiti&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.activiti&lt;/groupId&gt; &lt;artifactId&gt;activiti-engine&lt;/artifactId&gt; &lt;version&gt;6.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--logback--&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--guava--&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;23.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--h2否则会报java.lang.ClassNotFoundException: org.h2.Driver--&gt; &lt;dependency&gt; &lt;groupId&gt;com.h2database&lt;/groupId&gt; &lt;artifactId&gt;h2&lt;/artifactId&gt; &lt;version&gt;1.4.197&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt; &lt;/repositories&gt;&lt;/project&gt; 新建测试流程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version="1.0" encoding="UTF-8" standalone="yes"?&gt;&lt;definitions xmlns="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:activiti="http://activiti.org/bpmn" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:omgdc="http://www.omg.org/spec/DD/20100524/DC" xmlns:omgdi="http://www.omg.org/spec/DD/20100524/DI" xmlns:tns="http://www.activiti.org/test" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" expressionLanguage="http://www.w3.org/1999/XPath" id="m1562507898229" name="" targetNamespace="http://www.activiti.org/test" typeLanguage="http://www.w3.org/2001/XMLSchema"&gt; &lt;process id="apply_flow" isClosed="false" isExecutable="true" name="申请流程" processType="None"&gt; &lt;startEvent id="startEvent" name="开始审批流程"/&gt; &lt;userTask activiti:exclusive="true" id="apply" name="请假申请"&gt; &lt;extensionElements&gt; &lt;activiti:formProperty id="message" name="申请信息" readable="true" required="true" type="string" writable="true"/&gt; &lt;activiti:formProperty id="name" name="申请人" readable="true" required="true" type="string" writable="true"/&gt; &lt;activiti:formProperty id="submitType" name="是否确认提交审批" readable="true" required="true" type="string" writable="true"/&gt; &lt;/extensionElements&gt; &lt;/userTask&gt; &lt;sequenceFlow id="_4" sourceRef="startEvent" targetRef="apply"/&gt; &lt;userTask activiti:assignee="张三" activiti:exclusive="true" id="bzr_approve" name="班主任审批"&gt; &lt;extensionElements&gt; &lt;activiti:formProperty id="bzrApprove" name="班主任是否审批通过" readable="true" required="true" type="string" writable="true"/&gt; &lt;activiti:formProperty id="bzrMessage" name="班主任审批备注" readable="true" required="true" type="string" writable="true"/&gt; &lt;/extensionElements&gt; &lt;/userTask&gt; &lt;userTask activiti:assignee="李四" activiti:exclusive="true" id="jwc_approve" name="教务处审批"&gt; &lt;extensionElements&gt; &lt;activiti:formProperty id="jwcApprove" name="教务处是否审批通过" readable="true" required="true" type="string" writable="true"/&gt; &lt;activiti:formProperty id="jwcMessage" name="教务处备注" readable="true" required="true" type="string" writable="true"/&gt; &lt;/extensionElements&gt; &lt;/userTask&gt; &lt;endEvent id="EndEvent" name="结束审批流程"&gt; &lt;terminateEventDefinition id="EndEvent_ED_1"/&gt; &lt;/endEvent&gt; &lt;exclusiveGateway gatewayDirection="Unspecified" id="decide_submit" name="提交还是取消"/&gt; &lt;sequenceFlow id="_13" sourceRef="decide_submit" targetRef="bzr_approve"&gt; &lt;conditionExpression xsi:type="tFormalExpression"&gt;&lt;![CDATA[$&#123;submitType == "y" || submitType == "Y"&#125;]]&gt;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;exclusiveGateway gatewayDirection="Unspecified" id="decide_bzl_approve" name="班主任审批校验"/&gt; &lt;sequenceFlow id="_16" sourceRef="decide_bzl_approve" targetRef="jwc_approve"&gt; &lt;conditionExpression xsi:type="tFormalExpression"&gt;&lt;![CDATA[$&#123;bzrApprove =="Y" || bzrApprove == "y"&#125;]]&gt;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;endEvent id="cancle_submit" name="取消申请"&gt; &lt;terminateEventDefinition id="cancle_submit_ED_1"/&gt; &lt;/endEvent&gt; &lt;sequenceFlow id="_2" sourceRef="decide_submit" targetRef="cancle_submit"&gt; &lt;conditionExpression xsi:type="tFormalExpression"&gt;&lt;![CDATA[$&#123;submitType == "n" || submitType == "N"&#125;]]&gt;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;exclusiveGateway gatewayDirection="Unspecified" id="decide_jwc_approve" name="教务处审批校验"/&gt; &lt;sequenceFlow id="_5" sourceRef="decide_jwc_approve" targetRef="EndEvent"&gt; &lt;conditionExpression xsi:type="tFormalExpression"&gt;&lt;![CDATA[$&#123;jwcApprove == "Y" || jwcApprove == "y"&#125;]]&gt;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;sequenceFlow id="_7" sourceRef="decide_bzl_approve" targetRef="apply"&gt; &lt;conditionExpression xsi:type="tFormalExpression"&gt;&lt;![CDATA[$&#123;bzrApprove =="N" || bzrApprove == "n"&#125;]]&gt;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;sequenceFlow id="_8" sourceRef="decide_jwc_approve" targetRef="apply"&gt; &lt;conditionExpression xsi:type="tFormalExpression"&gt;&lt;![CDATA[$&#123;jwcApprove == "N" || jwcApprove == "n"&#125;]]&gt;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;sequenceFlow id="_9" sourceRef="bzr_approve" targetRef="decide_bzl_approve"/&gt; &lt;sequenceFlow id="_10" sourceRef="apply" targetRef="decide_submit"/&gt; &lt;sequenceFlow id="_12" sourceRef="jwc_approve" targetRef="decide_jwc_approve"/&gt; &lt;/process&gt; &lt;bpmndi:BPMNDiagram documentation="background=#FFFFFF;count=1;horizontalcount=1;orientation=0;width=842.4;height=1195.2;imageableWidth=832.4;imageableHeight=1185.2;imageableX=5.0;imageableY=5.0" id="Diagram-_1" name="New Diagram"&gt; &lt;--以下省略--&gt;&lt;/--以下省略--&gt;&lt;/definitions&gt; 流程图如下 测试代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class DemoMain &#123; private static final org.slf4j.Logger LOGGER = LoggerFactory.getLogger(DemoMain.class); public static void main(String[] args) throws ParseException &#123; LOGGER.info("启动程序"); //创建流程引擎 ProcessEngine processEngine = getProcessEngine(); //部署流程定义文件 ProcessDefinition processDefinition = getProcessDefinition(processEngine); //流程定义文件 申请，流程ID shenqing:1:4 //启动运行流程 ProcessInstance processInstance = getProcessInstance(processEngine, processDefinition); //启动流程 shenqing //处理流程 Scanner scanner = new Scanner(System.in); while (processInstance != null &amp;&amp; !processInstance.isEnded())&#123; TaskService taskService = processEngine.getTaskService(); List&lt;Task&gt; list = taskService.createTaskQuery().list(); LOGGER.info("待处理任务数量 &#123;&#125;",list.size()); for (Task task : list) &#123; LOGGER.info("待处理任务 &#123;&#125;",task.getName()); FormService formService = processEngine.getFormService(); TaskFormData taskFormData = formService.getTaskFormData(task.getId()); List&lt;FormProperty&gt; formProperties = taskFormData.getFormProperties(); //创建map存储输入值 Map&lt;String, Object&gt; variables = Maps.newHashMap(); //输入表单填写内容 for (FormProperty formProperty : formProperties) &#123; String line = null; if(StringFormType.class.isInstance(formProperty.getType()))&#123; LOGGER.info("请输入 &#123;&#125; ?",formProperty.getName()); line = scanner.nextLine(); variables.put(formProperty.getId(),line); &#125;else if(DateFormType.class.isInstance(formProperty.getType()))&#123; LOGGER.info("请输入 &#123;&#125; ？格式(yyyy-MM-dd)",formProperty.getName()); line = scanner.nextLine(); SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd"); Date date = simpleDateFormat.parse(line); variables.put(formProperty.getId(),date); &#125;else &#123; LOGGER.info("类型不支持 &#123;&#125;",formProperty.getType()); &#125; LOGGER.info("您输入的内容是 &#123;&#125;",line); &#125; taskService.complete(task.getId(),variables); //完成一步流程过后，重新设置processInstance //否则一直死循环出不来 processInstance = processEngine.getRuntimeService() .createProcessInstanceQuery() .processInstanceId(processInstance.getId()) .singleResult(); &#125; &#125; scanner.close(); LOGGER.info("结束程序"); &#125; private static ProcessInstance getProcessInstance(ProcessEngine processEngine, ProcessDefinition processDefinition) &#123; RuntimeService runtimeService = processEngine.getRuntimeService(); //根据流程定义id启动 ProcessInstance processInstance = runtimeService.startProcessInstanceById(processDefinition.getId()); LOGGER.info("启动流程 &#123;&#125;",processInstance.getProcessDefinitionKey()); return processInstance; &#125; private static ProcessDefinition getProcessDefinition(ProcessEngine processEngine) &#123; RepositoryService repositoryService = processEngine.getRepositoryService(); DeploymentBuilder deploymentBuilder = repositoryService.createDeployment(); deploymentBuilder.addClasspathResource("process1.bpmn"); Deployment deploy = deploymentBuilder.deploy(); String id = deploy.getId(); LOGGER.info("id &#123;&#125;",id); /*获取流程定义文件*/ ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery() .deploymentId(id).singleResult(); LOGGER.info("流程定义对象 &#123;&#125;",processDefinition); LOGGER.info("流程定义文件 &#123;&#125;，流程ID &#123;&#125;",processDefinition.getName(),processDefinition.getId()); return processDefinition; &#125; private static ProcessEngine getProcessEngine() &#123; ProcessEngineConfiguration cfg = ProcessEngineConfiguration.createStandaloneInMemProcessEngineConfiguration(); ProcessEngine processEngine = cfg.buildProcessEngine(); //流程引擎name String name = processEngine.getName(); //流程引擎的版本 String version = processEngine.VERSION; LOGGER.info("流程引擎的名字 &#123;&#125;,流程引擎的版本 &#123;&#125;",name,version ); return processEngine; &#125;&#125;]]></content>
      <categories>
        <category>activiti</category>
      </categories>
      <tags>
        <tag>activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java日志详解]]></title>
    <url>%2F2019%2F07%2F06%2Fjava%E6%97%A5%E5%BF%97%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[日志框架j.u.l￼j.u.l是java.util.logging包的简称，是JDK在1.4版本中引入的Java原生日志框架。Java Logging API提供了七个日志级别用来控制输出。这七个级别分别是：SEVERE、WARNING、INFO、CONFIG、FINE、FINER、FINEST。 Log4jLog4j是Apache的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是控制台、文件、GUI组件，甚至是套接口服务器、NT的事件记录器、UNIX Syslog守护进程等；我们也可以控制每一条日志的输出格式； 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。Log4也有七种日志级别：OFF、FATAL、ERROR、WARN、INFO、DEBUG和TRACE。 LogBack(默认使用SLF4J桥接)LogBack也是一个很成熟的日志框架，其实LogBack和Log4j出自一个人之手 logback当前分成三个模块：logback-core,logback- classic和logback-access。 logback-core是其它两个模块的基础模块。 logback-classic是Log4j的一个改良版本。此外logback-classic完整实现SLF4J API使你可以很方便地更换成其它日记系统如Log4j或j.u.l。 logback-access访问模块与Servlet容器集成提供通过Http来访问日记的功能。 Log4j2Log4j2已经不仅仅是Log4j的一个升级版本了，而是从头到尾被重写的，这可以认为这其实就是完全不同的两个框架。 日志门面每一种日志框架都有自己单独的API，要使用对应的框架就要使用其对应的API，这就大大的增加应用程序代码对于日志框架的耦合性。 为了解决这个问题，就是在日志框架和应用程序之间架设一个沟通的桥梁，对于应用程序来说，无论底层的日志框架如何变，都不需要有任何感知。只要门面服务做的足够好，随意换另外一个日志框架，应用程序不需要修改任意一行代码，就可以直接上线。 SLF4J(Simple Logging Facade for Java,缩写SLF4J)SLF4J 的作者就是 Log4j和Logback 的作者 Ceki Gülcü SLF4J其实只是一个门面服务而已，他并不是真正的日志框架，真正的日志的输出相关的实现还是要依赖Log4j、logback等日志框架的。 Apache Commons Logging(JCL)commons-logging和SLF4J的功能是类似的，主要是用来做日志 门面的。提供更加好友的API工具。 如果JCL运行时没找到任何一种第三方的日志实现，则就用jdk14自带的java.util.logging(JUL)。假如你的maven工程pom.xml里加入了log4j的依赖，运行时JCL找到即可动态绑定。 桥接方式使用SLF4J时，如果你需要使用某一种日志实现，那么你选择相对应的SLF4J的桥接包即可。比如使用log4j日志组件，就选slf4j-log4j12桥接包 当使用SLF4J+LogBack时是不需要桥接方式的，因为LogBack默认使用SLF4J桥接。 SLF4J提供的桥接包 • slfj-log4j12.jar (表示桥接 log4j) • slf4j-jdk14.jar(表示桥接jdk Loging) • sIf4j-jcl.jar(表示桥接 jcl) • log4j-slf4j-impl(表示桥接log4j2) • logback-classic(表示桥接 logback) 改变依赖jcl-over-slf4j log4j-over-slf4j 适用场景：第三方引用之间的冲突 例如：依赖spring程序开发，spring默认使用 commons Logging日志门面，第三方使用slf4j日志门面 这时候可以使用jcl-over-slf4j。 那些默认springboot默认使用 Commons Logging+Logback 日志xmllog4j12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE log4j:configuration SYSTEM "log4j.dtd"&gt; &lt;log4j:configuration&gt; &lt;!-- 将日志信息输出到控制台 --&gt; &lt;appender name="ConsoleAppender" class="org.apache.log4j.ConsoleAppender"&gt; &lt;!-- 设置日志输出的样式 --&gt; &lt;layout class="org.apache.log4j.PatternLayout"&gt; &lt;!-- 设置日志输出的格式 --&gt; &lt;param name="ConversionPattern" value="[%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;] [%-5p] [method:%l]%n%m%n%n" /&gt; &lt;/layout&gt; &lt;!--过滤器设置输出的级别--&gt; &lt;filter class="org.apache.log4j.varia.LevelRangeFilter"&gt; &lt;!-- 设置日志输出的最小级别 --&gt; &lt;param name="levelMin" value="WARN" /&gt; &lt;!-- 设置日志输出的最大级别 --&gt; &lt;param name="levelMax" value="ERROR" /&gt; &lt;!-- 设置日志输出的xxx，默认是false --&gt; &lt;param name="AcceptOnMatch" value="true" /&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;!-- 将日志信息输出到文件，但是当文件的大小达到某个阈值的时候，日志文件会自动回滚 --&gt; &lt;appender name="RollingFileAppender" class="org.apache.log4j.RollingFileAppender"&gt; &lt;!-- 设置日志信息输出文件全路径名 --&gt; &lt;param name="File" value="D:/log4j/RollingFileAppender.log" /&gt; &lt;!-- 设置是否在重新启动服务时，在原有日志的基础添加新日志 --&gt; &lt;param name="Append" value="true" /&gt; &lt;!-- 设置保存备份回滚日志的最大个数 --&gt; &lt;param name="MaxBackupIndex" value="10" /&gt; &lt;!-- 设置当日志文件达到此阈值的时候自动回滚，单位可以是KB，MB，GB，默认单位是KB --&gt; &lt;param name="MaxFileSize" value="10KB" /&gt; &lt;!-- 设置日志输出的样式 --&gt; &lt;layout class="org.apache.log4j.PatternLayout"&gt; &lt;!-- 设置日志输出的格式 --&gt; &lt;param name="ConversionPattern" value="[%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;] [%-5p] [method:%l]%n%m%n%n" /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- 将日志信息输出到文件，可以配置多久产生一个新的日志信息文件 --&gt; &lt;appender name="DailyRollingFileAppender" class="org.apache.log4j.DailyRollingFileAppender"&gt; &lt;!-- 设置日志信息输出文件全路径名 --&gt; &lt;param name="File" value="D:/log4j/DailyRollingFileAppender.log" /&gt; &lt;!-- 设置日志每分钟回滚一次，即产生一个新的日志文件 --&gt; &lt;param name="DatePattern" value="'.'yyyy-MM-dd-HH-mm'.log'" /&gt; &lt;!-- 设置日志输出的样式 --&gt; &lt;layout class="org.apache.log4j.PatternLayout"&gt; &lt;!-- 设置日志输出的格式 --&gt; &lt;param name="ConversionPattern" value="[%d&#123;yyyy-MM-dd HH:mm:ss:SSS&#125;] [%-5p] [method:%l]%n%m%n%n" /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;!-- 注意： 1：当additivity="false"时，root中的配置就失灵了，不遵循缺省的继承机制 2：logger中的name非常重要，它代表记录器的包的形式，有一定的包含关系，试验表明 2-1：当定义的logger的name同名时，只有最后的那一个才能正确的打印日志 2-2：当对应的logger含有包含关系时，比如：name=test.log4j.test8 和 name=test.log4j.test8.UseLog4j，则2-1的情况是一样的 2-3：logger的name表示所有的包含在此名的所有记录器都遵循同样的配置，name的值中的包含关系是指记录器的名称哟！注意啦！ 3：logger中定义的level和appender中的filter定义的level的区间取交集 4：如果appender中的filter定义的 levelMin &gt; levelMax ，则打印不出日志信息 --&gt; &lt;!-- 指定logger的设置，additivity指示是否遵循缺省的继承机制--&gt; &lt;logger name="test.log4j.test8.UseLog4j" additivity="false"&gt; &lt;level value ="WARN"/&gt; &lt;appender-ref ref="DailyRollingFileAppender"/&gt; &lt;/logger&gt; &lt;!--指定logger的设置，additivity指示是否遵循缺省的继承机制 --&gt; &lt;logger name="test.log4j.test8.UseLog4j_" additivity="false"&gt; &lt;level value ="ERROR"/&gt; &lt;appender-ref ref="RollingFileAppender"/&gt; &lt;/logger&gt; &lt;!-- 根logger的设置--&gt; &lt;root&gt; &lt;level value ="INFO"/&gt; &lt;appender-ref ref="ConsoleAppender"/&gt; &lt;appender-ref ref="DailyRollingFileAppender"/&gt; &lt;/root&gt; &lt;/log4j:configuration&gt; logback.xml(springboot默认xml名称是logback-spring.xml) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;contextName&gt;febs&lt;/contextName&gt; &lt;property name="log.path" value="york-admin-log" /&gt; &lt;property name="log.maxHistory" value="15" /&gt; &lt;property name="log.colorPattern" value="%d&#123;yyyy-MM-dd HH:mm:ss&#125; | %highlight(%-5level) | %boldYellow(%thread) | %boldGreen(%logger) | %msg%n"/&gt; &lt;property name="log.pattern" value="%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n" /&gt; &lt;!--输出到控制台--&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.colorPattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;appender name="file_info" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/info/info.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;MaxHistory&gt;$&#123;log.maxHistory&#125;&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;appender name="file_error" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/error/error.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;root level="debug"&gt; &lt;appender-ref ref="console" /&gt; &lt;/root&gt; &lt;root level="info"&gt; &lt;appender-ref ref="file_info" /&gt; &lt;appender-ref ref="file_error" /&gt; &lt;/root&gt;&lt;/configuration&gt;]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot整合连接远程redis]]></title>
    <url>%2F2019%2F05%2F11%2Fspringboot%E6%95%B4%E5%90%88%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8Bredis%2F</url>
    <content type="text"><![CDATA[redis的安装很简单，主要是配置文件redis.conf 1.直接启动redis1./redis-server 是这种启动方式需要一直打开窗口，不能进行其他操作，不太方便。 2.以后台进程方式启动redis将redis.conf复制到redis-server同级目录下 修改redis.conf文件 将 daemonize no 修改为 daemonize yes 后台启动 ./redis-server redis.conf 具体操作可以通过redis-cli 3.开启远程连接修改redis.conf文件 保护模式控制：protected-model yes 改为no 本地访问控制：bind 127.0.0.1注释掉 4.Linux 防火墙redis端口号为6379 12/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT/etc/rc.d/init.d/iptables save 5.springboot整合redis引入依赖12345&lt;!--redis--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 添加配置(使用的是百度云服务器，host填服务器ip)1234567#redisspring.redis.host=180.76.244.162spring.redis.port=6379spring.redis.database=1spring.redis.jedis.pool.max-active=8spring.redis.jedis.pool.max-idle=500spring.redis.jedis.pool.min-idle=0 编写dao123456789101112131415@Repositorypublic class RedisDao &#123; @Autowired private StringRedisTemplate template; public void setKey(String key,String value)&#123; ValueOperations&lt;String, String&gt; ops = template.opsForValue(); ops.set(key,value,1, TimeUnit.MINUTES);//1分钟过期 &#125; public String getValue(String key)&#123; ValueOperations&lt;String, String&gt; ops = this.template.opsForValue(); return ops.get(key); &#125;&#125; 编写测试1234567891011121314151617@WebAppConfiguration//用来声明加载的类是一个WebApplicationContext@RunWith(SpringRunner.class)@SpringBootTest@MapperScan("springboot.demo.dao")//扫描dao层@ComponentScan("springboot.demo.dao")public class DemoApplicationTests &#123; protected MockMvc mockMvc; @Autowired private WebApplicationContext wac; @Before public void setup() &#123; mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); //初始化MockMvc对象 //两种方式都可以初始化mockMvc，推荐用这种，上面的会自动跳转地址status判断方法无效 &#125;//这个方法在每个方法执行之前都会执行一遍&#125; 123456789101112public class RedisDaoTest extends DemoApplicationTests &#123; @Autowired RedisDao redisDao; @Test public void fun1()&#123; redisDao.setKey("name","haha"); redisDao.setKey("age","11"); System.out.println(redisDao.getValue("name")); System.out.println(redisDao.getValue("age")); &#125;&#125; 控制台打印 /* haha 11 */]]></content>
      <categories>
        <category>redis</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springbootmybatis-plus的分页]]></title>
    <url>%2F2019%2F05%2F11%2Fspringbootmybatis-plus%E7%9A%84%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[在已经整合了mybatis-plus基础上。 加入分页插件其中@MapperScan(“mybatisplus.demo.mapper”)如果springboot启动类已经有的话是不用加的 12345678910111213@EnableTransactionManagement@Configuration@MapperScan("mybatisplus.demo.mapper")public class MybatisPlusConfig &#123; /** * 分页插件 */ @Bean public PaginationInterceptor paginationInterceptor() &#123; return new PaginationInterceptor(); &#125;&#125; XML 自定义分页dao接口内容1234567public interface PersonMapper extends MyBaseMapper&lt;Person&gt; &#123; //分页方法 //IPage和Page都是mybatis-plus准备好的，Page可以自己实现，就是封装分页参数的类而已。 IPage&lt;Person&gt; selectPageVo(Page page);&#125; 编写Mapper.xmlxml分页方法，等同于编写一个普通 list 查询。 由于mybatis-plus自带的方法都是单表查询，所以如果要联表查询需要自定义xml，只不过不用分页 但是还是要有查询对应逻辑的list。 123456789&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="mybatisplus.demo.mapper.PersonMapper"&gt; &lt;select id="selectPageVo" resultType="mybatisplus.demo.entity.Person"&gt; SELECT * from person &lt;/select&gt;&lt;/mapper&gt; 测试1234567891011121314@Testpublic void fun27()&#123; Page&lt;Person&gt; page = new Page&lt;&gt;(); //相当于start page.setCurrent(2); //相当于pageSize page.setSize(5); IPage&lt;Person&gt; iPage = personMapper.selectPageVo(page); List&lt;Person&gt; personList = iPage.getRecords(); for (Person person : personList) &#123; System.out.println(person); &#125;&#125; 当使用单表查询，分页时mybatis-plus是有默认方法的 即：selectPage，需要一个传入IPage实现类和和Wrapper实现类 刚好Page就是实现IPage的，Wrapper实现类的话查询的就用QueryWrapper。 由于是mybatis-plus默认方法，在继承MyBaseMapper 就不用加自己的方法，直接调用就好了。 也不用编写mapper.xml。 12345678910111213141516@Testpublic void fun28()&#123; Page&lt;Person&gt; page = new Page&lt;&gt;(); //相当于start page.setCurrent(1); //相当于pageSize page.setSize(4); QueryWrapper&lt;Person&gt; wrapper = new QueryWrapper&lt;&gt;(); IPage&lt;Person&gt; iPage = personMapper.selectPage(page, wrapper.like("pname", "东")); for (Person person : iPage.getRecords()) &#123; System.out.println(person); &#125;&#125;]]></content>
      <categories>
        <category>mybatis-plus</category>
      </categories>
      <tags>
        <tag>mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JackJson的使用]]></title>
    <url>%2F2019%2F05%2F11%2FJackJson%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[JackJson的使用需要包：jackson-core-2.2.3.jar（核心jar包）jackson-annotations-2.2.3.jar（该包提供Json注解支持）jackson-databind-2.2.3.jar 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.1&lt;/version&gt;&lt;/dependency&gt; ObjectMapper是JSON操作的核心，Jackson的所有JSON操作都是在ObjectMapper中实现。 ObjectMapper有多个JSON序列化的方法，可以把JSON字符串保存File、OutputStream等不同的介质中。 writeValue(File arg0, Object arg1)把arg1转成json序列，并保存到arg0文件中。 writeValue(OutputStream arg0, Object arg1)把arg1转成json序列，并保存到arg0输出流中。 writeValueAsBytes(Object arg0)把arg0转成json序列，并把结果输出成字节数组。 writeValueAsString(Object arg0)把arg0转成json序列，并把结果输出成字符串。 1、指定对象Class转成 json字符串123456789101112//User类转JSONObjectMapper mapper = new ObjectMapper();User user = new User();user.setName("小民");user.setEmail("xiaomin@sina.com");user.setAge(20);SimpleDateFormat dateformat = new SimpleDateFormat("yyyy-MM-dd");user.setBirthday(dateformat.parse("1996-10-01"));String json = mapper.writeValueAsString(user);System.out.println(json); {“name”:”小民”,”age”:20,”birthday”:844099200000,”email”:”xiaomin@sina.com“} 2、List集合转化成json字符串1234567891011121314ObjectMapper mapper = new ObjectMapper();List&lt;User&gt; users = new ArrayList&lt;User&gt;();User user = new User();user.setName("小民");user.setEmail("xiaomin@sina.com");user.setAge(20);SimpleDateFormat dateformat = new SimpleDateFormat("yyyy-MM-dd");user.setBirthday(dateformat.parse("1996-10-01"));users.add(user);String jsonlist = mapper.writeValueAsString(users);System.out.println(jsonlist); 12&gt; [&#123;&quot;name&quot;:&quot;小民&quot;,&quot;age&quot;:20,&quot;birthday&quot;:844099200000,&quot;email&quot;:&quot;xiaomin@sina.com&quot;&#125;]&gt; 3、Json字符串转化成指定Class类1234567String json = "&#123;\"name\":\"小民\",\"age\":20,\"birthday\":844099200000,\"email\":\"xiaomin@sina.com\"&#125;";/** * ObjectMapper支持从byte[]、File、InputStream、字符串等数据的JSON反序列化。 */ObjectMapper mapper = new ObjectMapper();User user = mapper.readValue(json, User.class);System.out.println(user); 12&gt; User&#123;name=&apos;小民aa&apos;, age=25, birthday=Tue Oct 01 00:00:00 CST 1996, email=&apos;xiaomin@sina.com&apos;&#125;&gt; 4、Json字符串转化成集合List方法一： 12345String jsonString="[&#123;'id':'1'&#125;,&#123;'id':'2'&#125;]";ObjectMapper mapper = new ObjectMapper();JavaType javaType = mapper.getTypeFactory().constructParametricType(List.class, Bean.class);//如果是Map类型 mapper.getTypeFactory().constructParametricType(HashMap.class,String.class, Bean.class); List&lt;Bean&gt; lst = (List&lt;Bean&gt;)mapper.readValue(jsonString, javaType); 1234567&gt; Student&#123;name=&apos;s1&apos;, age=12, date=Thu Jun 09 20:38:37 CST 2016&#125;&gt; Student&#123;name=&apos;s2&apos;, age=12, date=Thu Jun 09 20:38:37 CST 2016&#125;&gt; Student&#123;name=&apos;s3&apos;, age=12, date=Thu Jun 09 20:38:37 CST 2016&#125;&gt; Student&#123;name=&apos;s4&apos;, age=12, date=Thu Jun 09 20:38:37 CST 2016&#125;&gt; Student&#123;name=&apos;s5&apos;, age=12, date=Thu Jun 09 20:38:37 CST 2016&#125;&gt; Student&#123;name=&apos;s6&apos;, age=12, date=Thu Jun 09 20:38:37 CST 2016&#125;&gt; 方法二： 123String jsonString="[&#123;'id':'1'&#125;,&#123;'id':'2'&#125;]";ObjectMapper mapper = new ObjectMapper();List&lt;Bean&gt; beanList = mapper.readValue(jsonString, new TypeReference&lt;List&lt;Bean&gt;&gt;() &#123;&#125;); 1234567&gt; Student&#123;name=&apos;s1&apos;, age=12, date=Thu Jun 09 20:38:37 CST 2016&#125;&gt; Student&#123;name=&apos;s2&apos;, age=12, date=Thu Jun 09 20:38:37 CST 2016&#125;&gt; Student&#123;name=&apos;s3&apos;, age=12, date=Thu Jun 09 20:38:37 CST 2016&#125;&gt; Student&#123;name=&apos;s4&apos;, age=12, date=Thu Jun 09 20:38:37 CST 2016&#125;&gt; Student&#123;name=&apos;s5&apos;, age=12, date=Thu Jun 09 20:38:37 CST 2016&#125;&gt; Student&#123;name=&apos;s6&apos;, age=12, date=Thu Jun 09 20:38:37 CST 2016&#125;&gt;]]></content>
      <categories>
        <category>JackJson</category>
      </categories>
      <tags>
        <tag>JackJson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis-plus的主键]]></title>
    <url>%2F2019%2F05%2F11%2Fmybatis-plus%E7%9A%84%E4%B8%BB%E9%94%AE%2F</url>
    <content type="text"><![CDATA[12@TableId(value = "id",type = IdType.UUID)private String id; // 主键 IdType生成不同类型的主键id，IdType是一个枚举类，定义了生成ID的类型 AUTO 数据库ID自增 INPUT 用户输入ID ID_WORKER 全局唯一ID，Long类型的主键 ID_WORKER_STR 字符串全局唯一ID UUID 全局唯一ID，UUID类型的主键 NONE 该类型为未设置主键类型 ​]]></content>
      <categories>
        <category>mybatis-plus</category>
      </categories>
      <tags>
        <tag>mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springbootmybatis-plus快速开始]]></title>
    <url>%2F2019%2F05%2F11%2Fspringbootmybatis-plus%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[1.建立springboot项目后添加依赖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;mybatis-plus&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.编写application.properties1234567891011#datasourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/test01?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username=rootspring.datasource.password=123#扫描mapper.xmlmybatis-plus.mapper-locations=mapper/*.xml#日志配置logging.config=classpath:logback-spring.xml#控制台打印sql语句logging.level.mybatisplus.demo.dao=debug 3.logback-spring.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt; &lt;!-- %m输出的信息,%p日志级别,%t线程名,%d日期,%c类的全名,%i索引【从数字0开始递增】,,, --&gt; &lt;!-- appender是configuration的子节点，是负责写日志的组件。 --&gt; &lt;!-- ConsoleAppender：把日志输出到控制台 --&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;%d %p (%file:%line\)- %m%n&lt;/pattern&gt; &lt;!-- 控制台也要使用UTF-8，不要使用GBK，否则会中文乱码 --&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- RollingFileAppender：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt; &lt;!-- 以下的大概意思是：1.先按日期存日志，日期变了，将前一天的日志文件名重命名为XXX%日期%索引，新的日志仍然是logs.log --&gt; &lt;!-- 2.如果日期没有发生变化，但是当前日志的文件大小超过1KB时，对当前日志进行分割 重命名--&gt; &lt;appender name="applogs" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!--日志输出目录--&gt; &lt;File&gt;D:/log/mybatis_plus_demo.log&lt;/File&gt; &lt;!-- rollingPolicy:当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名。 --&gt; &lt;!-- TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 活动文件的名字会根据fileNamePattern的值，每隔一段时间改变一次 --&gt; &lt;!-- 文件名：log/logs.2017-12-05.0.log --&gt; &lt;fileNamePattern&gt;log/logs.%d.%i.log&lt;/fileNamePattern&gt; &lt;!-- 每产生一个日志文件，该日志文件的保存期限为30天 --&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;!-- maxFileSize:这是活动文件的大小，默认值是10MB，测试时可改成1KB看效果 --&gt; &lt;maxFileSize&gt;1KB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;!-- pattern节点，用来设置日志的输入格式 --&gt; &lt;pattern&gt; %d %p (%file:%line\)- %m%n &lt;/pattern&gt; &lt;!-- 记录日志的编码:此处设置字符集 - --&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 控制台输出日志级别 --&gt; &lt;root level="info"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt; &lt;!-- 指定项目中某个包，当有日志操作行为时的日志记录级别 --&gt; &lt;!-- com.liyan为根包，也就是只要是发生在这个根包下面的所有日志操作行为的权限都是DEBUG --&gt; &lt;!-- 级别依次为【从高到低】：FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE --&gt; &lt;logger name="com.linan" level="DEBUG"&gt; &lt;appender-ref ref="applogs" /&gt; &lt;/logger&gt;&lt;/configuration&gt; 5.在 Spring Boot 启动类中添加 @MapperScan 注解，扫描 Mapper 文件夹12345678@SpringBootApplication@MapperScan("mybatisplus.demo.mapper")public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 6.编写实体类12345678910@Getter@Setter@ToStringpublic class Person &#123; private Integer pid; private String pname; private String page;&#125; 7.编写Mapper123public interface PersonMapper extends BaseMapper&lt;Person&gt;&#123;&#125; 8.单元测试12345@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123;&#125; 123456789101112131415public class MapperTest extends DemoApplicationTests &#123; @Autowired private PersonMapper personMapper; @Test public void fun1()&#123; //查询person列表 List&lt;Person&gt; personList = personMapper.selectList(null); //断言 Assert.assertEquals(2,personList.size()); for (Person person : personList) &#123; System.out.println(person); &#125; &#125;&#125; 控制台打印 12Person(pid=1, pname=陈平安, page=20)Person(pid=2, pname=左右, page=30) 9.自定义优化在使用BaseMapper的时候同时也支持自己的crud操作及编写*Mapper.xml。 BaseMapper提供了17个方法。 当自己涉及到的持久层操作，在BaseMapper中没有预定义，而且在以后的操作中又会重复很多次需要提取为公共的方法时： 可以自定义MyBaseMapper继承BaseMapper。在MyBaseMapper接口自定义公共方法。后续操作就可以继承MyBaseMapper就可以了。 application.properties无需添加相关配置 12public interface MyBaseMapper&lt;T&gt; extends BaseMapper&lt;T&gt; &#123;&#125; 123public interface PersonMapper extends MyBaseMapper&lt;Person&gt; &#123;&#125; 注意 MyBaseMapper不要让 @MapperScan 扫描到误以为是实体 Base 的操作 所以MyBaseMapper接口不能放在dao包内，要另外建一个包 注意使用自定义xml和dao的方法时application.properties的扫包配置前缀为mybatis-plus，而不是mybatis，不然是不会有效果的。 12#扫描mapper.xmlmybatis-plus.mapper-locations=mapper/*.xml]]></content>
      <categories>
        <category>mybatis-plus</category>
      </categories>
      <tags>
        <tag>mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli中js是怎样引入html的]]></title>
    <url>%2F2019%2F05%2F11%2Fvue-cli%E4%B8%ADjs%E6%98%AF%E6%80%8E%E6%A0%B7%E5%BC%95%E5%85%A5html%E7%9A%84%2F</url>
    <content type="text"><![CDATA[vue-cli是怎么通过webpack把js文件引入index.html的过程呢？vue新手在用vue-cli写项目时候会发现，项目目录下index.html并没有通过标签引入任何js。index.html如下： 123456789&lt;!DOCTYPE html&gt;&lt;head&gt;&lt;/meta charsets="utf-8"&gt;&lt;/meta name='viewport' content='width=device-width,user-scalable=no,scalable=1.0'&gt;&lt;head&gt;&lt;body&gt; &lt;div id="app"&gt;&lt;/div&gt;&lt;body&gt;&lt;/html&gt; 那到底是怎么引入js的呢？首先打开package.json,找到script 12345"scripts": &#123; "dev": "webpack-dev-server --inline --progress --config build/webpack.dev.conf.js", "start": "npm run dev", "build": "node build/build.js"&#125;, 执行命令npm run dev ，这时你会看到你创建的vue项目启动起来，所以我们一步步看，执行这个命令，需要找到webpack.dev.conf.js”这个文件，打开它我们看到 123456789'use strict'const utils = require('./utils')const webpack = require('webpack')const config = require('../config')const merge = require('webpack-merge')const baseWebpackConfig = require('./webpack.base.conf')const HtmlWebpackPlugin = require('html-webpack-plugin')const FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')const portfinder = require('portfinder') 它引入了很多插件，这里我们不管其他的，只看两个，webpack.base.conf ;html-webpack-plugin打开webpack.base.conf.js，我们看到 123456789101112131415'use strict'const path = require('path')const utils = require('./utils')const config = require('../config')const vueLoaderConfig = require('./vue-loader.conf')function resolve (dir) &#123; return path.join(__dirname, '..', dir)&#125;module.exports = &#123; context: path.resolve(__dirname, '../'), entry: &#123; app: './src/main.js' &#125;, 入口文件指向main.js，打开main.js,如下 123456789101112131415161718192021import Vue from 'vue'import App from './App'import router from './router'import ElementUI from 'element-ui'import 'element-ui/lib/theme-chalk/index.css'import store from "./store"import echarts from 'echarts'Vue.config.productionTip = falseVue.prototype.$echarts = echarts Vue.use(ElementUI)/* eslint-disable no-new */new Vue(&#123; el: '#app', router, store, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;) main.js中的router指向的是router文件夹下的index.js 123456789export default new Router(&#123; routes: [ &#123; path: '/', name: 'HelloWorld', component: HelloWorld &#125; ]&#125;) HelloWorld组件指向HelloWorld.vue 这里绑定了id为app的元素，然后我们打开第二个文件html-webpack-plugin，这个plugin是帮做我们配置html文件中js文件的引入的，有了这个plugin我们就不用再用在html中加入标签这么傻的方式引入js文件了在node-modules中，打开index.js 123456function HtmlWebpackPlugin (options) &#123; // Default options this.options = _.extend(&#123; template: path.join(__dirname, 'default_index.ejs'), filename: 'index.html', hash: false, 我们发现这不是有index.html吗，所以通过一系列复杂的关系我们得出：启动命令后，通过webpack的文件决定main.js作为app的入口，将main.js通过id绑定在index.html上]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm整合redis]]></title>
    <url>%2F2019%2F05%2F11%2Fssm%E6%95%B4%E5%90%88redis%2F</url>
    <content type="text"><![CDATA[ssm整合redis在java程序中使用redis： 导入jedis.jar包 直接 Jedis jedis = new Jedis(“192.168.80.131”, 6379);获取jedis对象，然后进行操作 也可以创建jedis连接池JedisPoolUtil，然后需要的时候从连接池中get，使用完release即可 JedisPoolUtil 1234567891011121314151617181920212223242526272829303132public class JedisPoolUtil &#123; // 被volatile修饰的变量不会被本地线程缓存，对该变量的读写都是直接操作共享内存。 private static volatile JedisPool jedisPool = null; // 私有化静态方法，不能new private JedisPoolUtil() &#123;&#125;; //对外提供一个get方法 //懒汉单例模式 public static JedisPool getJedisPoolInstance() &#123; if (jedisPool == null) &#123; synchronized (JedisPoolUtil.class) &#123; if (jedisPool == null) &#123; JedisPoolConfig poolConfig = new JedisPoolConfig(); poolConfig.setMaxWaitMillis(100 * 1000); poolConfig.setMaxTotal(1000); poolConfig.setMaxIdle(32); poolConfig.setTestOnBorrow(true); jedisPool = new JedisPool(poolConfig, "180.76.244.162",6379); &#125; &#125; &#125; return jedisPool; &#125; //释放回池子 public static void release(JedisPool jedisPool,Jedis jedis)&#123; if(jedis != null)&#123; jedisPool.returnResourceObject(jedis); &#125; &#125;&#125; 测试123456789public class JedisPoolUtilsTest &#123; public static void main(String[] args) &#123; JedisPool jedisPool = JedisPoolUtil.getJedisPoolInstance(); Jedis jedis = jedisPool.getResource(); jedis.set("两禅寺","东西"); System.out.println(jedis.get("两禅寺")); &#125;&#125; spring整合redis通过redisTemplate对redis进行操作（底层应该也是调用的jedis）编写spring-redis.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd"&gt; &lt;!-- 连接池配置 --&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;!-- 最大空闲数 --&gt; &lt;property name="maxIdle" value="50"&gt;&lt;/property&gt; &lt;!-- 最大连接数 --&gt; &lt;property name="maxTotal" value="100"&gt;&lt;/property&gt; &lt;!-- 最大等待时间 --&gt; &lt;property name="maxWaitMillis" value="20000"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置连接工厂 --&gt; &lt;bean id="connectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory"&gt; &lt;property name="hostName" value="180.76.244.162"&gt;&lt;/property&gt; &lt;property name="port" value="6379"&gt;&lt;/property&gt; &lt;!-- &lt;property name="password" value=""&gt;&lt;/property&gt; --&gt; &lt;property name="poolConfig" ref="poolConfig"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置 key 和 value 的序列化器 --&gt; &lt;bean id="jdkSerializationRedisSerializer" class="org.springframework.data.redis.serializer.JdkSerializationRedisSerializer"/&gt; &lt;bean id="stringRedisSerializer" class="org.springframework.data.redis.serializer.StringRedisSerializer"/&gt; &lt;!-- 配置Redis模板对象 --&gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate"&gt; &lt;property name="connectionFactory" ref="connectionFactory"&gt;&lt;/property&gt; &lt;property name="keySerializer" ref="stringRedisSerializer"&gt;&lt;/property&gt; &lt;property name="valueSerializer" ref="jdkSerializationRedisSerializer"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 实体类实现序列化12345678@Getter@Setter@ToStringpublic class User implements Serializable&#123; private Integer id; private String name; private Integer age;&#125; 修改父类测试类1234567891011@WebAppConfiguration//告诉junit spring的配置文件@ContextConfiguration(&#123; "classpath:spring-mybatis.xml", "classpath:spring-mvc.xml","classpath:spring-redis.xml"&#125;)//配置spring和junit整合，这样junit在启动时就会加载spring容器@RunWith(SpringJUnit4ClassRunner.class)//事务@Transactionalpublic class SSMManageTest &#123;&#125; 单元测试12345678910111213public class RedisTemplateTest extends SSMManageTest&#123; @Autowired private RedisTemplate&lt;String,Object&gt; redisTemplate; @Test public void fun1()&#123; User user = new User(); user.setName("东西"); user.setAge(10); redisTemplate.opsForValue().set("user",user); System.out.println(redisTemplate.opsForValue().get("user")); &#125;//User(id=null, name=东西, age=10)&#125;]]></content>
      <categories>
        <category>redis</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring集成redis作为cache]]></title>
    <url>%2F2019%2F05%2F11%2Fspring%E9%9B%86%E6%88%90redis%E4%BD%9C%E4%B8%BAcache%2F</url>
    <content type="text"><![CDATA[很烦这个！！在spring中不管使用什么缓存，思路都是一样的。1.实现cache接口，当然有默认的实现，例如EhCacheCache。 2.实现缓存管理类，当然也有默认的实现例如EhCacheCacheManager/EhCacheManagerFactoryBean； 3.创建xml文件，把cache接口实现类注入缓存管理实现类。 4.开启缓存注解 12&lt;!-- 开启缓存注解--&gt; &lt;cache:annotation-driven /&gt; 5.在方法上注解@Cacheable(value = “studentCache”) value属性在上面的xml中配置 6.这一步是因为这里使用了redis作为缓存，所以还需要xml配置redis，把redis交给spring管理，可以另外 创建一个xml，或者和缓存的xml放在一块。 1.创建maven工程，引入依赖，这里用的以前的，有些依赖没有用到但是依然导入了。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- javaee依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加日志相关jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加spring核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mybatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mybatis/spring整合包依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- json数据 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--jedis--&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.6.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.4&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.spring-mvc.xml1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"&gt; &lt;!-- 扫描controller --&gt; &lt;context:component-scan base-package="controller"/&gt; &lt;!-- 解除servlet对静态资源文件访问的限制 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 开启SpringMVC注解模式 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 前缀 --&gt; &lt;property name="prefix" value="" /&gt;&lt;!--这里根据自己的建包自己配置--&gt; &lt;!-- 后缀 --&gt; &lt;property name="suffix" value=".jsp" /&gt;&lt;!--这里根据自己的建包自己配置--&gt; &lt;/bean&gt;&lt;/beans&gt; 3.spring-mybatis.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package="service"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置数据库properties位置 --&gt; &lt;!--这个配置会报错，注释掉了用下面的--&gt; &lt;!--&lt;context:property-placeholder location="classpath:dbconfig.properties"&gt;&lt;/context:property-placeholder&gt;--&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:dbconfig.properties&lt;/value&gt; &lt;!--dbconfig.properties 数据库连接信息--&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean class="com.alibaba.druid.pool.DruidDataSource" id="dataSource"&gt; &lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;username&#125;"&gt;&lt;/property&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;url&#125;"&gt;&lt;/property&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 如果Mapper.xml与Mapper.class在同一个包下且同名，spring扫描Mapper.class的同时会自动扫描同名的Mapper.xml并装配到Mapper.class。 如果Mapper.xml与Mapper.class不在同一个包下或者不同名，就必须使用配置mapperLocations指定mapper.xml的位置。--&gt; &lt;!--此时spring是通过识别mapper.xml中的 namespace的值来确定对应的Mapper.class的--&gt; &lt;!-- 配置SqlSessionFactory对象 --&gt; &lt;bean class="org.mybatis.spring.SqlSessionFactoryBean" id="sqlSessionFactory"&gt; &lt;!-- 自动扫描mybatis配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml"&gt;&lt;/property&gt; &lt;!-- 扫描model包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="entity"&gt;&lt;/property&gt; &lt;!--配置使用pageHelper--&gt; &lt;/bean&gt; &lt;!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="dao"/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;&lt;/beans&gt; 4.dbconfig.properties 数据库连接信息1234567url=jdbc:mysql:///test01driverClassName=com.mysql.jdbc.Driverusername=rootpassword=123maxActive=20minIdle=10maxWait=60000 5.log4j.properties 日志文件12345678910111213141516171819202122232425log4j.rootLogger=INFO,Console,File #控制台日志log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.Target=System.out log4j.appender.Console.layout=org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=[%p][%t][%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;][%C] - %m%n #普通文件日志log4j.appender.File=org.apache.log4j.RollingFileAppender log4j.appender.File.File=D:/log/spring-redis-cache.log log4j.appender.File.MaxFileSize=10MB #输出日志，如果换成DEBUG表示输出DEBUG以上级别日志log4j.appender.File.Threshold=ALL log4j.appender.File.layout=org.apache.log4j.PatternLayout log4j.appender.File.layout.ConversionPattern=[%p][%t][%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;][%C] - %m%n #mybatis日志配置 需要将日志的输出级别调为debuglog4j.logger.com.ibatis=DEBUGlog4j.logger.com.ibatis.common.jdbc.SimpleDataSource=DEBUGlog4j.logger.com.ibatis.common.jdbc.ScriptRunner=DEBUGlog4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUG#与sql相关log4j.logger.java.sql.Connection=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG 6.mybatis-config.xml mybatis配置文件12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--用于配合log4j在控制台打印sql语句--&gt; &lt;settings&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING" /&gt; &lt;/settings&gt;&lt;/configuration&gt; 7.redis.xml redis和cache配置文件这里使用的是SimpleCacheManager，其实应该使用RedisCacheManager 使用RedisCacheManager的话需要注入redisTemplate依赖。 解释一下这里为什么构造传的redisTemplate。 RedisCacheManager有两个构造方法，所以我们讲道理应该传RedisOperations， 但是RedisOperations是一个接口，所以应该是传入其实现类，那么RedisOperations实现类是什么呢 其实有两个：RedisTemplate和StringRedisTemplate。哈哈哈 123456789101112131415public RedisCacheManager(RedisOperations redisOperations) &#123; this(redisOperations, Collections.emptyList());&#125;public RedisCacheManager(RedisOperations redisOperations, Collection&lt;String&gt; cacheNames) &#123; this.logger = LogFactory.getLog(RedisCacheManager.class); this.usePrefix = false; this.cachePrefix = new DefaultRedisCachePrefix(); this.loadRemoteCachesOnStartup = false; this.dynamic = true; this.defaultExpiration = 0L; this.expires = null; this.redisOperations = redisOperations; this.setCacheNames(cacheNames);&#125; 12345&lt;bean id="redisCacheManager" class="org.springframework.data.redis.cache.RedisCacheManager"&gt; &lt;constructor-arg name="redisOperations" ref="redisTemplate" /&gt; 这个是RedisCacheManager的属性配置，这里可以从properties读取 &lt;property name="defaultExpiration" value="$&#123;redis.expiration&#125;" /&gt;&lt;/bean&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:cache="http://www.springframework.org/schema/cache" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.2.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache-4.2.xsd"&gt; &lt;cache:annotation-driven/&gt; &lt;!-- 连接池配置 --&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;!-- 最大空闲数 --&gt; &lt;property name="maxIdle" value="50"&gt;&lt;/property&gt; &lt;!-- 最大连接数 --&gt; &lt;property name="maxTotal" value="100"&gt;&lt;/property&gt; &lt;!-- 最大等待时间 --&gt; &lt;property name="maxWaitMillis" value="20000"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 连接工厂 --&gt; &lt;bean id="JedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" p:host-name="180.76.244.162" p:port="6379" p:pool-config-ref="poolConfig"/&gt; &lt;!-- redis模板 --&gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate"&gt; &lt;property name="connectionFactory" ref="JedisConnectionFactory" /&gt; &lt;/bean&gt; &lt;bean id="cacheManager" class="org.springframework.cache.support.SimpleCacheManager"&gt; &lt;property name="caches"&gt; &lt;set&gt; &lt;!-- 这里可以配置多个redis --&gt; &lt;bean class="redis.RedisCache"&gt; &lt;property name="redisTemplate" ref="redisTemplate" /&gt; &lt;property name="name" value="content"/&gt; &lt;!-- name对应的名称要在类或方法的注解中使用 --&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 8.编写Cache接口实现类12345678910111213public interface Cache &#123; String getName(); //缓存的名字 Object getNativeCache(); //得到底层使用的缓存，如Ehcache ValueWrapper get(Object key); //根据key得到一个ValueWrapper，然后调用其get方法获取值 &lt;T&gt; T get(Object key, Class&lt;T&gt; type);//根据key，和value的类型直接获取value void put(Object key, Object value);//往缓存放数据 void evict(Object key);//从缓存中移除key对应的缓存 void clear(); //清空缓存 interface ValueWrapper &#123; //缓存值的Wrapper Object get(); //得到真实的value &#125; &#125; 这个看着蛮复杂，没细看。反正是缓存的crud操作，使用的是redisTemplate。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110public class RedisCache implements Cache&#123; private RedisTemplate&lt;String, Object&gt; redisTemplate; public void setRedisTemplate(RedisTemplate&lt;String, Object&gt; redisTemplate) &#123; this.redisTemplate = redisTemplate; &#125; public void setName(String name) &#123; this.name = name; &#125; private String name; @Override public String getName() &#123; return this.name; &#125; @Override public Object getNativeCache() &#123; return this.redisTemplate; &#125; @Override public ValueWrapper get(Object key) &#123; System.out.println("------缓存获取-------"+key.toString()); final String keyf = key.toString(); Object object = null; object = redisTemplate.execute(new RedisCallback&lt;Object&gt;() &#123; @Override public Object doInRedis(RedisConnection connection) throws DataAccessException &#123; byte[] key = keyf.getBytes(); byte[] value = connection.get(key); if (value == null) &#123; System.out.println("------缓存不存在-------"); return null; &#125; return SerializationUtils.deserialize(value); &#125; &#125;); ValueWrapper obj=(object != null ? new SimpleValueWrapper(object) : null); System.out.println("------获取到内容-------"+obj); return obj; &#125; @Override public &lt;T&gt; T get(Object key, Class&lt;T&gt; type) &#123; return null; &#125; @Override public &lt;T&gt; T get(Object key, Callable&lt;T&gt; valueLoader) &#123; return null; &#125; @Override public void put(Object key, Object value) &#123; System.out.println("-------加入缓存------"); System.out.println("key----:"+key); System.out.println("key----:"+value); final String keyString = key.toString(); final Object valuef = value; final long liveTime = 86400; redisTemplate.execute(new RedisCallback&lt;Long&gt;() &#123; @Override public Long doInRedis(RedisConnection connection) throws DataAccessException &#123; byte[] keyb = keyString.getBytes(); byte[] valueb = SerializationUtils.serialize((Serializable) valuef); connection.set(keyb, valueb); if (liveTime &gt; 0) &#123; connection.expire(keyb, liveTime); &#125; return 1L; &#125; &#125;); &#125; @Override public ValueWrapper putIfAbsent(Object key, Object value) &#123; return null; &#125; @Override public void evict(Object key) &#123; System.out.println("-------緩存刪除------"); final String keyf=key.toString(); redisTemplate.execute(new RedisCallback&lt;Long&gt;() &#123; @Override public Long doInRedis(RedisConnection connection) throws DataAccessException &#123; return connection.del(keyf.getBytes()); &#125; &#125;); &#125; @Override public void clear() &#123; System.out.println("-------緩存清理------"); redisTemplate.execute(new RedisCallback&lt;String&gt;() &#123; @Override public String doInRedis(RedisConnection connection) throws DataAccessException &#123; connection.flushDb(); return "ok"; &#125; &#125;); &#125;&#125; 9.实体类123456789@Getter@Setter@ToStringpublic class User implements Serializable&#123; private Integer id; private String name; private Integer age;&#125; 10.dao和mapper.xml1234public interface UserDao &#123; List&lt;User&gt; getUserList();&#125; 12345678&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.UserDao"&gt; &lt;select id="getUserList" resultType="user"&gt; SELECT * from user &lt;/select&gt;&lt;/mapper&gt; 11.service实现类1234567891011@Servicepublic class UserServiceImpl implements UserServie &#123; @Autowired private UserDao userDao; @Override @Cacheable(value = "content") public List&lt;User&gt; getUserList() &#123; List&lt;User&gt; userList = userDao.getUserList(); return userList; &#125;&#125; 12.单元测试123456789101112public class SpringRedisCacheTest extends RedisCacheTest&#123; @Autowired private UserServie userServie; @Test public void fun1()&#123; List&lt;User&gt; userList = userServie.getUserList(); for (User user : userList) &#123; System.out.println(user); &#125; &#125;&#125; 12345678@WebAppConfiguration//告诉junit spring的配置文件@ContextConfiguration(&#123; "classpath:spring-mybatis.xml", "classpath:spring-mvc.xml","classpath:redis.xml"&#125;)//配置spring和junit整合，这样junit在启动时就会加载spring容器@RunWith(SpringJUnit4ClassRunner.class)public class RedisCacheTest &#123;&#125; 13.补上web.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 读取配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mybatis.xml,classpath:redis.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置监听器加载spring --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置SpringMVC --&gt; &lt;servlet&gt; &lt;servlet-name&gt;MavenProject&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置springmvc什么时候启动，参数必须为整数 --&gt; &lt;!-- 如果为0或者大于0，则springMVC随着容器启动而启动 --&gt; &lt;!-- 如果小于0，则在第一次请求进来的时候启动 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;MavenProject&lt;/servlet-name&gt; &lt;!-- 所有的请求都进入springMVC --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 14.总结：其实套路都一样，主要是cache实现类通过redis实现对缓存的crud。]]></content>
      <categories>
        <category>redis</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot集成springcache]]></title>
    <url>%2F2019%2F05%2F11%2Fspringboot%E9%9B%86%E6%88%90springcache%2F</url>
    <content type="text"><![CDATA[写在前面 在未开启事物的情况之下，每次查询，spring都会关闭旧的sqlSession而创建新的sqlSession,因此此时的一级缓存是没有启作用的 在开启事物的情况之下，spring使用threadLocal获取当前资源绑定同一个sqlSession，因此此时一级缓存是有效的 如果开启事务即使用@Transactional注解进行本次测试，如果连续进行查询，只会打印一次sql，即只访问一次数据库。因为有mybatis的一级缓存存在。 所以要关闭事务，不要使用@Transactional注解 声明式缓存Spring 定义 CacheManager 和 Cache 接口用来统一不同的缓存技术。例如 JCache、 EhCache、 Hazelcast、 Guava、 Redis 等。在使用 Spring 集成 Cache 的时候，我们需要注册实现的 CacheManager 的 Bean。 Spring Boot 为我们自动配置了 JcacheCacheConfiguration、 EhCacheCacheConfiguration、HazelcastCacheConfiguration、GuavaCacheConfiguration、RedisCacheConfiguration、SimpleCacheConfiguration 等。 默认使用 ConcurrenMapCacheManager在我们不使用其他第三方缓存依赖的时候，springboot自动采用ConcurrenMapCacheManager作为缓存管理器。 测试时报错发现是去连接远程服务器上的redis了？其实就是这里的原因。pom里面引入了redis依赖，导致springboot把redis作为了缓存管理器 引入依赖1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;&lt;/dependency&gt; 开启缓存技术12345678910@SpringBootApplication@tk.mybatis.spring.annotation.MapperScan(basePackages = "springboot.demo.dao") //这个注解是之前做的通用mapper的测试用到的@EnableCachingpublic class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; service实现类123456789101112@Servicepublic class StudentServiceImpl implements StudentService &#123; @Autowired private StudentDao studentDao; @Override @Cacheable("students") public Student getStudent(int id) &#123; return studentDao.getStudent(id); &#125;&#125; 单元测试测试运行是打印1次sql语句，访问了1次数据库，缓存生效。 如果去掉 上面的@Cacheable(“students”)，则发现访问了两次数据库 1234567891011public class ServiceExtendsTest extends DemoApplicationTests &#123; @Autowired private StudentService studentService; @Test public void fun1()&#123; studentService.getStudent(1); studentService.getStudent(1); &#125;&#125; 123456789101112131415@WebAppConfiguration//用来声明加载的类是一个WebApplicationContext@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123; protected MockMvc mockMvc; @Autowired private WebApplicationContext wac; @Before public void setup() &#123; mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); //初始化MockMvc对象 //两种方式都可以初始化mockMvc，推荐用这种，上面的会自动跳转地址status判断方法无效 &#125;//这个方法在每个方法执行之前都会执行一遍&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot整合通用mapper]]></title>
    <url>%2F2019%2F05%2F11%2Fspringboot%E6%95%B4%E5%90%88%E9%80%9A%E7%94%A8mapper%2F</url>
    <content type="text"><![CDATA[1.引入依赖123456&lt;!--通用mapper--&gt;&lt;dependency&gt; &lt;groupId&gt;tk.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt;&lt;/dependency&gt; 2.增加application.properties1234#通用mapper#通用mapper的所在接口名称 不只是包名mapper.mappers=springboot.demo.mapper.MyBaseMappermapper.notEmpty=true 3.实体类12345678910@Getter@Setter@ToStringpublic class Person &#123; @Id private Integer pid; private String pname; private String page;&#125; 4.编写MyBaseMapper12public interface MyBaseMapper&lt;T&gt; extends Mapper&lt;T&gt; &#123;&#125; 5.使用mapperscan扫描你可以给带有 @Configuration 的类配置该注解，或者直接配置到 Spring Boot 的启动类上 注意：这里使用的 tk.mybatis.spring.annotation.MapperScan ! 12345678@SpringBootApplication@tk.mybatis.spring.annotation.MapperScan(basePackages = "springboot.demo.dao")public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 6.编写dao12public interface PersonDao extends MyBaseMapper&lt;Person&gt; &#123;&#125; 7.单元测试123456789101112131415@WebAppConfiguration//用来声明加载的类是一个WebApplicationContext@RunWith(SpringRunner.class)@SpringBootTestpublic class DemoApplicationTests &#123; protected MockMvc mockMvc; @Autowired private WebApplicationContext wac; @Before public void setup() &#123; mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); //初始化MockMvc对象 //两种方式都可以初始化mockMvc，推荐用这种，上面的会自动跳转地址status判断方法无效 &#125;//这个方法在每个方法执行之前都会执行一遍&#125; 12345678910111213public class DaoExtendsTest extends DemoApplicationTests &#123; @Autowired private PersonDao personDao; @Test public void personDaoTest()&#123; List&lt;Person&gt; peoples = personDao.selectAll(); for (Person people : peoples) &#123; System.out.println(people); &#125; &#125;&#125; 注意事项！！！123自己写的MyBaseMapper&lt;T&gt;不能被扫描到，所以如果放在dao包内会被mapperscan，会报错！！错误为Caused by: org.springframework.beans.factory.BeanCreationException: Error creating bean with name &apos;myBaseMapper&apos; 所以 本例中MyBaseMapper并没有放在dao包内，而是另外创建了mapper包 从添加的application.properties配置也可以看出，切记！ 1mapper.mappers=springboot.demo.mapper.MyBaseMapper]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC中Controller通过Map给JSP页面传值]]></title>
    <url>%2F2019%2F05%2F11%2FSpringMVC%E4%B8%ADController%E9%80%9A%E8%BF%87Map%E7%BB%99JSP%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[一开始理解不了，后来看做是ModelMap方式传数据，稍微能理解点。。因为ModelMap也是继承与LinkedHashMap。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123; public ModelMap() &#123; &#125; public ModelMap(String attributeName, Object attributeValue) &#123; this.addAttribute(attributeName, attributeValue); &#125; public ModelMap(Object attributeValue) &#123; this.addAttribute(attributeValue); &#125; public ModelMap addAttribute(String attributeName, Object attributeValue) &#123; Assert.notNull(attributeName, "Model attribute name must not be null"); this.put(attributeName, attributeValue); return this; &#125; public ModelMap addAttribute(Object attributeValue) &#123; Assert.notNull(attributeValue, "Model object must not be null"); return attributeValue instanceof Collection &amp;&amp; ((Collection)attributeValue).isEmpty() ? this : this.addAttribute(Conventions.getVariableName(attributeValue), attributeValue); &#125; public ModelMap addAllAttributes(Collection&lt;?&gt; attributeValues) &#123; if (attributeValues != null) &#123; Iterator var2 = attributeValues.iterator(); while(var2.hasNext()) &#123; Object attributeValue = var2.next(); this.addAttribute(attributeValue); &#125; &#125; return this; &#125; public ModelMap addAllAttributes(Map&lt;String, ?&gt; attributes) &#123; if (attributes != null) &#123; this.putAll(attributes); &#125; return this; &#125; public ModelMap mergeAttributes(Map&lt;String, ?&gt; attributes) &#123; if (attributes != null) &#123; Iterator var2 = attributes.entrySet().iterator(); while(var2.hasNext()) &#123; Entry&lt;String, ?&gt; entry = (Entry)var2.next(); String key = (String)entry.getKey(); if (!this.containsKey(key)) &#123; this.put(key, entry.getValue()); &#125; &#125; &#125; return this; &#125; public boolean containsAttribute(String attributeName) &#123; return this.containsKey(attributeName); &#125;&#125; 请求的jsp页面： 123&lt;form action="addUser" method="post" enctype="multipart/form-data"&gt; &lt;input type="submit" value="新增用户"&gt;&lt;/form&gt; Controller： 1234567891011/** * 新增用户 * @param user * @return */ @RequestMapping("/addUser") public String addUser(User user,Map&lt;String, Object&gt; map)&#123; System.out.println(user); map.put("names", "小明"); return "success"; &#125; jsp页面取值： 12345678910111213&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 新增成功 $&#123;requestScope.names&#125;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot配置filter]]></title>
    <url>%2F2019%2F05%2F11%2Fspringboot%E9%85%8D%E7%BD%AEfilter%2F</url>
    <content type="text"><![CDATA[使用Filter实例在SpringBoot中使用Filter也有两种方式：注解注册Filter和代码注册，同样也分别进行举例：通过注解的方式进行注册：配合@Order(1)指定过滤器顺序 12345678910111213141516171819202122@WebFilter(urlPatterns = "/*", filterName = "myfilter")@Order(1)public class FileterController implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println("Filter初始化中"); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println("开始进行过滤处理"); //调用该方法后，表示过滤器经过原来的url请求处理方法 filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; System.out.println("Filter销毁中"); &#125;&#125; 启动类中@SpringBootApplication使用@ServletComponentScan 注解1@ServletComponentScan(value = &quot;com.example.admin.config.filter&quot;)//配置扫描filter位置 @ServletComponentScan作用： 12345Servlet可以直接通过@WebServlet注解自动注册Filter可以直接通过@WebFilter注解自动注册Listener可以直接通过@WebListener 注解自动注册 通过代码注册的方式来使用Filter：1234567891011121314151617181920public class FileterController implements Filter &#123; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; System.out.println("Filter初始化中"); &#125; @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123; System.out.println("开始进行过滤处理"); //调用该方法后，表示过滤器经过原来的url请求处理方法 filterChain.doFilter(servletRequest, servletResponse); &#125; @Override public void destroy() &#123; System.out.println("Filter销毁中"); &#125;&#125; 12345678910111213141516171819202122@SpringBootApplicationpublic class Main &#123; /** * 代码方式注册Bean * @return */ @Bean public FilterRegistrationBean setFilter()&#123; FilterRegistrationBean filterBean = new FilterRegistrationBean(); filterBean.setFilter(new FilterController()); filterBean.setName("FilterController"); filterBean.addUrlPatterns("/*"); return filterBean; &#125; public static void main(String[] args)&#123; SpringApplication.run(Main.class, args); &#125;&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[freemarker静态化]]></title>
    <url>%2F2019%2F05%2F11%2Ffreemarker%E9%9D%99%E6%80%81%E5%8C%96%2F</url>
    <content type="text"><![CDATA[freemarker静态化1、使用模板文件静态化定义模板文件，使用freemarker静态化程序生成html文件。2、使用模板字符串静态化定义模板字符串，使用freemarker静态化程序生成html文件。 使用模板文件静态化模板省略，依赖省略 1234567891011121314151617181920212223242526//基于模板生成静态化文件@Testpublic void testGenerateHtml() throws IOException, TemplateException &#123; //创建配置类 Configuration configuration=new Configuration(Configuration.getVersion());北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-90901.3.3.2 使用模板字符串静态化 //设置模板路径 String classpath = this.getClass().getResource("/").getPath(); configuration.setDirectoryForTemplateLoading(new File(classpath + "/templates/")); //设置字符集 configuration.setDefaultEncoding("utf‐8"); //加载模板 Template template = configuration.getTemplate("test1.ftl"); //数据模型 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("name","黑马程序员"); //静态化 String content = FreeMarkerTemplateUtils.processTemplateIntoString(template, map); //静态化内容 System.out.println(content); InputStream inputStream = IOUtils.toInputStream(content); //输出文件 FileOutputStream fileOutputStream = new FileOutputStream(new File("d:/test1.html")); int copy = IOUtils.copy(inputStream, fileOutputStream);&#125; 使用模板字符串静态化123456789101112131415161718192021222324252627282930313233//基于模板字符串生成静态化文件@Testpublic void testGenerateHtmlByString() throws IOException, TemplateException &#123; //创建配置类 Configuration configuration=new Configuration(Configuration.getVersion()); //模板内容，这里测试时使用简单的字符串作为模板 String templateString="" + "&lt;html&gt;\n" + " &lt;head&gt;&lt;/head&gt;\n" + " &lt;body&gt;\n" + " 名称：$&#123;name&#125;\n" + " &lt;/body&gt;\n" + "&lt;/html&gt;"; //模板加载器 StringTemplateLoader stringTemplateLoader = new StringTemplateLoader(); stringTemplateLoader.putTemplate("template",templateString); configuration.setTemplateLoader(stringTemplateLoader); //得到模板 Template template = configuration.getTemplate("template","utf‐8"); //数据模型 Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("name","黑马程序员"); //静态化 String content = FreeMarkerTemplateUtils.processTemplateIntoString(template, map); //静态化内容 System.out.println(content);北京市昌平区建材城西路金燕龙办公楼一层 电话：400-618-9090 InputStream inputStream = IOUtils.toInputStream(content); //输出文件 FileOutputStream fileOutputStream = new FileOutputStream(new File("d:/test1.html")); IOUtils.copy(inputStream, fileOutputStream);&#125;]]></content>
      <categories>
        <category>freemarker</category>
      </categories>
      <tags>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RestTemplate]]></title>
    <url>%2F2019%2F05%2F11%2FRestTemplate%2F</url>
    <content type="text"><![CDATA[RestTemplate转自https://www.jianshu.com/p/0fd5f3f64137 这个作者写的真全！！！ RestTemplate默认依赖jdk的HTTP连接工具。当然你也可以 通过setRequestFactory属性切换到不同的HTTP源，比如Apache HttpComponents、Netty和OkHttp。 1.创建RestTemplate创建RestTemplate很简单，只需要new RestTemplate()，如果使用Spring架构，将创建的RestTemplate实例通过XML或注解的方式注册到Spring容器中即可 1234@Beanpublic RestTemplate restTemplate() &#123; return new RestTemplate();&#125; 2.RestTemplate构造方法RestTemplate无参构造 123456789101112131415161718192021222324252627282930313233343536/** * Create a new instance of the &#123;@link RestTemplate&#125; using default settings. * Default &#123;@link HttpMessageConverter&#125;s are initialized. * 使用默认配置创建一个RestTemplate实例 * 默认的HttpMessageConverter集合被初始化 */public RestTemplate() &#123; this.messageConverters.add(new ByteArrayHttpMessageConverter()); this.messageConverters.add(new StringHttpMessageConverter()); this.messageConverters.add(new ResourceHttpMessageConverter()); this.messageConverters.add(new SourceHttpMessageConverter&lt;Source&gt;()); this.messageConverters.add(new AllEncompassingFormHttpMessageConverter()); if (romePresent) &#123; this.messageConverters.add(new AtomFeedHttpMessageConverter()); this.messageConverters.add(new RssChannelHttpMessageConverter()); &#125; if (jackson2XmlPresent) &#123; this.messageConverters.add(new MappingJackson2XmlHttpMessageConverter()); &#125; else if (jaxb2Present) &#123; this.messageConverters.add(new Jaxb2RootElementHttpMessageConverter()); &#125; /** * 如果类路径下包含com.fasterxml.jackson.databind.ObjectMapper 和 com.fasterxml.jackson.core.JsonGenerator * 使用jackson做http请求、响应的json转换 */ if (jackson2Present) &#123; this.messageConverters.add(new MappingJackson2HttpMessageConverter()); &#125; else if (gsonPresent) &#123; this.messageConverters.add(new GsonHttpMessageConverter()); &#125;&#125; 参数为ClientHttpRequestFactory的构造 1234567891011121314/** * Create a new instance of the &#123;@link RestTemplate&#125; based on the given &#123;@link ClientHttpRequestFactory&#125;. * @param requestFactory HTTP request factory to use * @see org.springframework.http.client.SimpleClientHttpRequestFactory * @see org.springframework.http.client.HttpComponentsClientHttpRequestFactory * 使用指定的ClientHttpRequestFactory创建一个RestTemplate实例 * requestFactory是用于创建HTTP请求的工厂，默认的实现有 * SimpleClientHttpRequestFactory、HttpComponentsClientHttpRequestFactory * 如果没有设置默认是SimpleClientHttpRequestFactory */public RestTemplate(ClientHttpRequestFactory requestFactory) &#123; this(); //也会调用无参构造初始化默认的messageConverters setRequestFactory(requestFactory);&#125; 参数为messageConverters的构造 1234567891011/** * Create a new instance of the &#123;@link RestTemplate&#125; using the given list of * &#123;@link HttpMessageConverter&#125; to use * @param messageConverters the list of &#123;@link HttpMessageConverter&#125; to use * @since 3.2.7 * 传入自定义的HttpMessageConverter集合，并赋值给messageConverters，之后使用自定义的HttpMessageConverter */public RestTemplate(List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters) &#123; Assert.notEmpty(messageConverters, "At least one HttpMessageConverter required"); this.messageConverters.addAll(messageConverters);&#125; 3.RestTemplate API使用DELETE void delete(String url, Object… uriVariables) void delete(String url, Map&lt;String,?&gt; uriVariables) void delete(URI url) GET T getForObject(String url, Class responseType, Object… uriVariables) T getForObject(String url, Class responseType, Map&lt;String,?&gt; uriVariables) T getForObject(URI url, Class responseType) ResponseEntity getForEntity(String url, Class responseType, Object… uriVariables) ResponseEntity getForEntity(String url, Class responseType, Map&lt;String,?&gt; uriVariables) ResponseEntity getForEntity(URI url, Class responseType) HEAD HttpHeaders headForHeaders(String url, Object… uriVariables) HttpHeaders headForHeaders(String url, Map&lt;String,?&gt; uriVariables) HttpHeaders headForHeaders(URI url) OPTIONS Set optionsForAllow(String url, Object… uriVariables) Set optionsForAllow(String url, Map&lt;String,?&gt; uriVariables) Set optionsForAllow(URI url) POST T postForObject(String url, Object request, Class responseType, Object… uriVariables) T postForObject(String url, Object request, Class responseType, Map&lt;String,?&gt; uriVariables) T postForObject(URI url, Object request, Class responseType) ResponseEntity postForEntity(String url, Object request, Class responseType, Object… uriVariables) ResponseEntity postForEntity(String url, Object request, Class responseType, Map&lt;String,?&gt; uriVariables) ResponseEntity postForEntity(URI url, Object request, Class responseType) PUT void put(String url, Object request, Object… uriVariables) void put(String url, Object request, Map&lt;String,?&gt; uriVariables) void put(URI url, Object request) PATCH and othersexchange()、execute() 注意，使用字符串类型的url默认会对url进行转义，如http://example.com/hotel list在执行时会转义为http://example.com/hotel%20list，这样其实是没有问题的，但如果字符串类型的url本身已经转义过了，执行时就会再转义一次，变成http://example.com/hotel%2520list。如果不需要这种隐式的转义，可以使用java.net.URI参数的方法，这种方法不会在执行时存在隐式的url转义，可以在创建URI对象时自行决定是否转义，推荐使用UriComponentsBuilder创建URI 1234567UriComponents uriComponents = UriComponentsBuilder.fromUriString( "http://example.com/hotels/&#123;hotel&#125;/bookings/&#123;booking&#125;") .build() //build(true)就不会对url转义，但如果包含http://example.com/hotel list这种需要转义的url，会报错 .expand("42", "21") .encode();URI uri = uriComponents.toUri(); exchange 和execute 方法比上面列出的其它方法（如getForObject、postForEntity等）使用范围更广，允许调用者指定HTTP请求的方法（GET、POST、PUT等），并且可以支持像HTTP PATCH（部分更新），但需要底层的HTTP库支持，JDK自带的HttpURLConnection不支持PATCH方法，Apache的HTTPClient 4.2及以后版本支持作 4.getForEntity()12345678910111213141516171819202122232425262728/** * 参数1： String类型 或 URI类型的请求地址 * 参数2： 指定返回的实体类型，class对象 * 参数3： uri参数，可以是变长数组或map * 返回值：ResponseEntity&lt;T&gt;是Spring对HTTP响应的封装，包括了几个重要的元素，如响应码、contentType、contentLength、response header信息，response body信息等 */@Overridepublic &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException &#123; RequestCallback requestCallback = acceptHeaderRequestCallback(responseType); ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(responseType); return execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables);&#125;@Overridepublic &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException &#123; RequestCallback requestCallback = acceptHeaderRequestCallback(responseType); ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(responseType); return execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables);&#125;@Overridepublic &lt;T&gt; ResponseEntity&lt;T&gt; getForEntity(URI url, Class&lt;T&gt; responseType) throws RestClientException &#123; RequestCallback requestCallback = acceptHeaderRequestCallback(responseType); ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(responseType); return execute(url, HttpMethod.GET, requestCallback, responseExtractor);&#125; 12345ResponseEntity&lt;Book&gt; responseEntity = restTemplate.getForEntity("http://127.0.0.1:8080/getbook?bookname=&#123;1&#125;", Book.class, "java");Book book = responseEntity.getBody(); //响应体转换为Book类型int statusCodeValue = responseEntity.getStatusCodeValue(); //响应状态码HttpHeaders headers = responseEntity.getHeaders(); //响应头信息 5.getForObject()发送GET请求，返回指定的Object类型 1234567891011121314151617181920212223242526272829/** * 参数1： String类型 或 URI类型的请求地址 * 参数2： 指定返回的实体类型，class对象 * 参数3： uri参数，可以是变长数组或map * 返回值：responseType指定的Object类型 */@Overridepublic &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException &#123; RequestCallback requestCallback = acceptHeaderRequestCallback(responseType); HttpMessageConverterExtractor&lt;T&gt; responseExtractor = new HttpMessageConverterExtractor&lt;T&gt;(responseType, getMessageConverters(), logger); return execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables);&#125;@Overridepublic &lt;T&gt; T getForObject(String url, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException &#123; RequestCallback requestCallback = acceptHeaderRequestCallback(responseType); HttpMessageConverterExtractor&lt;T&gt; responseExtractor = new HttpMessageConverterExtractor&lt;T&gt;(responseType, getMessageConverters(), logger); return execute(url, HttpMethod.GET, requestCallback, responseExtractor, uriVariables);&#125;@Overridepublic &lt;T&gt; T getForObject(URI url, Class&lt;T&gt; responseType) throws RestClientException &#123; RequestCallback requestCallback = acceptHeaderRequestCallback(responseType); HttpMessageConverterExtractor&lt;T&gt; responseExtractor = new HttpMessageConverterExtractor&lt;T&gt;(responseType, getMessageConverters(), logger); return execute(url, HttpMethod.GET, requestCallback, responseExtractor);&#125; 1Book book = restTemplate.getForObject("http://127.0.0.1:8080/getbook?bookname=&#123;1&#125;", Book.class, "java"); 6.postForEntity()123456789101112131415161718192021222324252627/** * 参数1： String类型 或 URI类型的请求地址 * 参数2： 请求body，可以是HttpEntity类型（可设置request header），或其它Object类型 * 参数3： 指定返回的实体类型，class对象 * 参数4： uri参数，可以是变长数组或map * 返回值：ResponseEntity&lt;T&gt;是Spring对HTTP响应的封装，包括了几个重要的元素，如响应码、contentType、contentLength、response header信息，response body信息等 */@Overridepublic &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException &#123; RequestCallback requestCallback = httpEntityCallback(request, responseType); ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(responseType); return execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables);&#125;@Overridepublic &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException &#123; RequestCallback requestCallback = httpEntityCallback(request, responseType); ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(responseType); return execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables);&#125;@Overridepublic &lt;T&gt; ResponseEntity&lt;T&gt; postForEntity(URI url, Object request, Class&lt;T&gt; responseType) throws RestClientException &#123; RequestCallback requestCallback = httpEntityCallback(request, responseType); ResponseExtractor&lt;ResponseEntity&lt;T&gt;&gt; responseExtractor = responseEntityExtractor(responseType); return execute(url, HttpMethod.POST, requestCallback, responseExtractor);&#125; 123456//参数是Book类型，返回值是ResponseEntity&lt;Book&gt;类型ResponseEntity&lt;Book&gt; responseEntity = restTemplate.postForEntity("http://127.0.0.1:8080/updateBook", book, Book.class);Book book = responseEntity.getBody(); //响应体转换为Book类型int statusCodeValue = responseEntity.getStatusCodeValue(); //响应状态码HttpHeaders headers = responseEntity.getHeaders(); //响应头信息 7.postForObject()1234567891011121314151617181920212223242526272829303132/** * 参数1： String类型 或 URI类型的请求地址 * 参数2： 请求body，可以是HttpEntity类型（可设置request header），或其它Object类型 * 参数3： 指定返回的实体类型，class对象 * 参数4： uri参数，可以是变长数组或map * 返回值：responseType指定的Object类型 */@Overridepublic &lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Object... uriVariables) throws RestClientException &#123; RequestCallback requestCallback = httpEntityCallback(request, responseType); HttpMessageConverterExtractor&lt;T&gt; responseExtractor = new HttpMessageConverterExtractor&lt;T&gt;(responseType, getMessageConverters(), logger); return execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables);&#125;@Overridepublic &lt;T&gt; T postForObject(String url, Object request, Class&lt;T&gt; responseType, Map&lt;String, ?&gt; uriVariables) throws RestClientException &#123; RequestCallback requestCallback = httpEntityCallback(request, responseType); HttpMessageConverterExtractor&lt;T&gt; responseExtractor = new HttpMessageConverterExtractor&lt;T&gt;(responseType, getMessageConverters(), logger); return execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables);&#125;@Overridepublic &lt;T&gt; T postForObject(URI url, Object request, Class&lt;T&gt; responseType) throws RestClientException &#123; RequestCallback requestCallback = httpEntityCallback(request, responseType); HttpMessageConverterExtractor&lt;T&gt; responseExtractor = new HttpMessageConverterExtractor&lt;T&gt;(responseType, getMessageConverters()); return execute(url, HttpMethod.POST, requestCallback, responseExtractor);&#125; 12//参数是Book类型，返回值也是Book类型Book book = restTemplate.postForObject("http://127.0.0.1:8080/updatebook", book, Book.class); 8.exchange方法 可以支持多种HTTP方法，在参数中指定 可以在请求中增加header和body信息，返回类型是ResponseEntity，可以从中获取响应的状态码，header和body等信息 ​ 123456789101112HttpHeaders requestHeaders = new HttpHeaders();requestHeaders.set("MyRequestHeader", "MyValue");HttpEntity requestEntity = new HttpEntity(requestHeaders);HttpEntity&lt;String&gt; response = template.exchange( "http://example.com/hotels/&#123;hotel&#125;", HttpMethod.GET, //GET请求 requestEntity, //requestEntity，可以设置请求header、body String.class, "42");String responseHeader = response.getHeaders().getFirst("MyResponseHeader"); //响应头信息String body = response.getBody(); 9.RestTemplate扩展/配置处理请求头和响应头如果是发送post、put请求，要设置请求头，可以在调用方法时的第二个参数传入HttpEntity对象，HttpEntity可以用于设置请求头信息，如 12345HttpHeaders requestHeaders = new HttpHeaders();requestHeaders.set("MyRequestHeader", "MyValue");HttpEntity requestEntity = new HttpEntity(requestHeaders);Book book = restTemplate.postForObject("http://127.0.0.1:8080/getbook", requestEntity, Book.class); 如果是其它HTTP方法调用要设置请求头，可以使用exchange()方法 12345678910HttpHeaders requestHeaders = new HttpHeaders();requestHeaders.set("MyRequestHeader", "MyValue");HttpEntity requestEntity = new HttpEntity(requestHeaders);HttpEntity&lt;String&gt; response = template.exchange( "http://example.com/hotels/&#123;hotel&#125;", HttpMethod.GET, requestEntity, String.class, "42");String responseHeader = response.getHeaders().getFirst("MyResponseHeader");String body = response.getBody(); 总之，设置request header信息，需要找到对应的restTemplate方法中可以使用HttpEntity作为参数的，提前设置好请求头信息 注意：HttpEntity有4个构造方法，无参构造，只设置请求body，只设置headers，既设置headers又设置body 123456789101112131415161718192021222324252627282930313233343536/** * Create a new, empty &#123;@code HttpEntity&#125;. */protected HttpEntity() &#123; this(null, null);&#125;/** * Create a new &#123;@code HttpEntity&#125; with the given body and no headers. * @param body the entity body */public HttpEntity(T body) &#123; this(body, null);&#125;/** * Create a new &#123;@code HttpEntity&#125; with the given headers and no body. * @param headers the entity headers */public HttpEntity(MultiValueMap&lt;String, String&gt; headers) &#123; this(null, headers);&#125;/** * Create a new &#123;@code HttpEntity&#125; with the given body and headers. * @param body the entity body * @param headers the entity headers */public HttpEntity(T body, MultiValueMap&lt;String, String&gt; headers) &#123; this.body = body; HttpHeaders tempHeaders = new HttpHeaders(); if (headers != null) &#123; tempHeaders.putAll(headers); &#125; this.headers = HttpHeaders.readOnlyHttpHeaders(tempHeaders);&#125; 处理响应头信息使用RestTemplate中xxxForEntity()的方法，会返回ResponseEntity，可以从中获取到响应状态码，响应头和body等信息 1234567891011HttpHeaders requestHeaders = new HttpHeaders();requestHeaders.set("MyRequestHeader", "MyValue");HttpEntity requestEntity = new HttpEntity(requestHeaders);HttpEntity&lt;String&gt; response = template.exchange( "http://example.com/hotels/&#123;hotel&#125;", HttpMethod.GET, requestEntity, String.class, "42");//response相关信息String responseHeader = response.getHeaders().getFirst("MyResponseHeader");String body = response.getBody(); 10.ClientHttpRequestFactoryClientHttpRequestFactory是Spring定义的一个接口，其用于生产 org.springframework.http.client.ClientHttpRequest对象，RestTemplate只是模板类，抽象了很多调用方 法，而底层真正使用何种框架发送HTTP请求是通过ClientHttpRequestFactory指定的 1234567891011121314151617181920212223242526/** * Factory for &#123;@link ClientHttpRequest&#125; objects. * Requests are created by the &#123;@link #createRequest(URI, HttpMethod)&#125; method. * ClientHttpRequest对象的工厂 * * @author Arjen Poutsma * @since 3.0 */public interface ClientHttpRequestFactory &#123; /** * Create a new &#123;@link ClientHttpRequest&#125; for the specified URI and HTTP method. * &lt;p&gt;The returned request can be written to, and then executed by calling * &#123;@link ClientHttpRequest#execute()&#125;. * 使用指定的URI和HTTP方法新建一个ClientHttpRequest对象 * 可以修改返回的request，并通过ClientHttpRequest的execute()方法执行调用 * 即调用的逻辑也被Spring封装到ClientHttpRequest中 * * @param uri the URI to create a request for * @param httpMethod the HTTP method to execute * @return the created request * @throws IOException in case of I/O errors */ ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException;&#125; RestTemplate可以在构造时设置ClientHttpRequestFactory，也可以通过setRequestFactory()方法设置 1234567891011构造方法设置：/** * Create a new instance of the &#123;@link RestTemplate&#125; based on the given &#123;@link ClientHttpRequestFactory&#125;. * @param requestFactory HTTP request factory to use * @see org.springframework.http.client.SimpleClientHttpRequestFactory * @see org.springframework.http.client.HttpComponentsClientHttpRequestFactory */public RestTemplate(ClientHttpRequestFactory requestFactory) &#123; this(); setRequestFactory(requestFactory);&#125; 可以看到上面注释中已经给出了Spring的两种ClientHttpRequestFactory的实现类SimpleClientHttpRequestFactory和HttpComponentsClientHttpRequestFactory 11.SimpleClientHttpRequestFactory如果什么都不设置，RestTemplate默认使用的是SimpleClientHttpRequestFactory，其内部使用的是jdk的 java.net.HttpURLConnection创建底层连接，默认是没有连接池的，connectTimeout和readTimeout都是 -1，即没有超时时间 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public class SimpleClientHttpRequestFactory implements ClientHttpRequestFactory, AsyncClientHttpRequestFactory &#123; 。。。。。。 private int connectTimeout = -1; private int readTimeout = -1; //创建Request @Override public ClientHttpRequest createRequest(URI uri, HttpMethod httpMethod) throws IOException &#123; HttpURLConnection connection = openConnection(uri.toURL(), this.proxy); prepareConnection(connection, httpMethod.name()); //bufferRequestBody默认为true if (this.bufferRequestBody) &#123; return new SimpleBufferingClientHttpRequest(connection, this.outputStreaming); &#125; else &#123; return new SimpleStreamingClientHttpRequest(connection, this.chunkSize, this.outputStreaming); &#125; &#125; /** * Opens and returns a connection to the given URL. * 打开并返回一个指定URL的连接 * &lt;p&gt;The default implementation uses the given &#123;@linkplain #setProxy(java.net.Proxy) proxy&#125; - * if any - to open a connection. * @param url the URL to open a connection to * @param proxy the proxy to use, may be &#123;@code null&#125; * @return the opened connection 返回类型为 java.net.HttpURLConnection * @throws IOException in case of I/O errors */ protected HttpURLConnection openConnection(URL url, Proxy proxy) throws IOException &#123; URLConnection urlConnection = (proxy != null ? url.openConnection(proxy) : url.openConnection()); if (!HttpURLConnection.class.isInstance(urlConnection)) &#123; throw new IllegalStateException("HttpURLConnection required for [" + url + "] but got: " + urlConnection); &#125; return (HttpURLConnection) urlConnection; &#125; /** * Template method for preparing the given &#123;@link HttpURLConnection&#125;. * &lt;p&gt;The default implementation prepares the connection for input and output, and sets the HTTP method. * @param connection the connection to prepare * @param httpMethod the HTTP request method (&#123;@code GET&#125;, &#123;@code POST&#125;, etc.) * @throws IOException in case of I/O errors */ protected void prepareConnection(HttpURLConnection connection, String httpMethod) throws IOException &#123; //如果connectTimeout大于等于0，设置连接超时时间 if (this.connectTimeout &gt;= 0) &#123; connection.setConnectTimeout(this.connectTimeout); &#125; //如果readTimeout大于等于0，设置读超时时间 if (this.readTimeout &gt;= 0) &#123; connection.setReadTimeout(this.readTimeout); &#125; connection.setDoInput(true); if ("GET".equals(httpMethod)) &#123; connection.setInstanceFollowRedirects(true); &#125; else &#123; connection.setInstanceFollowRedirects(false); &#125; if ("POST".equals(httpMethod) || "PUT".equals(httpMethod) || "PATCH".equals(httpMethod) || "DELETE".equals(httpMethod)) &#123; connection.setDoOutput(true); &#125; else &#123; connection.setDoOutput(false); &#125; connection.setRequestMethod(httpMethod); &#125; 。。。。。。&#125; 12.HttpComponentsClientHttpRequestFactoryHttpComponentsClientHttpRequestFactory底层使用Apache HttpClient创建请求，访问远程的Http服务，可 以使用一个已经配置好的HttpClient实例创建HttpComponentsClientHttpRequestFactory请求工厂， HttpClient实例中可以配置连接池和证书等信息 添加HttpClient依赖12345&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt; &lt;!-- springboot项目不用指定 --&gt;&lt;/dependency&gt; 设置超时时间设置超时时间，可以直接使用Spring的底层基于HttpClient的HttpComponentsClientHttpRequestFactory，此处设置的是ClientHttpRequestFactory级别的全局超时时间 12345678910111213141516@Configuration public class RestTemplateConfig &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(clientHttpRequestFactory()); &#125; @Bean private ClientHttpRequestFactory clientHttpRequestFactory() &#123; HttpComponentsClientHttpRequestFactory factory = new HttpComponentsClientHttpRequestFactory(); factory.setConnectTimeout(30 * 1000); //连接超时时间 factory.setReadTimeout(60 * 1000); //读超时时间 return factory; &#125; &#125; 注意：如果通过一个HttpClient实例创建HttpComponentsClientHttpRequestFactory，并通过HttpClient指定了 DefaultRequestConfig，设置了connectTimeout、readTimeout等，在实际执行请求创建request时会与 HttpComponentsClientHttpRequestFactory的配置合并，connectTimeout、socketTimeout、 connectionRequestTimeout 以HttpComponentsClientHttpRequestFactory的配置为准 1234567891011121314151617181920212223242526272829HttpComponentsClientHttpRequestFactory：/** * Merge the given &#123;@link HttpClient&#125;-level &#123;@link RequestConfig&#125; with * the factory-level &#123;@link RequestConfig&#125;, if necessary. * @param clientConfig the config held by the current httpClient级别的requestConfig配置 * @return the merged request config * (may be &#123;@code null&#125; if the given client config is &#123;@code null&#125;) * @since 4.2 */protected RequestConfig mergeRequestConfig(RequestConfig clientConfig) &#123; if (this.requestConfig == null) &#123; // nothing to merge return clientConfig; &#125; RequestConfig.Builder builder = RequestConfig.copy(clientConfig); int connectTimeout = this.requestConfig.getConnectTimeout(); //HttpComponentsClientHttpRequestFactory级别的配置 if (connectTimeout &gt;= 0) &#123; builder.setConnectTimeout(connectTimeout); &#125; int connectionRequestTimeout = this.requestConfig.getConnectionRequestTimeout(); if (connectionRequestTimeout &gt;= 0) &#123; builder.setConnectionRequestTimeout(connectionRequestTimeout); &#125; int socketTimeout = this.requestConfig.getSocketTimeout(); if (socketTimeout &gt;= 0) &#123; builder.setSocketTimeout(socketTimeout); &#125; return builder.build();&#125; 上例中虽然没有指定http连接池，但HttpComponentsClientHttpRequestFactory无参构造会创建一个HttpClient，并默认使用了连接池配置，MaxTotal=10，DefaultMaxPerRoute=5 ，具体如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172HttpComponentsClientHttpRequestFactory：/** * Create a new instance of the &#123;@code HttpComponentsClientHttpRequestFactory&#125; * with a default &#123;@link HttpClient&#125;. */public HttpComponentsClientHttpRequestFactory() &#123; this(HttpClients.createSystem());&#125;HttpClients：/** * Creates &#123;@link CloseableHttpClient&#125; instance with default * configuration based on system properties. * 创建CloseableHttpClient实例使用基于system properties的默认配置 */public static CloseableHttpClient createSystem() &#123; return HttpClientBuilder.create().useSystemProperties().build();&#125;HttpClientBuilder：/** * Use system properties when creating and configuring default * implementations. */public final HttpClientBuilder useSystemProperties() &#123; this.systemProperties = true; //设置systemProperties为true return this;&#125;public CloseableHttpClient build() &#123; HttpClientConnectionManager connManagerCopy = this.connManager; //没有设置，为null if (connManagerCopy == null) &#123; 。。。。。。 //创建连接池管理器PoolingHttpClientConnectionManager @SuppressWarnings("resource") final PoolingHttpClientConnectionManager poolingmgr = new PoolingHttpClientConnectionManager( RegistryBuilder.&lt;ConnectionSocketFactory&gt;create() .register("http", PlainConnectionSocketFactory.getSocketFactory()) .register("https", sslSocketFactoryCopy) .build(), null, null, dnsResolver, connTimeToLive, connTimeToLiveTimeUnit != null ? connTimeToLiveTimeUnit : TimeUnit.MILLISECONDS); if (defaultSocketConfig != null) &#123; poolingmgr.setDefaultSocketConfig(defaultSocketConfig); &#125; if (defaultConnectionConfig != null) &#123; poolingmgr.setDefaultConnectionConfig(defaultConnectionConfig); &#125; //由于是HttpClientBuilder.create().useSystemProperties().build(),systemProperties为true if (systemProperties) &#123; String s = System.getProperty("http.keepAlive", "true"); //http.keepAlive默认值为true if ("true".equalsIgnoreCase(s)) &#123; s = System.getProperty("http.maxConnections", "5"); //默认值为5 final int max = Integer.parseInt(s); poolingmgr.setDefaultMaxPerRoute(max); //DefaultMaxPerRoute=5 poolingmgr.setMaxTotal(2 * max); //MaxTotal=10 &#125; &#125; if (maxConnTotal &gt; 0) &#123; poolingmgr.setMaxTotal(maxConnTotal); &#125; if (maxConnPerRoute &gt; 0) &#123; poolingmgr.setDefaultMaxPerRoute(maxConnPerRoute); &#125; connManagerCopy = poolingmgr; &#125;&#125; 配置连接池1234567891011121314151617181920212223242526272829303132333435@Configuration public class RestTemplateConfig &#123; @Bean public RestTemplate restTemplate() &#123; return new RestTemplate(clientHttpRequestFactory()); &#125; @Bean public HttpComponentsClientHttpRequestFactory clientHttpRequestFactory() &#123; try &#123; HttpClientBuilder httpClientBuilder = HttpClientBuilder.create(); //开始设置连接池 PoolingHttpClientConnectionManager poolingHttpClientConnectionManager = new PoolingHttpClientConnectionManager(); poolingHttpClientConnectionManager.setMaxTotal(100); //最大连接数 poolingHttpClientConnectionManager.setDefaultMaxPerRoute(20); //同路由并发数 httpClientBuilder.setConnectionManager(poolingHttpClientConnectionManager); HttpClient httpClient = httpClientBuilder.build(); // httpClient连接配置 HttpComponentsClientHttpRequestFactory clientHttpRequestFactory = new HttpComponentsClientHttpRequestFactory(httpClient); clientHttpRequestFactory.setConnectTimeout(30 * 1000); //连接超时 clientHttpRequestFactory.setReadTimeout(60 * 1000); //数据读取超时时间 clientHttpRequestFactory.setConnectionRequestTimeout(30 * 1000); //连接不够用的等待时间 return clientHttpRequestFactory; &#125; catch (Exception e) &#123; logger.error("初始化clientHttpRequestFactory出错", e); &#125; return null; &#125; &#125; 13.自定义messageConverterRestTemplate的无参构造中默认会初始化很多messageConverters，用于请求/响应中的消息转换 123456789101112131415161718192021222324252627282930313233343536/** * Create a new instance of the &#123;@link RestTemplate&#125; using default settings. * Default &#123;@link HttpMessageConverter&#125;s are initialized. * 使用默认配置创建一个RestTemplate实例 * 默认的HttpMessageConverter集合被初始化 */public RestTemplate() &#123; this.messageConverters.add(new ByteArrayHttpMessageConverter()); this.messageConverters.add(new StringHttpMessageConverter()); this.messageConverters.add(new ResourceHttpMessageConverter()); this.messageConverters.add(new SourceHttpMessageConverter&lt;Source&gt;()); this.messageConverters.add(new AllEncompassingFormHttpMessageConverter()); if (romePresent) &#123; this.messageConverters.add(new AtomFeedHttpMessageConverter()); this.messageConverters.add(new RssChannelHttpMessageConverter()); &#125; if (jackson2XmlPresent) &#123; this.messageConverters.add(new MappingJackson2XmlHttpMessageConverter()); &#125; else if (jaxb2Present) &#123; this.messageConverters.add(new Jaxb2RootElementHttpMessageConverter()); &#125; /** * 如果类路径下包含com.fasterxml.jackson.databind.ObjectMapper 和 com.fasterxml.jackson.core.JsonGenerator * 使用jackson做http请求、响应的json转换 */ if (jackson2Present) &#123; this.messageConverters.add(new MappingJackson2HttpMessageConverter()); &#125; else if (gsonPresent) &#123; //类路径下包含 com.google.gson.Gson this.messageConverters.add(new GsonHttpMessageConverter()); &#125;&#125; springboot项目默认使用jackson做json转换 14.使用fastjson做json转换 引入fastjson依赖 排除jackson的HttpMessageConverter转换器 添加fastjson的转换器 排除jackson的HttpMessageConverter转换器有两种方式： 1.类路径下去掉jackson的支持从RestTemplate的无参构造可以看出，需要判断类路径下是否有jackson的相关类，有才会添加 MappingJackson2HttpMessageConverter，故可以在pom.xml中排除jackson的支持，以springboot项目举例 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt; 2.在初始化配置RestTemplate时，去掉其默认的MappingJackson2HttpMessageConverter12345678910111213141516171819202122232425262728293031323334353637383940@Beanpublic RestTemplate restTemplate() &#123; RestTemplate restTemplate = new RestTemplate(); restTemplate.setRequestFactory(clientHttpRequestFactory()); //restTemplate默认的HttpMessageConverter List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConverters = restTemplate.getMessageConverters(); List&lt;HttpMessageConverter&lt;?&gt;&gt; messageConvertersNew = new ArrayList&lt;HttpMessageConverter&lt;?&gt;&gt;(); for(HttpMessageConverter httpMessageConverter : messageConverters)&#123; //跳过MappingJackson2HttpMessageConverter if (httpMessageConverter instanceof MappingJackson2HttpMessageConverter) continue; messageConvertersNew.add(httpMessageConverter); &#125; //添加fastjson转换器 messageConvertersNew.add(fastJsonHttpMessageConverter()); return restTemplate;&#125;@Beanpublic HttpMessageConverter fastJsonHttpMessageConverter() &#123; //MediaType List&lt;MediaType&gt; mediaTypes = new ArrayList&lt;&gt;(); mediaTypes.add(MediaType.APPLICATION_JSON_UTF8); //FastJsonConfig FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setSerializerFeatures(SerializerFeature.WriteMapNullValue, SerializerFeature.QuoteFieldNames); //创建FastJsonHttpMessageConverter4 Spring 4.2后使用 FastJsonHttpMessageConverter4 fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter4(); fastJsonHttpMessageConverter.setSupportedMediaTypes(mediaTypes); fastJsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig); return fastJsonHttpMessageConverter;&#125; 15.SpringBoot中使用RestTemplateSpringBoot没有提供自动配置好的RestTemplate，但是自动配置好了可以用于创建RestTemplate的RestTemplateBuilder实例，可以按如下使用 1234567891011121314@Servicepublic class MyBean &#123; private final RestTemplate restTemplate; public MyBean(RestTemplateBuilder restTemplateBuilder) &#123; this.restTemplate = restTemplateBuilder.build(); &#125; public Details someRestCall(String name) &#123; return this.restTemplate.getForObject("/&#123;name&#125;/details", Details.class, name); &#125;&#125; 16.RestTemplate自定义RestTemplate自定义主要有三种方法，具体取决于希望自定义应用的范围 类范围。为了尽量缩小自定义的范围，在类中注入自动配置的RestTemplateBuilder，然后根据需求调用它的配置方法，每次调用配置方法都会 new RestTemplateBuilder()并返回，所以对RestTemplateBuilder的配置只会影响由它创建的RestTemplate 应用范围。可以使用RestTemplateCustomizer来自定义应用范围的的RestTemplate，所有注册到Spring容器的RestTemplateCustomizer都会自动生效。如下，通过RestTemplateCustomizer设置连接池 12345678910111213141516171819202122232425262728@Bean public RestTemplateCustomizer restTemplateCustomizer()&#123; return new RestTemplateCustomizer()&#123; @Override public void customize(RestTemplate restTemplate) &#123; HttpClientBuilder httpClientBuilder = HttpClientBuilder.create(); //创建连接管理器 PoolingHttpClientConnectionManager poolingHttpClientConnectionManager = new PoolingHttpClientConnectionManager(); poolingHttpClientConnectionManager.setMaxTotal(100); poolingHttpClientConnectionManager.setDefaultMaxPerRoute(20); httpClientBuilder.setConnectionManager(poolingHttpClientConnectionManager); //创建httpClient HttpClient httpClient = httpClientBuilder.build(); //创建HttpComponentsClientHttpRequestFactory HttpComponentsClientHttpRequestFactory httpComponentsClientHttpRequestFactory = new HttpComponentsClientHttpRequestFactory(httpClient); httpComponentsClientHttpRequestFactory.setConnectTimeout(10 * 1000); httpComponentsClientHttpRequestFactory.setReadTimeout(60 * 1000); httpComponentsClientHttpRequestFactory.setConnectionRequestTimeout(20 * 1000); restTemplate.setRequestFactory(httpComponentsClientHttpRequestFactory); &#125; &#125;; &#125; 最后，最极端的（也是很少使用的）选项是创建你自己的RestTemplateBuilder bean。这将关闭RestTemplateBuilder的自动配置，并阻止使用任何RestTemplateCustomizer bean]]></content>
      <categories>
        <category>RestTemplate</category>
      </categories>
      <tags>
        <tag>RestTemplate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GridFS]]></title>
    <url>%2F2019%2F05%2F11%2FGridFS%2F</url>
    <content type="text"><![CDATA[GridFSGridFS简介GridFS是MongoDB提供的用于持久化存储文件的模块，CMS使用MongoDB存储数据，使用GridFS可以快速集成开发。 在GridFS存储文件是将文件分块存储，文件会按照256KB的大小分割成多个块进行存储，GridFS使用两个集合（collection）存储文件，一个集合是chunks, 用于存储文件的二进制数据；一个集合是files，用于存储文件的元数据信息（文件名称、块大小、上传时间等信息）。 GridFS 存文件需要MongoDB依赖 1234567891011121314@ResourceGridFsTemplate gridFsTemplate;@Test public void testGridFs() throws FileNotFoundException &#123; //要存储的文件 File file = new File("d:/index_banner.html"); //定义输入流 FileInputStream inputStram = new FileInputStream(file); //向GridFS存储文件 ObjectId objectId = = gridFsTemplate.store(inputStram, "轮播图测试文件01", ""); //得到文件ID String fileId = objectId.toString(); System.out.println(fileId); &#125; 文件存储成功得到一个文件id此文件id是fs.files集合中的主键。可以通过文件id查询fs.chunks表中的记录，得到文件的内容。 GridFS 读取文件在config包中定义Mongodb的配置类 1234567891011@Configurationpublic class MongoConfig &#123; @Value("$&#123;spring.data.mongodb.database&#125;") String db; @Bean public GridFSBucket getGridFSBucket(MongoClient mongoClient)&#123; MongoDatabase database = mongoClient.getDatabase(db); GridFSBucket bucket = GridFSBuckets.create(database); return bucket; &#125;&#125; 测试代码如下 123456789101112131415161718192021222324@SpringBootTest @RunWith(SpringRunner.class) public class GridFsTest &#123; @Autowired GridFsTemplate gridFsTemplate; @Autowired GridFSBucket gridFSBucket; @Test public void queryFile() throws IOException &#123; String fileId = "5b9c54e264c614237c271a99"; //根据id查询文件 GridFSFile gridFSFile =gridFsTemplate.findOne(Query.query(Criteria.where("_id").is(fileId))); //打开下载流对象 GridFSDownloadStream gridFSDownloadStream =gridFSBucket.openDownloadStream(gridFSFile.getObjectId()); //创建gridFsResource，用于获取流对象 GridFsResource gridFsResource = new GridFsResource(gridFSFile,gridFSDownloadStream); //获取流中的数据 String s = IOUtils.toString(gridFsResource.getInputStream(), "UTF‐8"); System.out.println(s); &#125; ... GridFS删除文件12345@Testpublic void testDelFile() throws IOException &#123; //根据文件id删除fs.files和fs.chunks中的记录 gridFsTemplate.delete(Query.query(Criteria.where("_id").is("5b32480ed3a022164c4d2f92")));&#125;]]></content>
      <categories>
        <category>GridFS</category>
      </categories>
      <tags>
        <tag>GridFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java遇到的注解5]]></title>
    <url>%2F2019%2F04%2F22%2Fjava%E9%81%87%E5%88%B0%E7%9A%84%E6%B3%A8%E8%A7%A35%2F</url>
    <content type="text"><![CDATA[@RequestParam@RequestParam用于将请求参数区数据映射到功能处理方法的参数上。 1public String queryUserName(@RequestParam String userName) 在url中输入:localhost:8080/**/?userName=zhangsan 请求中包含username参数（如/requestparam1?userName=zhang），则自动传入。 接下来我们看一下@RequestParam注解主要有哪些参数： value：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入； required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码； defaultValue：默认值，表示如果请求中没有同名参数时的默认值，默认值可以是SpEL表达式，如“#{systemProperties[‘java.vm.version’]}”。表示请求中可以没有名字为username的参数，如果没有默认为null，此处需要注意如下几点： 1public String queryUserName(@RequestParam(value="userName" ,required =false ) String userName) 原子类型：必须有值，否则抛出异常，如果允许空值请使用包装类代替。 ​ Boolean包装类型类型：默认Boolean.FALSE，其他引用类型默认为null。 12public String requestparam5( @RequestParam(value="username", required=true, defaultValue="zhang") String username) 如果没有传入参数,则默认是”zhangsan”. 但是在传递参数的时候如果是url?userName=zhangsan&amp;userName=wangwu时怎么办呢? 其实在实际roleList参数入参的数据为“zhangsan,wangwu”，即多个数据之间使用“，”分割；我们应该使用如下方式来接收多个请求参数： 1public String requestparam8(@RequestParam(value="userName") String [] userNames) 1public String requestparam8(@RequestParam(value="list") List&lt;String&gt; list) @RequestHeader@RequestHeader用于将请求的头信息区数据映射到功能处理方法的参数上。 1234@RequestMapping(value="/header") public String test( @RequestHeader("User-Agent") String userAgent, @RequestHeader(value="Accept") String[] accepts) 如上配置将自动将请求头“User-Agent”值入参到userAgent参数上，并将“Accept”请求头值入参到accepts参数上。 @RequestHeader也拥有和@RequestParam相同的三个参数，含义一样。 @SessionAttributes绑定命令对象到session有时候我们需要在多次请求之间保持数据，一般情况需要我们明确的调用HttpSession的API来存取会话数据，如多步骤提交的表单。Spring Web MVC提供了@SessionAttributes进行请求间透明的存取会话数据。 1234567891011121314151617181920//1、在控制器类头上添加@SessionAttributes注解 @SessionAttributes(value = &#123;"user"&#125;) //① public class SessionAttributeController //2、@ModelAttribute注解的方法进行表单引用对象的创建 @ModelAttribute("user") //② public UserModel initUser() //3、@RequestMapping注解方法的@ModelAttribute注解的参数进行命令对象的绑定 @RequestMapping("/session1") //③ public String session1(@ModelAttribute("user") UserModel user) //4、通过SessionStatus的setComplete()方法清除@SessionAttributes指定的会话数据 @RequestMapping("/session2") //③ public String session(@ModelAttribute("user") UserModel user, SessionStatus status) &#123; if(true) &#123; //④ status.setComplete(); &#125; return "success"; &#125; @SessionAttributes(value = {“user”})含义： @SessionAttributes(value = {“user”}) 标识将模型数据中的名字为“user” 的对象存储到会话中（默认HttpSession），此处value指定将模型数据中的哪些数据（名字进行匹配）存储到会话中，此外还有一个types属性表示模型数据中的哪些类型的对象存储到会话范围内，如果同时指定value和types属性则那些名字和类型都匹配的对象才能存储到会话范围内。 包含@SessionAttributes的执行流程如下所示： ① 首先根据@SessionAttributes注解信息查找会话内的对象放入到模型数据中； ② 执行@ModelAttribute注解的方法：如果模型数据中包含同名的数据，则不执行@ModelAttribute注解方法进行准备表单引用数据，而是使用①步骤中的会话数据；如果模型数据中不包含同名的数据，执行@ModelAttribute注解的方法并将返回值添加到模型数据中； ③ 执行@RequestMapping方法，绑定@ModelAttribute注解的参数：查找模型数据中是否有@ModelAttribute注解的同名对象，如果有直接使用，否则通过反射创建一个；并将请求参数绑定到该命令对象； 此处需要注意：如果使用@SessionAttributes注解控制器类之后，③步骤一定是从模型对象中取得同名的命令对象，如果模型数据中不存在将抛出HttpSessionRequiredException Expected session attribute ‘user’(Spring3.1) 或HttpSessionRequiredException Session attribute ‘user’ required - not found in session(Spring3.0)异常。 ④ 如果会话可以销毁了，如多步骤提交表单的最后一步，此时可以调用SessionStatus对象的setComplete()标识当前会话的@SessionAttributes指定的数据可以清理了，此时当@RequestMapping功能处理方法执行完毕会进行清理会话数据。 @CookieValue绑定Cookie数据值@CookieValue用于将请求的Cookie数据映射到功能处理方法的参数上。 1public String test(@CookieValue(value="JSESSIONID", defaultValue="") String sessionId) 如上配置将自动将JSESSIONID值入参到sessionId参数上，defaultValue表示Cookie中没有JSESSIONID时默认为空。 1public String test2(@CookieValue(value="JSESSIONID", defaultValue="") Cookie sessionId) 传入参数类型也可以是javax.servlet.http.Cookie类型 测试代码在CookieValueTypeController中。@CookieValue也拥有和@RequestParam相同的三个参数，含义一样。 @RequestBody主要用来接收前端传递给后端的json字符串中的数据的(请求体中的数据的); GET方式无请求体，所以使用@RequestBody接收数据时，前端不能使用GET方式提交数据，而是用POST方式进行提交。 只接收POST请求Body里的数据。 @InitBinder在使用SpingMVC框架的项目中，经常会遇到页面某些数据类型是Date、Integer、Double等的数据要绑定到控制器的实体，或者控制器需要接受这些数据，如果这类数据类型不做处理的话将无法绑定。 由@InitBinder表示的方法，可以对WebDataBinder对象进行初始化。WebDataBinder是DataBinder的子类，用于完成由表单到JavaBean属性的绑定。 @InitBinder方法不能有返回值，它必须盛名为void。 @InitBinder方法的参数通常是WebDataBinder，@InitBinder可以对WebDataBinder进行初始化。 @DateTimeFormat用于springmvc封装数据时转换日期格式 加载实体类的属性上，很方便 1@DateTimeFormat(pattern="yyyy-MM-dd HH:mm") com.alibaba.dubbo.config.annotation.Service @Servicedubbo的service @reference是dubbo注解 @reference也是注入，但是一般用来注入分布式的远程服务对象，需要配合dubbo配置使用。 @Fieldsolr注解如下面示例代表该属性和Solrhome 的 schema.xml中名为item_title的域对应。 12@Field("item_title") private String title; @Dynamicsolr注解代表该属性为动态域 123@Dynamic @Field("item_spec_*") private Map&lt;String,String&gt; specMap; @JmsListener通过@JmsListener(destination = “queueName”) 注解，实现对特定队列的消费。 @InitBinder在使用SpingMVC框架的项目中，经常会遇到页面某些数据类型是Date、Integer、Double等的数据要绑定到控制器的实体，或者控制器需要接受这些数据，如果这类数据类型不做处理的话将无法绑定。 这里我们可以使用注解@InitBinder来解决这些问题，这样SpingMVC在绑定表单之前，都会先注册这些编辑器。一般会将这些方法些在BaseController中，需要进行这类转换的控制器只需继承BaseController即可。 其实Spring提供了很多的实现类，如CustomDateEditor、CustomBooleanEditor、CustomNumberEditor等，基本上是够用的。 1234567@InitBinderpublic void initBinder(WebDataBinder binder)&#123; SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); dateFormat.setLenient(false); binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, true));&#125; @PostConstruct和@PreConstruct注解1.@PostConstruct说明 ​ 被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器调用一次，类似于Serclet的inti()方法。被@PostConstruct修饰的方法会在构造函数之后，init()方法之前运行。 2.@PreDestroy说明 ​ 被@PreDestroy修饰的方法会在服务器卸载Servlet的时候运行，并且只会被服务器调用一次，类似于Servlet的destroy()方法。被@PreDestroy修饰的方法会在destroy()方法之后运行，在Servlet被彻底卸载之前。 @Entity注解必须与@Id注解 结合使用 否则 No identifier specified for entity: name 属性 (可选)实体名称。 缺省为实体类的非限定名称。 该名称用于引用查询中的实体。 该名称不能是Java持久性查询语言中的保留字面值。 不与@Table结合的话 表名 默认为 SnakeCaseStrategy(命名策略 )为表名 ​ 若使用 name属性 且没有与@Table结合 则表名为 name值的SnakeCaseStrategy(命名策略 ) 例如： 123@Entity public class UserEntity&#123;...&#125; 表名 user_entity @Entity(name=&quot;UE&quot;) public class UserEntity&#123;...&#125; 表名 ue @Entity(name=&quot;UsEntity&quot;) public class UserEntity&#123;...&#125; 表名 @ServletComponentScanSpringBootApplication 上使用@ServletComponentScan 注解后 Servlet可以直接通过@WebServlet注解自动注册 Filter可以直接通过@WebFilter注解自动注册 Listener可以直接通过@WebListener 注解自动注册 @JsonProperty此注解用于属性上，作用是把该属性的名称序列化为另外一个名称，如把trueName属性序列化为name，@JsonProperty(“name”)。 12@JsonProperty("name") private String trueName; @JsonProperty不仅仅是在序列化的时候有用，反序列化的时候也有用，比如有些接口返回的是json字符串，命名又不是标准的驼峰形式，在映射成对象的时候，将类的属性上加上@JsonProperty注解，里面写上返回的json串对应的名字]]></content>
      <categories>
        <category>注解</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java遇到的注解4]]></title>
    <url>%2F2019%2F04%2F22%2Fjava%E9%81%87%E5%88%B0%E7%9A%84%E6%B3%A8%E8%A7%A34%2F</url>
    <content type="text"><![CDATA[@Cacheable@Cacheable可以标记在一个方法上，也可以标记在一个类上。当标记在一个方法上时表示该方法是支持缓存的，当标记在一个类上时则表示该类所有的方法都是支持缓存的。对于一个支持缓存的方法，Spring会在其被调用后将其返回值缓存起来，以保证下次利用同样的参数来执行该方法时可以直接从缓存中获取结果，而不需要再次执行该方法。Spring在缓存方法的返回值时是以键值对进行缓存的，值就是方法的返回结果，至于键的话，Spring又支持两种策略，默认策略和自定义策略，这个稍后会进行说明。需要注意的是当一个支持缓存的方法在对象内部被调用时是不会触发缓存功能的。@Cacheable可以指定三个属性，value、key和condition。 1.value属性指定Cache名称value属性是必须指定的，其表示当前方法的返回值是会被缓存在哪个Cache上的，对应Cache的名称。其可以是一个Cache也可以是多个Cache，当需要指定多个Cache时其是一个数组。 1234@Cacheable("cache1")//Cache是发生在cache1上的 public User find(Integer id) &#123; return null; &#125; 1234@Cacheable(&#123;"cache1", "cache2"&#125;)//Cache是发生在cache1和cache2上的 public User find(Integer id) &#123; return null; &#125; 2. 使用key属性自定义keykey属性是用来指定Spring缓存方法的返回结果时对应的key的。该属性支持SpringEL表达式。当我们没有指定该属性时，Spring将使用默认策略生成key。我们这里先来看看自定义策略，至于默认策略会在后文单独介绍。 ​ 自定义策略是指我们可以通过Spring的EL表达式来指定我们的key。这里的EL表达式可以使用方法参数及它们对应的属性。使用方法参数时我们可以直接使用“#参数名”或者“#p参数index”。下面是几个使用参数作为key的示例。 1234@Cacheable(value="users", key="#id") public User find(Integer id) &#123; return null; &#125; 1234@Cacheable(value="users", key="#p0") public User find(Integer id) &#123; return null; &#125; 1234@Cacheable(value="users", key="#user.id") public User find(User user) &#123; return null; &#125; 1234@Cacheable(value="users", key="#p0.id") public User find(User user) &#123; return null; &#125; 除了上述使用方法参数作为key之外，Spring还为我们提供了一个root对象可以用来生成key。通过该root对象我们可以获取到以下信息。 属性名称 描述 示例 methodName 当前方法名 #root.methodName method 当前方法 #root.method.name target 当前被调用的对象 #root.target targetClass 当前被调用的对象的class #root.targetClass args 当前方法参数组成的数组 #root.args[0] caches 当前被调用的方法使用的Cache #root.caches[0].name 当我们要使用root对象的属性作为key时我们也可以将“#root”省略，因为Spring默认使用的就是root对象的属性。如： 1234@Cacheable(value=&#123;"users", "xxx"&#125;, key="caches[1].name") public User find(User user) &#123; return null; &#125; 3. condition属性指定发生的条件有的时候我们可能并不希望缓存一个方法所有的返回结果。通过condition属性可以实现这一功能。condition属性默认为空，表示将缓存所有的调用情形。其值是通过SpringEL表达式来指定的，当为true时表示进行缓存处理；当为false时表示不进行缓存处理，即每次调用该方法时该方法都会执行一次。如下示例表示只有当user的id为偶数时才会进行缓存。 12345@Cacheable(value=&#123;"users"&#125;, key="#user.id", condition="#user.id%2==0") public User find(User user) &#123; System.out.println("find user by user " + user); return user; &#125; @EnableCaching注解是spring framework中的注解驱动的缓存管理功能。自spring版本3.1起加入了该注解。如果你使用了这个注解，那么你就不需要在XML文件中配置cache manager了，等价于 1&lt;cache:annotation-driven/&gt; @EnableAutoConfiguration@SpringBootApplication包含了@ComponentScan、@Configuration和@EnableAutoConfiguration等注解。 其中的@EnableAutoConfiguration 12345678910111213@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(&#123;EnableAutoConfigurationImportSelector.class&#125;)public @interface EnableAutoConfiguration &#123; String ENABLED_OVERRIDE_PROPERTY = "spring.boot.enableautoconfiguration"; Class&lt;?&gt;[] exclude() default &#123;&#125;; String[] excludeName() default &#123;&#125;;&#125; 其中最关键的要属@Import(EnableAutoConfigurationImportSelector.class)，借助EnableAutoConfigurationImportSelector，@EnableAutoConfiguration可以帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。 @Conditional条件注解 通过@Conditional注解可以根据代码中设置的条件装载不同的bean，在设置条件注解之前，先要把装载的bean类去实现Condition接口，然后对该实现接口的类设置是否装载的条件 示例： 1、创建服务接口1234//一个服务接口public interface Person &#123; void birth();&#125; 2、接口实现类1234567public class Man implements Person &#123; @Override public void birth() &#123; System.out.println("我不会生孩子……"); &#125;&#125; 12345678public class Woman implements Person &#123; @Override public void birth() &#123; System.out.println("我要生孩子了……"); &#125;&#125; 3.创建条件类，实现Condition接口1234567public class ManCondition implements Condition &#123; @Override public boolean matches(ConditionContext arg0, AnnotatedTypeMetadata arg1) &#123; return false; &#125;&#125; 1234567public class WomanCondition implements Condition &#123; @Override public boolean matches(ConditionContext arg0, AnnotatedTypeMetadata arg1) &#123; return true; &#125;&#125; 4.创建配置类1234567891011121314151617@Configurationpublic class ConditionalConfig &#123; @Bean @Conditional(ManCondition.class) //如果ManCondition中的match方法返回结果true，就创建该Bean,否则不创建 public Man getMan()&#123; return new Man(); &#125; //如果ManCondition中的match方法返回结果true，就创建该Bean,否则不创建 @Bean @Conditional(WomanCondition.class) public Woman getWoman()&#123; return new Woman(); &#125;&#125; 5.测试1234567891011public class TestMain &#123; public static void main(String[] args) &#123; AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(ConditionalConfig.class); Person person = ctx.getBean(Person.class); //通过条件类判断，只有Woman的条件类返回true，所以在容器中只能找到Woman的实现类的装载bean,而Woman又是继承自Person的，所以，在容器中可以找到一个唯一的Bean,通过getBean获取到。 System.out.println(person); person.birth(); &#125; //控制台打印我要生孩子了……&#125; @ConditionalOnBean（仅仅在当前上下文中存在某个对象时，才会实例化一个Bean） @ConditionalOnClass（某个class位于类路径上，才会实例化一个Bean） @ConditionalOnExpression（当表达式为true的时候，才会实例化一个Bean） @ConditionalOnMissingBean（仅仅在当前上下文中不存在某个对象时，才会实例化一个Bean） @ConditionalOnMissingClass（某个class类路径上不存在的时候，才会实例化一个Bean） @ConditionalOnNotWebApplication（不是web应用） @Order用于为使用此批注注释的组件定义排序顺序。注解主要用来控制配置类的加载顺序 。 Spring中的事务是通过aop来实现的，当我们自己写aop拦截的时候，会遇到跟spring的事务aop执行的先后顺序问题，比如说动态切换数据源的问题，如果事务在前，数据源切换在后，会导致数据源切换失效，所以就用到了Order（排序）这个关键字. @EnableAspectJAutoProxy开启AOP，代替 1&lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; @EnableTransactionManagement开启spring事务管理，代替 1&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; @EnableWebMvc开启webMvc，代替 1&lt;mvc:annotation-driven /&gt; @EnableCaching开启缓存，代替 1&lt;cache:annotation-driven /&gt; @EnableAsync@EnableAsync注解开启异步方法的支持。 @EnableScheduling @EnableScheduling注解开启计划任务的支持。 也就是字面上的意思，开启计划任务的支持！一般都需要@Scheduled注解的配合。 @EnableConfigurationProperties@EnableConfigurationProperties注解是用来开启对@ConfigurationProperties注解配置Bean的支持。 也就是@EnableConfigurationProperties注解告诉Spring Boot 使能支持@ConfigurationProperties @EnableJpaRepositories注解开启对Spring Data JPA Repostory的支持。 Spring Data JPA 框架，主要针对的就是 Spring 唯一没有简化到的业务逻辑代码，至此，开发者连仅剩的实现持久层业务逻辑的工作都省了，唯一要做的，就只是声明持久层的接口，其他都交给 Spring Data JPA 来帮你完成！ @Bean和@Component区别Spring帮助我们管理Bean分为两个部分，一个是注册Bean，一个装配Bean。完成这两个动作有三种方式，一种是使用自动配置的方式、一种是使用JavaConfig的方式，一种就是使用XML配置的方式。 @Bean和@Configuration配合使用对应的是JavaConfig方式 @Component和@AutoWired配合使用对应的是自动配置的方式。 @Component去告诉Spring，我是一个bean，你要来管理我，然后使用@AutoWired注解依赖注入。 @Configuration其实就是告诉spring，spring容器要怎么配置（怎么去注册bean，怎么去处理bean之间的关系（装配））。那么久很好理解了，@Bean的意思就是，我要获取这个bean的时候，你spring要按照这种方式去帮我获取到这个bean。 @Bean用在方法上，@Component用在类上的。 shiro注解@RequiresAuthentication​ 使用该注解标注的类，实例，方法在访问或调用时，当前Subject必须在当前session中已经过认证。 @RequiresGuest​ 使用该注解标注的类，实例，方法在访问或调用时，当前Subject可以是“gust”身份，不需要经过认证或者在原先的session中存在记录。 @RequiresPermissions​ 当前Subject需要拥有某些特定的权限时，才能执行被该注解标注的方法。如果当前Subject不具有这样的权限，则方法不会被执行。 @RequiresRoles​ 当前Subject必须拥有所有指定的角色时，才能访问被该注解标注的方法。如果当天Subject不同时拥有所有指定角色，则方法不会执行还会抛出AuthorizationException异常。 @RequiresUser当前Subject必须是应用的用户，才能访问或调用被该注解标注的类，实例，方法。]]></content>
      <categories>
        <category>注解</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java遇到的注解3]]></title>
    <url>%2F2019%2F04%2F22%2Fjava%E9%81%87%E5%88%B0%E7%9A%84%E6%B3%A8%E8%A7%A33%2F</url>
    <content type="text"><![CDATA[@RestController@RestController = @Controller + @ResponseBody。 @Transactional 属性 类型 描述 value String 可选的限定描述符，指定使用的事务管理器 propagation enum: Propagation 可选的事务传播行为设置 isolation enum: Isolation 可选的事务隔离级别设置 readOnly boolean 读写或只读事务，默认读写 timeout int (in seconds granularity) 事务超时时间设置 rollbackFor Class对象数组，必须继承自Throwable 导致事务回滚的异常类数组 rollbackForClassName 类名数组，必须继承自Throwable 导致事务回滚的异常类名字数组 noRollbackFor Class对象数组，必须继承自Throwable 不会导致事务回滚的异常类数组 noRollbackForClassName 类名数组，必须继承自Throwable 不会导致事务回滚的异常类名字数组 指示spring事务管理器回滚一个事务的推荐方法是在当前事务的上下文内抛出异常 spring事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务 默认配置下，spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为 RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。 用 spring 事务管理器,由spring来负责数据库的打开,提交,回滚.默认遇到运行期异常(throw new RuntimeException(“注释”);)会回滚，即遇到不受检查（unchecked）的异常时回滚；而遇到需要捕获的异常 (throw new Exception(“注释”);)不会回滚,即遇到受检查的异常（就是非运行时抛出的异常，编译器会检查到的异 常叫受检查异常或说受检查异常）时，需我们指定方式来让事务回滚要想所有异常都回滚,要加上 @Transactional( rollbackFor={Exception.class,其它异常}) .如果让unchecked异常不回滚： @Transactional(notRollbackFor=RunTimeException.class) @Transactional 使用位置 类上方、方法上方Spring 建议不要在接口或者接口方法上使用该注解，因为这只有在使用基于接口的代理时它才会生效当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。 方法的访问权限为 public@Transactional 注解应该只被应用到 public 方法上，这是由 Spring AOP 的本质决定的。在 protected、private 或者默认可见性的方法上使用 @Transactional 注解，这将被忽略，也不会抛出任何异常 默认情况下，只有来自外部的方法调用才会被AOP代理捕获，也就是，类内部方法调用本类内部的其他方法并不会引起事务行为，即使被调用方法使用@Transactional注解进行修饰 12例如一：同一个类中方法，A方法未使用此标签，B使用了，C未使用，A 调用 B , B 调用 C ；则外部调用A之后，B的事务是不会起作用的例如二：若是有上层（按照 Controller层、Service层、DAO层的顺序）由Action 调用 Service 直接调用，发生异常会发生回滚；若间接调用，Action 调用 Service 中 的A 方法，A无@Transactional 注解，B有，A调用B，B的注解无效 @ContextConfiguration用来指定加载的Spring配置文件的位置,会加载默认配置文件。 Spring整合JUnit4测试时，使用注解引入多个配置文件。 @ContextConfiguration 注解有以下两个常用的属性： locations：可以通过该属性手工指定 Spring 配置文件所在的位置，可以指定一个或多个 Spring 配置文件。 inheritLocations：是否要继承父测试用例类中的 Spring 配置文件，默认为 true。 @RollbackSpring整合JUnit4测试时： 表明被注解方法的事务在完成后是否需要被回滚。 如果true，事务将被回滚，否则事务将被提交。 @NotTransactionalSpring整合JUnit4测试时： 出现该注解表明测试方法必须不在事务中执行。 @TransactionConfiguration为配置事务性测试定义了类级别的元数据。特别地，如果需要的PlatformTransactionManager不是“transactionManager”的话， 那么可以显式配置驱动事务的PlatformTransactionManager的bean名字。此外， 可以将defaultRollback标志改为false。通常， @TransactionConfiguration与@ContextConfiguration搭配使用。 123456@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfiguration@ContextConfiguration(locations = &#123; "classpath:spring.xml", "classpath:spring-mvc.xml", "classpath:spring/spring-mybatis.xml"&#125;)//当然 你可以声明一个事务管理 每个单元测试都进行事务回滚 无论成功与否@TransactionConfiguration@Transactional 但是上述写法已经过时，替代写法为 123456@RunWith(SpringJUnit4ClassRunner.class)@WebAppConfiguration@ContextConfiguration(locations = &#123; "classpath:spring.xml", "classpath:spring-mvc.xml", "classpath:spring/spring-mybatis.xml"&#125;)//当然 你可以声明一个事务管理 每个单元测试都进行事务回滚 无论成功与否@Rollback@Transactional @WebAppConfiguration(“src/main/resources”)注解在类上,用来声明加载的ApplicationContex 是一个WebApplicationContext ,它的属性指定的是Web资源的位置,默认为src/main/webapp ,自定义修改为 resource。 Junit常用注解@Before：初始化方法，@Test之前执行 @After：释放资源，@Test之后执行 @Test：测试方法，在这里可以测试期望异常和超时时间 @Ignore：忽略的测试方法 @BeforeClass：针对所有测试，只执行一次，且必须为static void @AfterClass：针对所有测试，只执行一次，且必须为static void @RunWith：指定使用的单元测试执行类 测试用例执行顺序 @BeforeClass ==&gt; @Before ==&gt; @Test ==&gt; @After ==&gt; @AfterClass @ControllerAdvice从名字上可以看出大体意思是控制器增强。 注解了@Controller的类的方法可以使用@ExceptionHandler、@InitBinder、@ModelAttribute注解到方法上，@ControllerAdvice注解将作用在 所有注解了@RequestMapping的控制器的方法上。 简单来说注解了@ControllerAdvice的类的方法就可以注解@ExceptionHandler、@InitBinder、@ModelAttribute。并将方法应用与注解了@RequestMapping的控制器的方法上。 典型的例子就是全局异常处理。 @RestControllerAdvice类似于 @RestController 与 @Controller的区别。 @RestControllerAdvice = @ControllerAdvice + @ResponseBody。 @MapperScan和@ComponentScan@MapperScan是mybatis的注解，@MapperScan扫描dao包代表包下的是mybatis的Mapper类。 Mapper类是接口，不需要我们写实现类，所以我们能看到service层使用@Service，controller层使用了@Controller却没有看到dao层使用@Repository注解。 测试时遇到过userDao报红如下，因为没有注入dao，即没有@Repository注解，但是已经配置了@MapperScan，所以虽然idea报红了但是仍然可以测试运行。如果要想不报红的话也很简单，只要加上@Repository并用@ComponentScan扫描就好了。 123456789public class DaoTest extends AnnotationSSMTest &#123; @Autowired private UserDao userDao; @Test public void userDaoTest()&#123; User user = userDao.queryUserByName("haha"); System.out.println(user); &#125;&#125; @ComponentScan是把类注入到SpringIOC中。 @SpringBootApplication包含了@ComponentScan、@Configuration和@EnableAutoConfiguration等注解。 其中@ComponentScan让springboot扫描到Configuration类并把它加入到程序上下文。 @EnableAutoConfiguration自动配置。 @Inject@Inject是JSR330 (Dependency Injection for Java)中的规范，需要导入javax.inject.Inject;实现注入。 @Inject是根据类型进行自动装配的，如果需要按名称进行装配，则需要配合@Named； @Inject可以作用在变量、setter方法、构造函数上。 @Named@Named(“XXX”) 中的 XX是 Bean 的名称，所以 @Inject和 @Named结合使用时，自动注入的策略就从 byType 转变成 byName 了。 @Autowired是spring自带的，@Inject是JSR330规范实现的，@Resource是JSR250规范实现的，需要导入不同的包 @Autowired、@Inject用法基本一样，不同的是@Autowired有一个request属性 @Autowired、@Inject是默认按照类型匹配的，@Resource是按照名称匹配的 @Autowired如果需要按照名称匹配需要和@Qualifier一起使用，@Inject和@Name一起使用 @MapperScan和@Mapper@MapperScan用于扫描dao包。在springboot项目中加在启动类上如下。也可以用@Mapper达到同样效果。只不过是在每一个dao类都要加。当启动类不和dao层，service层等同级时，@Mapper则不会有效果，而@MapperScan只要路径正确仍然有效。 12345678@SpringBootApplication@MapperScan("springboot.demo.dao")public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; @SpringApplicationConfiguration(Application.class)新版的Spring Boot取消了@SpringApplicationConfiguration这个注解，用@SpringBootTest就可以了。 swagger注解 @Api：修饰整个类，描述Controller的作用 @ApiOperation：描述一个类的一个方法，或者说一个接口 @ApiParam：单个参数描述 @ApiModel：用对象来接收参数 @ApiProperty：用对象接收参数时，描述对象的一个字段 @ApiResponse：HTTP响应其中1个描述 @ApiResponses：HTTP响应整体描述 @ApiIgnore：使用该注解忽略这个API @ApiError ：发生错误返回的信息 @ApiParamImplicitL：一个请求参数 @ApiParamsImplicit 多个请求参数 @GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping以@GetMapping为例 @GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。该注解将HTTP Get 映射到 特定的处理方法上。以此类推。]]></content>
      <categories>
        <category>注解</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java遇到的注解2]]></title>
    <url>%2F2019%2F04%2F22%2Fjava%E9%81%87%E5%88%B0%E7%9A%84%E6%B3%A8%E8%A7%A32%2F</url>
    <content type="text"><![CDATA[@Resource 和 @Autowired@Resource默认按照名称方式进行bean匹配。 @Autowired默认按照类型方式进行bean匹配 @Resource的作用相当于@Autowired，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入罢了。@Resource有两个属性是比较重要的，分是name和type，Spring将@Resource注解的name属性解析为bean的名字，而type属性则解析为bean的类型。所以如果使用name属性，则使用byName的自动注入策略，而使用type属性时则使用byType自动注入策略。如果既不指定name也不指定type属性，这时将通过反射机制使用byName自动注入策略。@Autowired默认按类型装配（这个注解是属业spring的），默认情况下必须要求依赖对象必须存在，如果我们想使用名称装配可以结合@Qualifier注解进行使用。 如果一个接口有许多实现类，就无法光靠type决定。推荐用@Resource，稳妥，而且@Resource属于J2EE的，减少了与spring的耦合。 @Resource 默认的名字是把类名前面的大写变成小写 @Bean@Bean是一个方法级别上的注解。标识一个用于配置和初始化一个由SpringIoc容器管理的新对象的方法，类似于XML配置文件的。可以在Spring的@Component注解的类中使用@Bean注解任何方法(仅仅是可以)通常和@Bean一起使用的是@Configuration,不是@Component。 123456@Configurationpublic class App&#123; 声明一个类，相当于一个配置文件@Beanpublic MyService myService()&#123;return new MyServiceImpl();&#125; 这个上面相当于下面 123&lt;beans&gt;&lt;bean id="myService" class="com.test.MyServiceImpl"/&gt;&lt;/beans&gt; @Configuration@Configuration用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。@Configuration标注在类上，相当于把该类作为spring的xml配置文件中的，作用为：配置spring容器(应用上下文)。 @Configuration注解的类必需使用&lt;context:component-scanbase-package=&quot;XXX&quot;/&gt;扫描 123456@Configurationpublic class TestConfiguration &#123; public TestConfiguration() &#123; System.out.println("TestConfiguration容器启动初始化。。。"); &#125;&#125; 1234567891011public class TestMain &#123; public static void main(String[] args) &#123; // @Configuration注解的spring容器加载方式，用AnnotationConfigApplicationContext替换ClassPathXmlApplicationContext ApplicationContext context = new AnnotationConfigApplicationContext(TestConfiguration.class); // 如果加载spring-context.xml文件： // ApplicationContext context = new // ClassPathXmlApplicationContext("spring-context.xml"); &#125;&#125; 运行main方法显示TestConfiguration容器启动初始化。。。；@Bean注解在返回实例的方法上，如果未通过@Bean指定bean的名称，则默认与标注的方法名相同；@Bean的作用是注册bean对象，那么完全可以使用@Component、@Controller、@Service、@Ripository等注解注册bean，当然需要配置@ComponentScan注解进行自动扫描。 @Primary@Primary标志这个 Bean 如果在多个同类 Bean 候选时，该 Bean 优先被考虑。简单地说，当有两个同一类型的Bean，依赖注入时你没有指定name，正常情况下会报错，有两个你要的Bean，识别不了。但是 @Primary 相当于指定这个Bean为默认的，如果你没有指定name，就采用 @Primary 标识的Bean。 @ConfigurationProperties1、在类上使用该注解2、在工厂方法上使用该注解 （@bean）就是绑定application.properties中的属性 。通过@ConfigurationProperties來获取配置信息。 方式1： 1234567891011121314@Getter@Setter@Configuration@PropertySource("classpath:db.properties")@ConfigurationProperties(prefix = "spring.datasource.sakila")public class DbConfigInfo &#123; private String url; private String username; private String password; private String driverClassName; private String initialSize; private String maxIdle; private String minIdle;&#125; 方式2： 12345678910111213141516@Configuration@PropertySource("classpath:db.properties")public class DBConfig &#123; @Primary @Bean("libraryDataSource") @ConfigurationProperties(prefix = "spring.datasource.library") public DataSource sakilaDataSource() &#123; return DataSourceBuilder.create().build(); &#125; @Bean("sakilaDataSource") @ConfigurationProperties(prefix = "spring.datasource.sakila") public DataSource libraryDataSource() &#123; return DataSourceBuilder.create().build(); &#125;&#125; @PropertySource指定配置文件位置 @PropertySource(“classpath:datasource.properties”) @ModelAttribute① 应用在方法上。② 应用在方法的参数上。③ 应用在方法上，并且方法也使用了@RequestMapping 首先说明一下，被 @ModelAttribute 注解的方法会在Controller每个方法执行之前都执行，因此对于一个Controller中包含多个URL的时候，要谨慎使用。 1) 使用 @ModelAttribute 注解无返回值的方法 1234567891011121314@Controller@RequestMapping("/modelattributeTest")public class ModelAttributeTestController1 &#123; @ModelAttribute public void myModel(@RequestParam(required = false) String abc, Model model) &#123; model.addAttribute("attributeName", abc); &#125; @RequestMapping(value = "/test1") public String test1() &#123; return "modelattributetest/test1"; &#125;&#125; 这个例子，在请求/modelattributeTest/test1?abc=aaa后，会先执行 myModel方法，然后接着执行test1方法，参数abc的值被放入Model中后，接着被带到 test方法中。当返回视图 modelattributetest/test1时，Model 会被带到页面上，当然你在使用 @RequestParam的时候可以使用required来指定参数是否是必须的。如果把 myModel和 test1 合二为一后的方法可以为，这也是我们最常用的方法： 12345@RequestMapping(value = "/test2")public String test1(@RequestParam(required = false) String abc, Model model) &#123; model.addAttribute("attributeName", abc); return "modelattributetest/test1";&#125; 2）使用 @ModelAttribute 注解带有返回值的方法 1234@ModelAttributepublic String myModel(@RequestParam(required = false) String abc) &#123; return abc;&#125; or 12345@ModelAttributepublic Student myModel(@RequestParam(required = false) String abc) &#123; Student stu = new Student(abc); return stu;&#125; 返回值对象会被默认放到隐含的 Model中，在 Model中的 key为 “返回值首字母小写”，value 为返回的值。等同于 12model.addAttribute("string", abc);model.addAttribute("student", stu); 想自定义其实很简单，只需要给@ModelAttribute添加value属性即可，如下： 1234@ModelAttribute(value = "num") public int myModel(@RequestParam(required = false) int number) &#123; return number;&#125; 想当于 1这样就相当于model.addAttribute(“num”, number); 3）使用 @ModelAttribute 注解方法参数 1234567891011121314151617181920212223@Controller@RequestMapping("/modelattributeTest3")public class ModelAttributeTestController3 &#123; @ModelAttribute(value = "attributeName") public String myModel(@RequestParam(required = false) String abc) &#123; return abc; &#125; @ModelAttribute public void myModel3(Model model) &#123; model.addAttribute("name", "SHANHY"); model.addAttribute("age", "28"); &#125; @RequestMapping(value = "/test1") public String test1(@ModelAttribute("attributeName") String str, @ModelAttribute("name") String str2, @ModelAttribute("age") String str3) &#123; return "modelattributetest/test1"; &#125;&#125; 使用 @ModelAttribute注解的参数，意思是从前面的 Model中提取对应名称的属性。 4）应用在方法上，并且方法也使用了@RequestMapping 12345678910@Controller@RequestMapping(&quot;/modelattributeTest4&quot;)public class ModelAttributeTestController4 &#123; @RequestMapping(value = &quot;/test1&quot;) @ModelAttribute(&quot;name&quot;) public String test1(@RequestParam(required = false) String name) &#123; return name; &#125;&#125; 返回值 String （或者其他对象），就不再是视图了,还是我们上面将到的放入 Model 中的值，此时对应的页面就是 @RequestMapping的值 test1。 @PathVariable@RequestParam注解是获取静态URL传入的参数。@PathVariable是获取请求路径中的变量作为参数 。 通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中：URL 中的 {xxx} 占位符可以通过@PathVariable(“xxx“) 绑定到操作方法的入参中。 1234567891011121314151617@RestController@RequestMapping(value="users")public class UserController &#123; @RequestMapping(value = "/list", method = &#123;RequestMethod.GET, RequestMethod.POST&#125;) public Map&lt;String, Object&gt; list(@RequestParam Long user_id) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("user_id", user_id); return map; &#125; @RequestMapping(value = "/get_user/&#123;user_id&#125;", method = &#123;RequestMethod.GET, RequestMethod.POST&#125;) public Map&lt;String, Object&gt; get_user(@PathVariable Long user_id) &#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put("user_id", user_id); return map; &#125;&#125; @JsonIgnore标在Javabean的属性上，作用是在将ResponseBody中的Javabean返回前端过程中，被springmvc自带的jackson转化成json字符串时，忽略这个属性，对序列化也有影响。 1234567891011public class Xxx &#123; private String attr1; @JsonIgnore private String attr2; public void setAttr1(String attr)&#123; this.attr1 = attr; &#125; public void setAttr2(String attr)&#123; this.attr2 = attr; &#125;&#125; @JsonFormat在转化为json对象时用于格式化。 在对象实体类中的属性或者get方法加注解：@JsonFormat（pattern=”yyyy-MM-dd”,timezone=”GMT+8”），通常用于格式化日期。]]></content>
      <categories>
        <category>注解</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java遇到的注解1]]></title>
    <url>%2F2019%2F04%2F22%2Fjava%E9%81%87%E5%88%B0%E7%9A%84%E6%B3%A8%E8%A7%A31%2F</url>
    <content type="text"><![CDATA[写在前面:注解的可用的类型包括以下几种：所有基本类型、String、Class、enum、Annotation、以上类型的数组形式。元素不能有不确定的值，即要么有默认值，要么在使用注解的时候提供元素的值。而且元素不能使用null作为默认值。注解在只有一个元素且该元素的名称是value的情况下，在使用注解的时候可以省略“value=”，直接写需要的值即可。 @Retention定义注解的保留策略@Retention(RetentionPolicy.SOURCE) //注解仅存在于源码中，在class字节码文件中不包含。@Retention(RetentionPolicy.CLASS) // 默认的保留策略，注解会在class字节码文件中存在，但运行时无法获得。@Retention(RetentionPolicy.RUNTIME) // 注解会在class字节码文件中存在，在运行时可以通过反射获取到。生命周期长度 SOURCE &lt; CLASS &lt; RUNTIME ，所以前者能作用的地方后者一定也能作用。一般如果需要在运行时去动态获取注解信息，那只能用 RUNTIME 注解；如果要在编译时进行一些预处理操作，比如生成一些辅助代码（如 ButterKnife），就用 CLASS注解；如果只是做一些检查性的操作，比如 @Override 和 @SuppressWarnings，则可选用 SOURCE 注解。 @Target定义注解的作用目标。@Target(ElementType.TYPE) //接口、类、枚举、注解@Target(ElementType.FIELD) //字段、枚举的常量@Target(ElementType.METHOD) //方法@Target(ElementType.PARAMETER) //方法参数@Target(ElementType.CONSTRUCTOR) //构造函数@Target(ElementType.LOCAL_VARIABLE)//局部变量@Target(ElementType.ANNOTATION_TYPE)//注解@Target(ElementType.PACKAGE) ///包 @Document说明该注解将被包含在javadoc中。 @Inherited说明子类可以继承父类中的该注解。 @Override用于标明此方法覆盖了父类的方法。 @Deprecated用于标明已经过时的方法或类。 @SuppressWarnnings用于有选择的关闭编译器对类、方法、成员变量、变量初始化的警告。 @Repeatable注解表明标记的注解可以多次应用于相同的声明或类型使用。 @AliasFor互为别名，标签有一些使用限制，但是这应该能想到的，比如要求互为别名的属性属性值类型，默认值，都是相同的，互为别名的注解必须成对出现，比如value属性添加了@AliasFor(“path”)，那么path属性就必须添加@AliasFor(“value”)，另外还有一点，互为别名的属性必须定义默认值。 @ResponseBody作用是将controller的方法返回的对象通过适当的转换器转换为指定的格式之后，写入到response对象的body区。通常用来返回JSON数据或者是XML。@ResponseBody 方式写json时 123456789101112131415161718192021222324@ResponseBody @RequestMapping(value = "/registerAction" ,produces = "application/json;charset=UTF-8") public String registerAction(User user)&#123; boolean isExist = userService.findUserEmail(user.getUser_email()); ObjectMapper mapper = new ObjectMapper(); if(isExist)&#123; String fail= null; try &#123; fail = mapper.writeValueAsString("fail"); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return fail; &#125; else &#123; String success = null; try &#123; success = mapper.writeValueAsString("success"); &#125; catch (JsonProcessingException e) &#123; e.printStackTrace(); &#125; return success; &#125; &#125; springboot包括了spring和springmvc。也包括了jackson。 ObjectMapper是在jackson包下的。writeValueAsString就是将对象转化为json字符串。 因为 String +ResponseBody = 返回值为String，没有进行转化，所以要手动转化！！好坑啊这个，浪费我好长时间，还以为前端出错了好吗！如果是对象的话会转化为自动json字符串的的。 @Component把普通pojo实例化到spring容器中，相当于配置文件中的 注解了@Component能被@ComponentScan扫描。 1&lt;bean id="" class=""/&gt; @Controller 控制器（注入服务） 用于标注控制层，相当于struts中的action层。 @Service 服务（注入dao） 用于标注服务层，主要用来进行业务的逻辑处理。 @Repository（实现dao访问） 用于标注数据访问层，也可以说用于标注数据访问组件，即DAO组件.。 @RequestMappingvalue：指定请求的实际地址，指定的地址可以是URI Template 模式；method： 指定请求的method类型， GET、POST、PUT、DELETE等；consumes：指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;consumes的例子（方法仅处理request Content-Type为“application/json”类型的请求。） 12345@Controller @RequestMapping(value = "/pets", method = RequestMethod.POST, consumes="application/json") public void addPet(@RequestBody Pet pet, Model model) &#123; // implementation omitted &#125; produces: 它的作用是指定返回值类型，不但可以设置返回值类型还可以设定返回值的字符编码；params： 指定request中必须包含某些参数值时，才让该方法处理。headers：指定request中必须包含某些指定的header值，才能让该方法处理请求。 关于content-typeGET 请求不存在请求实体部分，键值对参数放置在 URL 尾部，因此请求头不需要设置 Content-Type 字段。POST默认是application/x-www-form-urlencoded。会将表单内的数据转换拼接成 key-value。当然content-type还有其他取值。 @RequestBody别看成@ResponseBody 用来处理content-type不是默认的application/x-www-form-urlcoded编码的内容。当我们用get/post方式提交请求后， Content-Type的值有以下几种，分别对应能不能解析数据如下：1.application/x-www-form-urlencoded： 可选（即非必须，因为这种情况的数据@RequestParam, @ModelAttribute也可以处理，当然@RequestBody也能处理）2.multipart/form-data,：不能处理（即使用@RequestBody不能处理这种格式的数据）3.其他格式：（其他格式包括application/json, application/xml等），这些格式的数据，必须使用@RequestBody来处理 @RequestParam用于将请求参数区数据映射到功能处理方法的参数上。value：参数名字，即入参的请求参数名字，如username表示请求的参数区中的名字为username的参数的值将传入。required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报404错误码。defaultValue：默认值。]]></content>
      <categories>
        <category>注解</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring整合shiro注解]]></title>
    <url>%2F2018%2F12%2F30%2Fspring%E6%95%B4%E5%90%88shiro%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[shiro注解权限控制-5个权限注解RequiresAuthentication: 使用该注解标注的类，实例，方法在访问或调用时，当前Subject必须在当前session中已经过认证。 RequiresGuest: 使用该注解标注的类，实例，方法在访问或调用时，当前Subject可以是“gust”身份，不需要经过认证或者在原先的session中存在记录。 RequiresPermissions: 当前Subject需要拥有某些特定的权限时，才能执行被该注解标注的方法。如果当前Subject不具有这样的权限，则方法不会被执行。 RequiresRoles: 当前Subject必须拥有所有指定的角色时，才能访问被该注解标注的方法。如果当天Subject不同时拥有所有指定角色，则方法不会执行还会抛出AuthorizationException异常。 RequiresUser 当前Subject必须是应用的用户，才能访问或调用被该注解标注的类，实例，方法。 使用方法：Shiro的认证注解处理是有内定的处理顺序的，如果有个多个注解的话，前面的通过了会继续检查后面的，若不通过则直接返回，处理顺序依次为（与实际声明顺序无关）： RequiresRoles RequiresPermissions RequiresAuthentication RequiresUser RequiresGuest 例如：你同时声明了RequiresRoles和RequiresPermissions，那就要求拥有此角色的同时还得拥有相应的权限。 @RequiresRoles可以用在Controller或者方法上。可以多个roles，多个roles时默认逻辑为 AND也就是所有具备所有role才能访问。 示例1234567891011//属于user角色@RequiresRoles("user")//必须同时属于user和admin角色@RequiresRoles(&#123;"user","admin"&#125;)//属于user或者admin之一;修改logical为OR 即可@RequiresRoles(value=&#123;"user","admin"&#125;,logical=Logical.OR) @RequiresPermissions1234567891011//符合index:hello权限要求@RequiresPermissions("index:hello")//必须同时复核index:hello和index:world权限要求@RequiresPermissions(&#123;"index:hello","index:world"&#125;)//符合index:hello或index:world权限要求即可@RequiresPermissions(value=&#123;"index:hello","index:world"&#125;,logical=Logical.OR) RequiresAuthentication，RequiresUser，RequiresGuest都一样。 spring整合shiro开启注解需要引入aspectj依赖，如果有spring aop的话就不用了 在xml文件中加入以下即可使用上述注解 123456 &lt;!--开启aop，对类代理--&gt;&lt;aop:config proxy-target-class="true"&gt;&lt;/aop:config&gt;&lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt; &lt;property name="securityManager" ref="securityManager" /&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shiro未完待续3]]></title>
    <url>%2F2018%2F12%2F30%2Fshiro%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD3%2F</url>
    <content type="text"><![CDATA[转自http://blog.51cto.com/luchunli/1833372 https://www.cnblogs.com/yoohot/p/6085830.html 1.AbstractFilterShiro通过抽象类对Servlet的Filter接口进行了封装，并通过继承ServletContextSupport对ServletContext也进行了封装。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public abstract class AbstractFilter extends ServletContextSupport implements Filter &#123; private static final transient Logger log = LoggerFactory.getLogger(AbstractFilter.class); protected FilterConfig filterConfig; public AbstractFilter() &#123; &#125; public FilterConfig getFilterConfig() &#123; return this.filterConfig; &#125; // 初始化 FilterConfig 与 ServletContext public void setFilterConfig(FilterConfig filterConfig) &#123; this.filterConfig = filterConfig; // 调用ServletContextSupport的方法来封装ServletContext this.setServletContext(filterConfig.getServletContext()); &#125; // 从 FilterConfig 中获取初始参数 protected String getInitParam(String paramName) &#123; FilterConfig config = this.getFilterConfig(); return config != null ? StringUtils.clean(config.getInitParameter(paramName)) : null; &#125; public final void init(FilterConfig filterConfig) throws ServletException &#123; this.setFilterConfig(filterConfig); try &#123; this.onFilterConfigSet(); &#125; catch (Exception var3) &#123; if (var3 instanceof ServletException) &#123; throw (ServletException)var3; &#125; else &#123; if (log.isErrorEnabled()) &#123; log.error("Unable to start Filter: [" + var3.getMessage() + "].", var3); &#125; throw new ServletException(var3); &#125; &#125; &#125; protected void onFilterConfigSet() throws Exception &#123; &#125; public void destroy() &#123; &#125;&#125; 2、NameableFilter继承了AbstractFilter实现了Nameable 每个 Filter 必须有一个名字，可通过 setName 方法设置的，如果不设置就取该 Filter 默认的名字 123456789101112131415161718192021222324252627282930313233public abstract class NameableFilter extends AbstractFilter implements Nameable &#123; private String name; public NameableFilter() &#123; &#125; protected String getName() &#123; // 若成员变量 name 为空，则从 FilterConfig 中获取 Filter Name if (this.name == null) &#123; FilterConfig config = this.getFilterConfig(); if (config != null) &#123; this.name = config.getFilterName(); &#125; &#125; return this.name; &#125; public void setName(String name) &#123; this.name = name; &#125; protected StringBuilder toStringBuilder() &#123; String name = this.getName(); if (name == null) &#123; return super.toStringBuilder(); &#125; else &#123; StringBuilder sb = new StringBuilder(); sb.append(name); return sb; &#125; &#125;&#125; 3、OncePerRequestFilterOncePerRequestFilter extends NameableFilter 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public abstract class OncePerRequestFilter extends NameableFilter &#123; /** * 已执行过的过滤器（"already filtered"）附加的后缀名 * * @see #getAlreadyFilteredAttributeName */ public static final String ALREADY_FILTERED_SUFFIX = ".FILTERED"; /** * 是否开启过滤功能 * * @see #isEnabled() */ private boolean enabled = true; //most filters wish to execute when configured, so default to true public final void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws ServletException, IOException &#123; // 获取 Filter 已过滤的属性名 String alreadyFilteredAttributeName = getAlreadyFilteredAttributeName(); // 判断是否已过滤 if ( request.getAttribute(alreadyFilteredAttributeName) != null ) &#123; // 若已过滤，则进入 FilterChain 中下一个 Filter filterChain.doFilter(request, response); // 若未过滤，则判断是否未开启过滤功能（其中 shouldNotFilter 方法将被废弃 &#125; else if (!isEnabled(request, response) || shouldNotFilter(request) ) &#123; // 若未开启，则进入 FilterChain 中下一个 Filter filterChain.doFilter(request, response); &#125; else &#123; // Do invoke this filter...（执行过滤） // 将已过滤属性设置为 true（只要保证 Request 中有这个属性即可） request.setAttribute(alreadyFilteredAttributeName, Boolean.TRUE); try &#123; // 在子类中执行具体的过滤操作 doFilterInternal(request, response, filterChain); &#125; finally &#123; // 当前 Filter 执行结束需移除 Request 中的已过滤属性 request.removeAttribute(alreadyFilteredAttributeName); &#125; &#125; &#125; protected String getAlreadyFilteredAttributeName() &#123; String name = getName(); if (name == null) &#123; name = getClass().getName(); &#125; return name + ALREADY_FILTERED_SUFFIX; &#125; // 抽象方法，由子类实现 protected abstract void doFilterInternal(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException;&#125; 如何确保每个请求只会被同一个 Filter 拦截一次呢？Shiro 提供了一个超简单的解决方案：在 Requet 中放置一个后缀为.FILTERED 的属性，在执行具体拦截操作（即 doFilterInternal 方法）之前放入该属性，执行完毕后移除该属性。 在 Shiro 的 Filter Chian 配置中，如果我们想禁用某个 Filter，如何实现呢？OncePerRequestFilter也为我们提供了一个 enabled 的属性，方便我们可以在 shiro.ini 中随时禁用某个 Filter，例如： 12345[main]ssl.enabled = false[urls]/foo = ssl, authc 这样一来 ssl 这个 Filter 就被我们给禁用了，以后想开启 ssl 的话，完全不需要在 urls配置中一个个手工来添加，只需把 ssl.enabled 设置为 true，或注释掉该行，或直接删除该行即可。 4.AdviceFilterOncePerRequestFilter有两个子类 AdviceFilter和AbstractShiroFilter AdviceFilter extends OncePerRequestFilter doFilterInternal会先调用preHandle做一些前置判断，如果返回false则filter链不继续往下执行，postHandle在目标方法（即客户端请求的接口）正常（未抛出异常）执行后完成一些操作，默认不做任何操作。在finally中的cleanup方法中会调用afterCompletion方法，不管目标方法是否出现异常都会继续操作。 12345678910111213141516171819202122232425262728293031323334353637383940 //类似于AOP中的后置返回增强；在拦截器链执行完成后执行；进行后处理（如记录执行时间之类的）protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception &#123; return true; &#125;//类似于AOP中的前置增强；在拦截器链执行之前执行；如果返回true则继续拦截器链；否则中断后续的拦截器链的执行直接返回 protected void postHandle(ServletRequest request, ServletResponse response) throws Exception &#123; &#125;//类似于AOP中的后置最终增强；即不管有没有异常都会执行；可以进行清理资源 public void afterCompletion(ServletRequest request, ServletResponse response, Exception exception) throws Exception &#123; &#125; protected void executeChain(ServletRequest request, ServletResponse response, FilterChain chain) throws Exception &#123; chain.doFilter(request, response); &#125;//父类OncePerRequestFilter会调用，//OncePerRequestFilter中实现了doFilter方法具体逻辑在子类的doFilterInternal中。 public void doFilterInternal中。(ServletRequest request, ServletResponse response, FilterChain chain) throws ServletException, IOException &#123; Exception exception = null; try &#123; boolean continueChain = this.preHandle(request, response); if (log.isTraceEnabled()) &#123; log.trace("Invoked preHandle method. Continuing chain?: [" + continueChain + "]"); &#125; if (continueChain) &#123; this.executeChain(request, response, chain); &#125; this.postHandle(request, response); if (log.isTraceEnabled()) &#123; log.trace("Successfully invoked postHandle method"); &#125; &#125; catch (Exception var9) &#123; exception = var9; &#125; finally &#123; this.cleanup(request, response, exception); &#125; &#125; 5.PathMatchingFilterPathMatchingFilter extends AdviceFilter implements PathConfigProcessor PathMatchingFilter主要是对preHandle做进一步细化控制 该filter为抽象类，其他路径直接通过：preHandle中，若请求的路径非该filter中配置的拦截路径，则直接返回true进行下一个filter。若包含在此filter路径中，则会在isFilterChainContinued做一些控制，该方法中会调用onPreHandle方法，所以子类可以在onPreHandle中编写filter控制流程代码（返回true或false）。 6.AccessControlFilterAccessControlFilter extends PathMatchingFilter isAccessAllowed方法和onAccessDenied方法达到控制效果，这两个方法都是抽象方法，由子类去实现。 123public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123; return this.isAccessAllowed(request, response, mappedValue) || this.onAccessDenied(request, response, mappedValue); &#125; isAccessAllowed和onAccessDenied方法会影响到onPreHandle方法，而onPreHandle方法会影响到preHandle方法，而preHandle方法会达到控制filter链是否执行下去的效果。。所以如果正在执行的filter中isAccessAllowed和onAccessDenied都返回false，则整个filter控制链都将结束，不会到达目标方法（客户端请求的接口），而是直接跳转到某个页面（由filter定义的，将会在authc中看到） 7.AuthenticationFilter和AuthenticatingFilter认证的filterAuthenticatingFilter extends AuthenticationFilter 在抽象类中AuthenticatingFilter实现了isAccessAllowed方法，该方法是用来判断用户是否已登录，若未登录再判断是否请求的是登录地址，是登录地址则放行，否则返回false终止filter链。 AuthenticationFilter 12345// AuthenticationFilterprotected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) &#123; Subject subject = this.getSubject(request, response); return subject.isAuthenticated(); &#125; AuthenticatingFilter 123protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) &#123; return super.isAccessAllowed(request, response, mappedValue) || !this.isLoginRequest(request, response) &amp;&amp; this.isPermissive(mappedValue);&#125; 提供了executeLogin方法实现用户登录的，还定义了onLoginSuccess和onLoginFailure方法，在登录成功或者失败时做一些操作。 1234567891011121314151617181920212223protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception &#123; AuthenticationToken token = this.createToken(request, response); if (token == null) &#123; String msg = "createToken method implementation returned null. A valid non-null AuthenticationToken must be created in order to execute a login attempt."; throw new IllegalStateException(msg); &#125; else &#123; try &#123; Subject subject = this.getSubject(request, response); subject.login(token); return this.onLoginSuccess(token, subject, request, response); &#125; catch (AuthenticationException var5) &#123; return this.onLoginFailure(token, var5, request, response); &#125; &#125; &#125; protected boolean onLoginSuccess(AuthenticationToken token, Subject subject, ServletRequest request, ServletResponse response) throws Exception &#123; return true; &#125; protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) &#123; return false; &#125; 8.FormAuthenticationFilterFormAuthenticationFilter extends AuthenticatingFilter 实现了onAccessDenied方法 123456789101112131415161718192021222324protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception &#123; if (this.isLoginRequest(request, response)) &#123; if (this.isLoginSubmission(request, response)) &#123; if (log.isTraceEnabled()) &#123; log.trace("Login submission detected. Attempting to execute login."); &#125; return this.executeLogin(request, response); &#125; else &#123; if (log.isTraceEnabled()) &#123; log.trace("Login page view."); &#125; return true; &#125; &#125; else &#123; if (log.isTraceEnabled()) &#123; log.trace("Attempting to access a path which requires authentication. Forwarding to the Authentication url [" + this.getLoginUrl() + "]"); &#125; this.saveRequestAndRedirectToLogin(request, response); return false; &#125;&#125; 如果用户未登录，即AuthenticatingFilter中的isAccessAllowed判断了用户未登录，则会调用onAccessDenied方法做用户登录操作 调用AuthenticatingFilter中的executeLogin，executeLogin中调用onLoginSuccess和onLoginFailure。 12345678910111213protected boolean onLoginSuccess(AuthenticationToken token, Subject subject, ServletRequest request, ServletResponse response) throws Exception &#123; this.issueSuccessRedirect(request, response); return false; &#125; protected boolean onLoginFailure(AuthenticationToken token, AuthenticationException e, ServletRequest request, ServletResponse response) &#123; if (log.isDebugEnabled()) &#123; log.debug("Authentication exception", e); &#125; this.setFailureAttribute(request, e); return true; &#125; 9.自定义filter一般自定义filter可以继承三种： ①OncePerRequestFilter只需实现doFilterInternal方法即可，在这里面实现filter的功能。切记在该方法中最后调用filterChain.doFilter(request, response)，允许filter链继续执行下去。可以在这个自定义filter中覆盖isEnable达到控制该filter是否需要被执行（实质是doFilterInternal方法）以达到动态控制的效果，一般不建议直接继承这个类; ②AdviceFilter 中提供三个方法preHandle postHandle afterCompletion：若需要在目标方法执行前后都做一些判断的话应该继承这个类覆盖preHandle 和postHandle 。 ③PathMatchingFilter中preHandle实质会判断onPreHandle来决定是否继续往下执行。所以只需覆盖onPreHandle方法即可。 ④AccessControlFilter：最常用的，该filter中onPreHandle调用isAccessAllowed和onAccessDenied决定是否继续执行。一般继承该filter，isAccessAllowed决定是否继续执行。onAccessDenied做后续的操作，如重定向到另外一个地址、添加一些信息到request域等等。 ④若要自定义登录filter，一般是由于前端传过来的需求所定义的token与shiro默认提供token的不符，可以继承AuthenticatingFilter ，在这里面实现createToken来创建自定义token。另外需要自定义凭证匹配器credentialsMatcher。重写public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info)即可。realm也需要自定义以返回自定义的token。 10、总结 filter的核心是doFilter。shiro中对应的类是OncePerRequestFilter OncePerRequestFilter确保每个请求只会被同一个 Filter 拦截一次。 OncePerRequestFilter会调用doFilterInternal(request, response, filterChain)，doFilterInternal具体由子类实现。 子类AdviceFilter的doFilterInternal方法中主要是调用preHandle方法,preHandle方法主要逻辑有其子类实现。 1boolean continueChain = this.preHandle(request, response); PathMatchingFilter为AdviceFilter子类，实现了preHandle逻辑，其结果主要由onPreHandle控制。 onPreHandle逻辑由其子类实现控制。 AccessControlFilter继承PathMatchingFilter。实现了onPreHandle方法 123public boolean onPreHandle(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception &#123; return this.isAccessAllowed(request, response, mappedValue) || this.onAccessDenied(request, response, mappedValue); &#125; 其结果主要是isAccessAllowed和onAccessDenied逻辑控制。即登录成功要干什么，失败又要干什么。 对于登录而言isAccessAllowed和onAccessDenied逻辑在AuthenticationFilter，AuthenticatingFilter,FormAuthenticationFilter逻辑中 对于权限认证而言则在AuthorizationFilter，PermissionsAuthorizationFilter等类中]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter]]></title>
    <url>%2F2018%2F12%2F30%2FFilter%2F</url>
    <content type="text"><![CDATA[参考自https://blog.csdn.net/u013087513/article/details/56835894 1234567public interface Filter &#123; void init(FilterConfig var1) throws ServletException; void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) throws IOException, ServletException; void destroy();&#125; init(FilterConfig filterConfig) throws ServletException和我们编写的Servlet程序一样，Filter的创建与销毁由WEB服务器负责。web应用程序启动时，web服务器将创建Filter的实例对象，并调用init方法进行初始化（注意：filter对象只会创建一次，init方法也只会执行一次） 开发人员通过init方法的参数，可以获得代表当前filter配置信息的FilterConfig对象。 doFilter(ServletRequest, ServletResponse, FilterChain)每次filter进行拦截都会执行 在实际开发中方法中参数request和response通常转换为HttpServletRequest和HttpServletResponse类型进行操作。 destroy()在web容器卸载Filter对象之前被调用 FilterConfig接口用户在配置filter时，可以使用init-param标签为filter配置一些初始化参数，当web容器实例化Filter对象，调用其init方法时，会把封装了filter初始化参数的FilterConfig对象传递进来，因此开发人员在编写Filter时，通过FilterConfig对象的方法就可获得过滤器的初始化参数有关的信息以及获取ServletContext对象等信息： 123456789public interface FilterConfig &#123; String getFilterName(); ServletContext getServletContext(); String getInitParameter(String var1); Enumeration&lt;String&gt; getInitParameterNames();&#125; String getFilterName()：得到filter的名称。 String getInitParameter(String name)：返回在部署描述中指定名称的初始化参数的值。如果不存在则返回null。 Enumeration getInitParameterNames()：返回过滤器中的所有初始化参数的名字的枚举集合。 public ServletContext getServletContext()：返回Servlet上下文对象的引用。 web.xml中的filter配置123456789101112131415161718192021222324252627&lt;!-- 定义Filter --&gt;&lt;filter&gt;&lt;!-- Filter的名字 --&gt;&lt;filter-name&gt;myfilter&lt;/filter-name&gt;&lt;!-- Filter的实现类 --&gt;&lt;filter-class&gt;&lt;/filter-class&gt;&lt;!-- 下面2个init-param元素配置了参数 --&gt;&lt;init-param&gt;&lt;param-name&gt;encoding&lt;/param-name&gt;&lt;param-value&gt;utf-8&lt;/param-value&gt;&lt;/init-param&gt;&lt;init-param&gt;&lt;param-name&gt;loginPage&lt;/param-name&gt;&lt;param-value&gt;/login.jsp&lt;/param-value&gt;&lt;/init-param&gt;&lt;/filter&gt;&lt;!-- 定义Filter拦截的URL地址 --&gt;&lt;filter-mapping&gt;&lt;!-- Filter的名字 --&gt;&lt;filter-name&gt;myfilter&lt;/filter-name&gt;&lt;!-- Filter负责拦截的URL --&gt;&lt;url-pattern&gt;&lt;/url-pattern&gt;&lt;!-- 指定过滤器所拦截的Servlet名称。--&gt;&lt;servlet-name&gt;&lt;/servlet-name&gt; &lt;!-- 指定过滤器所拦截的资源被Servlet容器调用的方式，可以是REQUEST，INCLUDE，FORWARD，和ERROR之一，默认是REQUEST。用户可以设置多个--&gt;&lt;dispatcher&gt;&lt;/dispatcher&gt; &lt;/filter-mapping&gt; url-pattern有三种匹配方式： 绝对路径匹配：以/开头 不包含通配符 * 是一个绝对访问路径。例如：/demo、/index.jsp 目录匹配：以/ 开头，以 结尾。例如：/、/servlet/、/servlet/xxx/ 扩展名匹配：不能以/ 开头，也不能以结尾 只能以后缀名结尾 例如：.do、*.demo等 映射Filter的多种方式： REQUEST：当用户直接访问页面时，Web容器将会调用过滤器。如果目标资源是通过RequestDispatcher的include()或forward()方法访问时，那么该过滤器就不会被调用。 INCLUDE：如果目标资源是通过RequestDispatcher的include()方法访问时，那么该过滤器将被调用。除此之外，该过滤器不会被调用。 FORWARD：如果目标资源是通过RequestDispatcher的forward()方法访问时，那么该过滤器将被调用，除此之外，该过滤器不会被调用。 ERROR：如果目标资源是通过声明式异常处理机制调用时，那么该过滤器将被调用。除此之外，过滤器不会被调用。 实例123456789101112131415161718192021public class FirstFilter implements Filter &#123; @Override public void destroy() &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println("firstFilter...."); chain.doFilter(request, response); System.out.println("firstFilter end...."); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; &#125; 123456789101112131415161718192021public class SecondFilter implements Filter &#123; @Override public void destroy() &#123; &#125; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; System.out.println("secondFilter...."); chain.doFilter(request, response); System.out.println("secondFilter end...."); &#125; @Override public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; &#125; 创建demo.servlet 1234567891011121314public class DemoServlet extends HttpServlet &#123; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; System.out.println("demo servlet"); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125; &#125; 在web.xml中添加如下配置： 12345678910111213141516171819202122232425&lt;filter&gt; &lt;filter-name&gt;firstFilter&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.FirstFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter&gt; &lt;filter-name&gt;senondFilter&lt;/filter-name&gt; &lt;filter-class&gt;cn.itcast.web.filter.SecondFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;firstFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/demo&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;senondFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/demo&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;demoServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.DemoServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;demoServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/demo&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 控制台打印 12345firstFilter....secondFilter....demo servletsecondFilter end....firstFilter end.... 将FirstFilter的filter-mapping标签对放置在SecondFilter的映射标签对的前面 重启服务器 访问/demo 12345secondFilter....firstFilter....demo servletfirstFilter end....secondFilter end....]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shiro未完待续2]]></title>
    <url>%2F2018%2F12%2F25%2Fshiro%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD2%2F</url>
    <content type="text"><![CDATA[转自https://www.cnblogs.com/koal/p/5152671.html shiro内置filter anon org.apache.shiro.web.filter.authc.AnonymousFilter authc org.apache.shiro.web.filter.authc.FormAuthenticationFilter authcBasic org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter perms org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter port org.apache.shiro.web.filter.authz.PortFilter rest org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter roles org.apache.shiro.web.filter.authz.RolesAuthorizationFilter ssl org.apache.shiro.web.filter.authz.SslFilter user org.apache.shiro.web.filter.authc.UserFilter rest：例子/admins/user/=rest[user],根据请求的方法，相当于/admins/user/=perms[user:method] ,其中method为post，get，delete等。 port：例子/admins/user/**=port[8081],当请求的url的端口不是8081是跳转到schemal://serverName:8081?queryString,其中schmal是协议http或https等，serverName是你访问的host,8081是url配置里port的端口，queryString 是你访问的url里的？后面的参数。 perms：例子/admins/user/=perms[user:add:*],perms参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，例如/admins/user/=perms[“user:add:,user:modify:“]，当有多个参数时必须每个参数都通过才通过，想当于 isPermitedAll()方法。 roles：例子/admins/user/=roles[admin],参数可以写多个，多个时必须加上引号，并且参数之间用逗号分割，当有多个参数时，例如/admins/user/=roles[“admin,guest”],每个参数通过才算通过，相当于hasAllRoles()方法。 anon：例子/admins/**=anon 没有参数，表示可以匿名使用。 authc：例如/admins/user/**=authc表示需要认证才能使用，没有参数 authcBasic：例如/admins/user/**=authcBasic没有参数表示httpBasic认证 ssl：例子/admins/user/**=ssl没有参数，表示安全的url请求，协议为https user：例如/admins/user/**=user没有参数表示必须存在用户，当登入操作时不做检查 这些过滤器分为两组，一组是认证过滤器，一组是授权过滤器。其中anon，authcBasic，auchc，user是第一组， perms，roles，ssl，rest，port是第二组]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot项目使用mybatis-generator-maven-plugin生成代码]]></title>
    <url>%2F2018%2F12%2F25%2Fspringboot%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8mybatis-generator-maven-plugin%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[springboot项目使用mybatis-generator-maven-plugin生成代码原版想用mybatis-plus的，为什么最终选择了mybatis-generator-maven-plugin生成代码呢，因为mybatis-plus不太会分页。哈哈，言归正传。 springboot项目的mybatis-generator-maven-plugin生成代码和ssm中使用mybatis-generator-maven-plugin是一样的。 在做springboot项目时可以新建一个model专门用来生成代码，很方便。 1.新建springboot web项目步骤不在赘述。 2.引入依赖123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 3.插件这里的依赖没有版本是因为有父工程的依赖版本控制。 注意：mybatis generator 插件里面一定要有mysql依赖，反正我没有加的时候报错了。 1234567891011121314151617181920212223242526&lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;!-- mybatis generator 自动生成代码插件 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;configuration&gt; &lt;configurationFile&gt;src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt; &lt;overwrite&gt;true&lt;/overwrite&gt; &lt;verbose&gt;true&lt;/verbose&gt; &lt;/configuration&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt;&lt;/plugins&gt; 4.generatorConfig.xml具体参数根据自己需要修改 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;!-- 配置Run As Maven build : Goals 参数 : mybatis-generator:generate -Dmybatis.generator.overwrite=true --&gt;&lt;!-- 配置 tableName,使用 Run As Maven build 生成 dao model 层 --&gt;&lt;generatorConfiguration&gt; &lt;!--数据库驱动包路径 --&gt; &lt;!-- 由于在pom.xml中加入插件时已经配置数据库驱动包，所以此处不必配置了--&gt; &lt;!--&lt;classPathEntry location="D:\java\mysql-connector-java-5.1.35.jar"/&gt;--&gt; &lt;context id="DB2Tables" targetRuntime="MyBatis3"&gt; &lt;!--关闭注释 --&gt; &lt;commentGenerator&gt; &lt;property name="suppressAllComments" value="true"/&gt; &lt;/commentGenerator&gt; &lt;!--数据库连接信息 --&gt; &lt;jdbcConnection driverClass="com.mysql.jdbc.Driver" connectionURL="jdbc:mysql://127.0.0.1:3306/york_oa" userId="root" password="123"&gt; &lt;/jdbcConnection&gt; &lt;!--生成的model 包路径 --&gt; &lt;javaModelGenerator targetPackage="entity" targetProject="src/main/java/york/generator"&gt; &lt;property name="enableSubPackages" value="ture"/&gt; &lt;property name="trimStrings" value="true"/&gt; &lt;/javaModelGenerator&gt; &lt;!--生成xml mapper文件 路径 --&gt; &lt;sqlMapGenerator targetPackage="mapper" targetProject="src/main/java/york/generator"&gt; &lt;property name="enableSubPackages" value="ture"/&gt; &lt;/sqlMapGenerator&gt; &lt;!-- 生成的Dao接口 的包路径 --&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="dao" targetProject="src/main/java/york/generator"&gt; &lt;property name="enableSubPackages" value="ture"/&gt; &lt;/javaClientGenerator&gt; &lt;!--对应数据库表名，多个表，请复制指定 --&gt; &lt;table tableName="york_staff"&gt;&lt;/table&gt; &lt;!--&lt;table tableName="T_ROLE"&gt;&lt;/table&gt;--&gt; &lt;!--&lt;table tableName="T_USER_ROLE"&gt;&lt;/table&gt;--&gt; &lt;!--&lt;table tableName="T_PERMISSION"&gt;&lt;/table&gt;--&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 5.application.yml123456789101112131415161718192021222324252627282930313233343536373839# 开发环境配置server: # 服务端口 port: 9999 servlet: # 项目contextPath context-path: / tomcat: # tomcat的URI编码 uri-encoding: UTF-8 # tomcat最大线程数，默认为200 max-threads: 800 # Tomcat启动初始化的线程数，默认值25 min-spare-threads: 30spring:#引入其他model内的配置文件，注意命名方式以application-开头 datasource: url: jdbc:mysql://127.0.0.1:3306/york_oa username: root password: 123 # 使用druid数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver filters: stat maxActive: 20 initialSize: 1 maxWait: 60000 minIdle: 1 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: select 'x' testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true maxOpenPreparedStatements: 20logging: config: classpath:logback-spring.xml 至此配置完毕，运行插件就行了]]></content>
      <categories>
        <category>springboot</category>
        <category>mybatis-generator</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>mybatis-generator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot注解事务处理]]></title>
    <url>%2F2018%2F12%2F25%2Fspringboot%E6%B3%A8%E8%A7%A3%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[用的注解都是@Transactional 指示spring事务管理器回滚一个事务的推荐方法是在当前事务的上下文内抛出异常 spring事务管理器会捕捉任何未处理的异常，然后依据规则决定是否回滚抛出异常的事务 默认配置下，spring只有在抛出的异常为运行时unchecked异常时才回滚该事务，也就是抛出的异常为 RuntimeException的子类(Errors也会导致事务回滚)，而抛出checked异常则不会导致事务回滚。 用 spring 事务管理器,由spring来负责数据库的打开,提交,回滚.默认遇到运行期例外(throw new RuntimeException(“注释”);)会回滚，即遇到不受检查（unchecked）的例外时回滚；而遇到需要捕获的例外 (throw new Exception(“注释”);)不会回滚,即遇到受检查的例外（就是非运行时抛出的异常，编译器会检查到的异 常叫受检查例外或说受检查异常）时，需我们指定方式来让事务回滚要想所有异常都回滚,要加上 @Transactional( rollbackFor={Exception.class,其它异常}) .如果让unchecked异常不回滚： @Transactional(notRollbackFor=RunTimeException.class) 同样适用与springboot springboot@Transactional测试测试父类12345678@SpringBootApplication@MapperScan("springboot.demo.dao")public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; dao继承测试没有@Transactional时，虽然报错但是数据仍然插入了。 12345678910111213public class DaoExtendsTest extends DemoApplicationTests &#123; @Autowired private UserDao userDao; @Test public void daoTest()&#123; User user = new User(); user.setAge(20); user.setName("南北"); userDao.saveUser(user); int i = 1/0; System.out.println(user); &#125;&#125; 加入@Transactional注解，抛出的是unchecked异常，事务回滚，数据没有插入 12345678910111213public class DaoExtendsTest extends DemoApplicationTests &#123; @Autowired private UserDao userDao; @Test public void daoTest()&#123; User user = new User(); user.setAge(20); user.setName("南北"); userDao.saveUser(user); int i = 1/0; System.out.println(user); &#125;&#125; 当我们catch住异常时 应该是成功插入了数据但是，springboot的单元测试中@Transactional应该是默认回滚数据的 我们可以看到砸控制台打印 Rolled back transaction for test: 123456789101112131415161718public class DaoExtendsTest extends DemoApplicationTests &#123; @Autowired private UserDao userDao; @Test @Transactional public void daoTest()&#123; User user = new User(); user.setAge(20); user.setName("南北"); userDao.saveUser(user); try &#123; int i = 1/0; &#125;catch (Exception e)&#123; System.out.println("捕获异常"); &#125; System.out.println(user); &#125;&#125; 可见异常被捕捉后是不进行异常回滚的，如果想要回滚可以捕捉后在抛出Runtime Exception 1234567891011121314151617181920public class DaoExtendsTest extends DemoApplicationTests &#123; @Autowired private UserDao userDao; @Test @Transactional public void daoTest()&#123; User user = new User(); user.setAge(20); user.setName("南北"); userDao.saveUser(user); try &#123; int i = 1/0; &#125;catch (Exception e)&#123; System.out.println("捕获异常"); throw new RuntimeException(); &#125; System.out.println(user); &#125;&#125; 如果想要事务回滚所有异常或者指定异常 @Transactional( rollbackFor={Exception.class,其它异常}) 如果想要事务不会滚Runtime Exception @Transactional(notRollbackFor=RunTimeException.class) 但是想要处理异常，都要抛出，而不进行try，catch处理 即使try，catch处理也要在catch代码块中throw 异常。 springboot单元测试中@Transactional默认是回滚事务，可以配合@Rollback阻止事务回滚 但是这样配置事务在测试时就是永远不会回滚。即使抛出Runtime Exception如下 即使catch后抛出了RuntimeException，会发现数据仍然插入了。 123456789101112131415161718192021public class DaoExtendsTest extends DemoApplicationTests &#123; @Autowired private UserDao userDao; @Test @Transactional @Rollback(false) public void daoTest()&#123; User user = new User(); user.setAge(20); user.setName("南北"); userDao.saveUser(user); try &#123; &#125;catch (Exception e)&#123; System.out.println("捕获异常"); throw new RuntimeException(); &#125; System.out.println(user); &#125;&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shiro未完待续1]]></title>
    <url>%2F2018%2F12%2F25%2Fshiro%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD1%2F</url>
    <content type="text"><![CDATA[1.入门Apache Shiro 是 Java 的一个安全框架。 1) Authentication：身份认证/登录，验证用户是不是拥有相应的身份。 2) Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限。 3) Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通 JavaSE 环境的，也可以是如 Web 环境的。 4) Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储。 5) Web Support：Web支持，可以非常容易的集成到 web 环境。 6) Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率。 7) Concurrency：shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去。 8) Testing：提供测试支持。 9) Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。 10) Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。 Shiro有三个主要的概念：Subject，SecurityManager，Realms Subject：翻译为主角，当前参与应用安全部分的主角。可以是用户，可以试第三方服务，可以是cron 任务，或者任何东西。主要指一个正在与当前软件交互的东西。所有Subject都需要SecurityManager，当你与Subject进行交互，这些交互行为实际上被转换为与SecurityManager的交互 SecurityManager：安全管理员，Shiro架构的核心，它就像Shiro内部所有原件的保护伞。然而一旦配置了SecurityManager，SecurityManager就用到的比较少，开发者大部分时间都花在Subject上面。请记得，当你与Subject进行交互的时候，实际上是SecurityManager在背后帮你举起Subject来做一些安全操作。 Realms：Realms作为Shiro和你的应用的连接桥，当需要与安全数据交互的时候，像用户账户，或者访问控制，Shiro就从一个或多个Realms中查找。Shiro提供了一些可以直接使用的Realms，如果默认的Realms不能满足你的需求，你也可以定制自己的Realms 2.Shiro认证，授权1.SimpleAccountRealm引入依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 新建测试 12345678910111213141516171819202122232425262728293031323334public class AuthenticationTest &#123; //Shiro 从 Realm 获取安全数据（如用户、角色、权限） SimpleAccountRealm accountRealm = new SimpleAccountRealm(); @Before public void addUser()&#123; accountRealm.addAccount("haha","123456"); &#125; @Test public void testAuthentication()&#123; //1.构建securityManager,从accountRealm获取安全数据 DefaultSecurityManager securityManager= new DefaultSecurityManager(); securityManager.setRealm(accountRealm); //2.主体提交认证请求 SecurityUtils.setSecurityManager(securityManager); //获得主体 Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("haha","123456"); //主体登录认证 subject.login(token); //判断是否认证 boolean authenticated = subject.isAuthenticated(); System.out.println(authenticated); //true //登出 subject.logout(); System.out.println(subject.isAuthenticated()); //false &#125;&#125; 2.IniRealmIniRealm是从ini文件中读取安全数据 新建ini文件 用户为haha，密码为123456，有一个admin的角色，角色有删除权限。 1234[users]haha=123456,admin[roles]admin=user:delete 新检测试类 1234567891011121314151617181920212223242526272829public class IniRealmTest &#123; @Test public void testAuthentication()&#123; //创建iniRealm,读取user.ini。 IniRealm iniRealm = new IniRealm("classpath:user.ini"); //1.构建securityManager,从iniRealm获取安全数据 DefaultSecurityManager securityManager= new DefaultSecurityManager(); securityManager.setRealm(iniRealm); //2.主体提交认证请求 SecurityUtils.setSecurityManager(securityManager); //获得主体 Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("haha","123456"); //主体登录认证 subject.login(token); //判断是否认证 boolean authenticated = subject.isAuthenticated(); System.out.println(authenticated); //检查是否有admin角色 subject.checkRole("admin"); //检查是否有删除权限 subject.checkPermission("user:delete"); &#125;&#125; 3.JdbcRealmJdbcRealm是从数据库中查询的到安全信息。 123456789101112131415161718192021222324252627282930313233343536373839public class JdbcRealmTest &#123; @Test public void testAuthentication()&#123; DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setUrl("jdbc:mysql://localhost:3306/shiro_test"); druidDataSource.setUsername("root"); druidDataSource.setPassword("123"); druidDataSource.setDriverClassName("com.mysql.jdbc.Driver"); //创建jdbcRealm。 JdbcRealm jdbcRealm = new JdbcRealm(); //设置数据源 jdbcRealm.setDataSource(druidDataSource); //设置权限开关开启 jdbcRealm.setPermissionsLookupEnabled(true); //1.构建securityManager,从iniRealm获取安全数据 DefaultSecurityManager securityManager= new DefaultSecurityManager(); securityManager.setRealm(jdbcRealm); //2.主体提交认证请求 SecurityUtils.setSecurityManager(securityManager); //获得主体 Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("haha","123456"); //主体登录认证 subject.login(token); //判断是否认证 boolean authenticated = subject.isAuthenticated(); System.out.println(authenticated); subject.checkRole("admin"); subject.checkPermission("user:delete"); &#125;&#125; 上面的案例没有写sql语句，因为JdbcRealm默认内置了一些sql语句 我们只要在建表的时候按照默认的sql语句建的话，就可以查到数据，进行校验。 1234567//认证校验protected static final String DEFAULT_AUTHENTICATION_QUERY = "select password from users where username = ?";protected static final String DEFAULT_SALTED_AUTHENTICATION_QUERY = "select password, password_salt from users where username = ?";//校验用户下是否有对应角色protected static final String DEFAULT_USER_ROLES_QUERY = "select role_name from user_roles where username = ?";//验证角色是否有对应的权限。protected static final String DEFAULT_PERMISSIONS_QUERY = "select permission from roles_permissions where role_name = ?"; 实现过程中不太可能用默认的。JdbcRealm当然支持自己的sql语句 123456789101112131415161718192021222324252627282930313233343536373839404142434445@Testpublic void testAuthentication()&#123; DruidDataSource druidDataSource = new DruidDataSource(); druidDataSource.setUrl("jdbc:mysql://localhost:3306/shiro_test"); druidDataSource.setUsername("root"); druidDataSource.setPassword("123"); druidDataSource.setDriverClassName("com.mysql.jdbc.Driver"); //创建jdbcRealm。 JdbcRealm jdbcRealm = new JdbcRealm(); //设置数据源 jdbcRealm.setDataSource(druidDataSource); //设置权限开关开启 jdbcRealm.setPermissionsLookupEnabled(true); //-------------------------------------------------- String sql = "select user_password from test_user where user_name = ?"; jdbcRealm.setAuthenticationQuery(sql); //查询角色 //jdbcRealm.setUserRolesQuery(sql); //查询权限 //jdbcRealm.setPermissionsQuery(sql); //-------------------------------------------------- //1.构建securityManager,从iniRealm获取安全数据 DefaultSecurityManager securityManager= new DefaultSecurityManager(); securityManager.setRealm(jdbcRealm); //2.主体提交认证请求 SecurityUtils.setSecurityManager(securityManager); //获得主体 Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("hehe","123"); //主体登录认证 subject.login(token); //判断是否认证 boolean authenticated = subject.isAuthenticated(); System.out.println(authenticated); //subject.checkRole("admin"); //subject.checkPermission("user:delete");&#125; 4.自定义Realm需要继承AuthorizingRealm类实现它两个方法。 123456789101112131415161718192021222324252627282930313233343536373839public class MyRealm extends AuthorizingRealm &#123; Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;(); &#123; map.put("haha","123456"); super.setName("myRealm"); &#125; //此方法用于授权 protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; String username = (String) principalCollection.getPrimaryPrincipal(); Set&lt;String&gt; roles = getRolesByUserName(username); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); authorizationInfo.setRoles(roles); return authorizationInfo; &#125; //此方法用于认证 protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; //从主体认证信息中获取用户名 String username = (String) authenticationToken.getPrincipal(); //通过用户名从数据库获得凭证 String password = getPasswordByUserName(username); if(password==null)&#123; return null; &#125; SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(username,password,"myRealm"); return authenticationInfo; &#125; //模拟数据库查询 private String getPasswordByUserName(String username)&#123; return map.get(username); &#125; //模拟从数据库中获得数据 private Set&lt;String&gt; getRolesByUserName(String username)&#123; //这里用map模拟会更好点，用username作为key去获得set集合的value Set&lt;String&gt; roles = new HashSet&lt;String&gt;(); roles.add("admin"); return roles; &#125;&#125; 测试 123456789101112131415161718192021222324252627282930public class MyRealmTest &#123; @Test public void testAuthentication()&#123; //创建自定义Realm。 MyRealm myRealm = new MyRealm(); //1.构建securityManager,从iniRealm获取安全数据 DefaultSecurityManager securityManager= new DefaultSecurityManager(); securityManager.setRealm(myRealm); //2.主体提交认证请求 SecurityUtils.setSecurityManager(securityManager); //获得主体 Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("haha","123456"); //主体登录认证 subject.login(token); //判断是否认证 boolean authenticated = subject.isAuthenticated(); System.out.println(authenticated); subject.checkRole("admin"); //subject.checkPermission("user:delete"); &#125;&#125; 3.shiro加密12345678910111213141516171819202122232425262728293031323334353637383940public class MyRealmTest &#123; @Test public void testAuthentication()&#123; //创建自定义Realm。 MyRealm myRealm = new MyRealm(); //1.构建securityManager,从iniRealm获取安全数据 DefaultSecurityManager securityManager= new DefaultSecurityManager(); securityManager.setRealm(myRealm); //----------------------加密操作------------------------ //加密 HashedCredentialsMatcher matcher = new HashedCredentialsMatcher(); //加密算法名称 matcher.setHashAlgorithmName("md5"); //加密算法次数 matcher.setHashIterations(1); myRealm.setCredentialsMatcher(matcher); //----------------------加密操作------------------------ //2.主体提交认证请求 SecurityUtils.setSecurityManager(securityManager); //获得主体 Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken("haha","123456"); //主体登录认证 subject.login(token); //判断是否认证 boolean authenticated = subject.isAuthenticated(); System.out.println(authenticated); subject.checkRole("admin"); //subject.checkPermission("user:delete"); &#125;&#125; 修改myRealm 这里的密码用了md5,，模拟的时候先用main方法算出了加密后的密码，然后放到map中。 为了让密码更加安全使用了加盐的操作 Md5Hash md5Hash = new Md5Hash(“123456”,”haha”);123456后面的haha就是盐 使用加盐操作的话再返回authenticationInfo之前就要多一步操作了，即 1authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes("haha")); 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class MyRealm extends AuthorizingRealm &#123; Map&lt;String,String&gt; map = new HashMap&lt;String, String&gt;(); &#123; map.put("haha","8c7e1f3b1b787ec9f24fcc01e243e072"); super.setName("myRealm"); &#125; //此方法用于授权 protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; String username = (String) principalCollection.getPrimaryPrincipal(); Set&lt;String&gt; roles = getRolesByUserName(username); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); authorizationInfo.setRoles(roles); return authorizationInfo; &#125; //此方法用于认证 protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; //从主体认证信息中获取用户名 String username = (String) authenticationToken.getPrincipal(); //通过用户名从数据库获得凭证 String password = getPasswordByUserName(username); if(password==null)&#123; return null; &#125; SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(username,password,"myRealm"); authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes("haha")); return authenticationInfo; &#125; //模拟数据库查询 private String getPasswordByUserName(String username)&#123; return map.get(username); &#125; //模拟从数据库中获得数据 private Set&lt;String&gt; getRolesByUserName(String username)&#123; //这里用map模拟会更好点，用username作为key去获得set集合的value Set&lt;String&gt; roles = new HashSet&lt;String&gt;(); roles.add("admin"); return roles; &#125; public static void main(String[] args) &#123; Md5Hash md5Hash = new Md5Hash("123456","haha"); System.out.println(md5Hash.toString()); &#125;&#125;]]></content>
      <categories>
        <category>shiro</category>
      </categories>
      <tags>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot整合邮件]]></title>
    <url>%2F2018%2F12%2F22%2Fspringboot%E6%95%B4%E5%90%88%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[引入依赖12345&lt;!--mail--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt; 添加配置123456#邮件配置spring.mail.host=smtp.qq.comspring.mail.username=1377262954@qq.com#这里不是邮箱的登录密码，而是开启PO3/SMTP服务时邮箱的授权码spring.mail.password=vntbnlrepwppgchbspring.mail.default-encoding=UTF-8 测试发邮件 txt123456789101112131415161718public class MailTest extends DemoApplicationTests &#123; @Autowired private JavaMailSenderImpl mailSender; @Test public void sendTxtMail() &#123; SimpleMailMessage simpleMailMessage = new SimpleMailMessage(); // 设置收件人，寄件人 simpleMailMessage.setTo(new String[] &#123;"1377262954@qq.com"&#125;); simpleMailMessage.setFrom("1377262954@qq.com"); simpleMailMessage.setSubject("Springboot Mail 邮件测试【文本】"); simpleMailMessage.setText("这里是一段简单文本。"); // 发送邮件 mailSender.send(simpleMailMessage); System.out.println("邮件已发送"); &#125;&#125; 测试发邮件 html123456789101112131415161718192021@Testpublic void sendHtmlMail() throws Exception &#123; MimeMessage mimeMessage = mailSender.createMimeMessage(); MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage); mimeMessageHelper.setTo("1377262954@qq.com"); mimeMessageHelper.setFrom("1377262954@qq.com"); mimeMessageHelper.setSubject("Spring Boot Mail 邮件测试【HTML】"); StringBuilder sb = new StringBuilder(); sb.append("&lt;html&gt;&lt;head&gt;&lt;/head&gt;"); sb.append("&lt;body&gt;&lt;h1&gt;spring 邮件测试&lt;/h1&gt;&lt;p&gt;hello!this is spring mail test。&lt;/p&gt;&lt;/body&gt;"); sb.append("&lt;/html&gt;"); // 启用html mimeMessageHelper.setText(sb.toString(), true); // 发送邮件 mailSender.send(mimeMessage); System.out.println("邮件已发送");&#125; 测试发邮件 包含图片1234567891011121314151617181920212223242526272829303132/** * 发送包含内嵌图片的邮件 * @throws Exception */@Testpublic void sendAttachedImageMail() throws Exception &#123; MimeMessage mimeMessage = mailSender.createMimeMessage(); // multipart模式 MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true); mimeMessageHelper.setTo("1377262954@qq.com"); mimeMessageHelper.setFrom("1377262954@qq.com"); mimeMessageHelper.setSubject("Spring Boot Mail 邮件测试【图片】"); StringBuilder sb = new StringBuilder(); sb.append("&lt;html&gt;&lt;head&gt;&lt;/head&gt;"); sb.append("&lt;body&gt;&lt;h1&gt;spring 邮件测试&lt;/h1&gt;&lt;p&gt;hello!this is spring mail test。&lt;/p&gt;"); // cid为固定写法，imageId指定一个标识 sb.append("&lt;img src=\"cid:imageId\"/&gt;&lt;/body&gt;"); sb.append("&lt;/html&gt;"); // 启用html mimeMessageHelper.setText(sb.toString(), true); // 设置imageId FileSystemResource img = new FileSystemResource(new File("D:\\luffy_demo_pic10.jpg")); mimeMessageHelper.addInline("imageId", img); // 发送邮件 mailSender.send(mimeMessage); System.out.println("邮件已发送");&#125; 测试发邮件 包含附件1234567891011121314151617181920212223242526272829/** * 发送包含附件的邮件 * @throws Exception */ @Test public void sendAttendedFileMail() throws Exception &#123; MimeMessage mimeMessage = mailSender.createMimeMessage(); // multipart模式 MimeMessageHelper mimeMessageHelper = new MimeMessageHelper(mimeMessage, true, "utf-8"); mimeMessageHelper.setTo("1377262954@qq.com"); mimeMessageHelper.setFrom("1377262954@qq.com"); mimeMessageHelper.setSubject("Spring Boot Mail 邮件测试【附件】"); StringBuilder sb = new StringBuilder(); sb.append("&lt;html&gt;&lt;head&gt;&lt;/head&gt;"); sb.append("&lt;body&gt;&lt;h1&gt;spring 邮件测试&lt;/h1&gt;&lt;p&gt;hello!this is spring mail test。&lt;/p&gt;&lt;/body&gt;"); sb.append("&lt;/html&gt;"); // 启用html mimeMessageHelper.setText(sb.toString(), true); // 设置附件 FileSystemResource img = new FileSystemResource(new File("E:/1.jpg")); mimeMessageHelper.addAttachment("image.jpg", img); // 发送邮件 mailSender.send(mimeMessage); System.out.println("邮件已发送"); &#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringMVC异常统一处理的三种方式]]></title>
    <url>%2F2018%2F12%2F22%2FSpringMVC%E5%BC%82%E5%B8%B8%E7%BB%9F%E4%B8%80%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Spring 统一异常处理有 3 种方式，分别为： 使用 @ ExceptionHandler 注解 实现 HandlerExceptionResolver 接口 使用 @controlleradvice 注解 使用 @ ExceptionHandler 注解使用该注解有一个不好的地方就是：进行异常处理的方法必须与出错的方法在同一个Controller里面。使用如下： 12345678910111213141516171819@Controller public class GlobalController &#123; /** * 用于处理异常的 * @return */ @ExceptionHandler(&#123;MyException.class&#125;) public String exception(MyException e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); return "exception"; &#125; @RequestMapping("test") public void test() &#123; throw new MyException("出错了！"); &#125; &#125; 这种方式最大的缺陷就是不能全局控制异常。每个类都要写一遍。 使用 @ControllerAdvice+ @ ExceptionHandler 注解@ ExceptionHandler 需要进行异常处理的方法必须与出错的方法在同一个Controller里面。那么当代码加入了@ControllerAdvice，则不需要必须在同一个 controller 中了。也就是说，@controlleradvice + @ ExceptionHandler 也可以实现全局的异常捕捉。 请确保此WebExceptionHandle 类能被扫描到并装载进 Spring 容器中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@ControllerAdvice@ResponseBodypublic class WebExceptionHandle &#123; private static Logger logger = LoggerFactory.getLogger(WebExceptionHandle.class); /** * 400 - Bad Request */ @ResponseStatus(HttpStatus.BAD_REQUEST) @ExceptionHandler(HttpMessageNotReadableException.class) public ServiceResponse handleHttpMessageNotReadableException(HttpMessageNotReadableException e) &#123; logger.error("参数解析失败", e); return ServiceResponseHandle.failed("could_not_read_json"); &#125; /** * 405 - Method Not Allowed */ @ResponseStatus(HttpStatus.METHOD_NOT_ALLOWED) @ExceptionHandler(HttpRequestMethodNotSupportedException.class) public ServiceResponse handleHttpRequestMethodNotSupportedException(HttpRequestMethodNotSupportedException e) &#123; logger.error("不支持当前请求方法", e); return ServiceResponseHandle.failed("request_method_not_supported"); &#125; /** * 415 - Unsupported Media Type */ @ResponseStatus(HttpStatus.UNSUPPORTED_MEDIA_TYPE) @ExceptionHandler(HttpMediaTypeNotSupportedException.class) public ServiceResponse handleHttpMediaTypeNotSupportedException(Exception e) &#123; logger.error("不支持当前媒体类型", e); return ServiceResponseHandle.failed("content_type_not_supported"); &#125; /** * 500 - Internal Server Error */ @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) @ExceptionHandler(Exception.class) public ServiceResponse handleException(Exception e) &#123; if (e instanceof BusinessException)&#123; return ServiceResponseHandle.failed("BUSINESS_ERROR", e.getMessage()); &#125; logger.error("服务运行异常", e); e.printStackTrace(); return ServiceResponseHandle.failed("server_error"); &#125;&#125; 如果 @ExceptionHandler 注解中未声明要处理的异常类型，则默认为参数列表中的异常类型。所以还可以写成这样： 123456789@ControllerAdvicepublic class GlobalExceptionHandler &#123; @ExceptionHandler() @ResponseBody String handleException(Exception e)&#123; return "Exception Deal! " + e.getMessage(); &#125;&#125; 参数对象就是 Controller 层抛出的异常对象！ 继承 ResponseEntityExceptionHandler 类来实现针对 Rest 接口 的全局异常捕获，并且可以返回自定义格式： 12345678910111213141516171819202122232425262728293031323334@Slf4j@ControllerAdvicepublic class ExceptionHandlerBean extends ResponseEntityExceptionHandler &#123; /** * 数据找不到异常 * @param ex * @param request * @return * @throws IOException */ @ExceptionHandler(&#123;DataNotFoundException.class&#125;) public ResponseEntity&lt;Object&gt; handleDataNotFoundException(RuntimeException ex, WebRequest request) throws IOException &#123; return getResponseEntity(ex,request,ReturnStatusCode.DataNotFoundException); &#125; /** * 根据各种异常构建 ResponseEntity 实体. 服务于以上各种异常 * @param ex * @param request * @param specificException * @return */ private ResponseEntity&lt;Object&gt; getResponseEntity(RuntimeException ex, WebRequest request, ReturnStatusCode specificException) &#123; ReturnTemplate returnTemplate = new ReturnTemplate(); returnTemplate.setStatusCode(specificException); returnTemplate.setErrorMsg(ex.getMessage()); return handleExceptionInternal(ex, returnTemplate, new HttpHeaders(), HttpStatus.OK, request); &#125;&#125; 实现 HandlerExceptionResolver 接口这种方式可以进行全局的异常控制。例如： 12345678910111213@Component public class ExceptionTest implements HandlerExceptionResolver&#123; /** * TODO 简单描述该方法的实现功能（可选）. * @see org.springframework.web.servlet.HandlerExceptionResolver#resolveException(javax.servlet.http.HttpServletRequest, javax.servlet.http.HttpServletResponse, java.lang.Object, java.lang.Exception) */ public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; System.out.println("This is exception handler method!"); return null; &#125; &#125;]]></content>
      <categories>
        <category>异常</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Json和FastJson]]></title>
    <url>%2F2018%2F12%2F22%2FJson%E5%92%8CFastJson%2F</url>
    <content type="text"><![CDATA[Json格式JSON字符串：特殊字符可在字符前面加 \ 或使用 \u 加 4位16进制数来处理 1&#123;"name":"jobs"&#125; JSON布尔：必须小写的true和false 1&#123;"bool":true&#125; JSON空：必须小写的null 1&#123;"object":null&#125; JSON数值：不能使用8/16进制 12345&#123;"num":60&#125;&#123;"num":-60&#125;&#123;"num":6.6666&#125;&#123;"num":1e+6&#125;&lt;!-- 1乘10的6次方，e不区分大小写 --&gt;&#123;"num":1e-6&#125;&lt;!-- 1乘10的负6次方，e不区分大小写 --&gt; JSON对象 123456&#123; "starcraft": &#123; "INC": "Blizzard", "price": 60 &#125;&#125; 1&#123;"name":"胡小威" , "age":20 , "male":true&#125; 1&#123;"name":"胡小威", "age"=20, "male":true, "address":&#123;"street":"岳麓山南", "city":"长沙","country":"中国"&#125;&#125; JSON数组 1234567[&#123;"id" : 1 ,"name" : "xiaoming"&#125;,&#123;"id" : 2 , "name" : "xiaohong"&#125;] 1234567[&#123;"name":"胡小威", "age"=20, "male":true, "address":&#123;"street":"岳麓山南", "city":"长沙","country":"中国"&#125;&#125;,&#123;"name":"赵小亮", "age"=22, "male":false, "address":&#123;"street":"九州港", "city":"珠海","country":"中国"&#125;&#125;] JSON对象数组 1234567891011121314151617&#123; "array": [ &#123; "name": "jobs" &#125;, &#123; "name": "bill", "age": 60 &#125;, &#123; "product": "war3", "type": "game", "popular": true, "price": 60 &#125; ]&#125; FastJson常见方法(API)maven依赖如下： 12345&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;$&#123;fastjson&#125;&lt;/version&gt;&lt;/dependency&gt; Fastjson中的经常调用的方法: 1 public static final Object parse(String text); // 把JSON文本parse为JSONObject或者JSONArray 123456@Testpublic void fun1()&#123; String s1 = "&#123;\"name\":\"胡小威\" , \"age\":20 , \"male\":true&#125;"; Object parse = JSON.parse(s1); System.out.println(parse);&#125; 2 public static final JSONObject parseObject(String text)； // 把JSON文本parse成JSONObject 123456@Testpublic void fun2()&#123; String s1 = "&#123;\"name\":\"胡小威\" , \"age\":20 , \"male\":true&#125;"; JSONObject jsonObject = JSON.parseObject(s1); System.out.println(jsonObject);&#125; 3 public static final T parseObject(String text, Class clazz); // 把JSON文本parse为JavaBean 注意：使用单引号，使用转译+双引出现了String类型封装失败，为”null”的问题。 12345678 @Test public void fun3()&#123; String s1 = "&#123;'name':'胡小伟' , 'age':20 , 'male':true&#125;"; Person person = JSON.parseObject(s1, Person.class); System.out.println(person); &#125;&#125;//Person&#123;name='胡小伟', age=20, male=true&#125; 4 public static final JSONArray parseArray(String text); // 把JSON文本parse成JSONArray 1234567@Testpublic void fun4()&#123; String s1 = "['id',60,true]"; JSONArray objects = JSON.parseArray(s1); System.out.println(objects);&#125;//["id",60,true] 5 public static final List parseArray(String text, Class clazz); //把JSON文本parse成JavaBean集合 1234567@Testpublic void fun5()&#123; String s1 = "[&#123;'name':'胡小伟','age':20 ,'male':true&#125;,&#123;'name':'东西','age':10 ,'male':false&#125;]"; List&lt;Person&gt; people = JSON.parseArray(s1, Person.class); System.out.println(people);&#125;//[Person&#123;name='胡小伟', age=20, male=true&#125;, Person&#123;name='东西', age=10, male=false&#125;] 6 public static final String toJSONString(Object object); // 将JavaBean序列化为JSON文本 12345678910@Testpublic void fun6()&#123; Person person = new Person(); person.setAge(25); person.setName("南北"); person.setMale(true); String s = JSON.toJSONString(person); System.out.println(s);&#125;//&#123;"age":25,"male":true,"name":"南北"&#125; 7 public static final String toJSONString(Object object, boolean prettyFormat); // 将JavaBean序列化为带格式的JSON文本 8 public static final Object toJSON(Object javaObject); 将JavaBean转换为JSONObject或者JSONArray。 1234567891011121314151617@Testpublic void fun7()&#123; ArrayList&lt;Person&gt; arrayList = new ArrayList&lt;Person&gt;(); Person person1 = new Person(); person1.setAge(25); person1.setName("南北"); person1.setMale(true); Person person2 = new Person(); person2.setAge(15); person2.setName("东西"); person2.setMale(false); arrayList.add(person1); arrayList.add(person2); Object o = JSON.toJSON(arrayList); System.out.println(o);&#125;//[&#123;"name":"南北","age":25,"male":true&#125;,&#123;"name":"东西","age":15,"male":false&#125;] 9 JSON Map String 转 Map 123456789101112@Testpublic void test()&#123; String str = "&#123;\"age\":\"24\",\"name\":\"cool\"&#125;"; JSONObject jsonObject = JSONObject.parseObject(str); //json对象转Map Map&lt;String,Object&gt; map = (Map&lt;String,Object&gt;)jsonObject; System.out.println("map对象是：" + map); Object object = map.get("age"); System.out.println("age的值是"+object);&#125;//map对象是：&#123;"name":"cool","age":"24"&#125;//age的值是24 Map 转 String 12345678@Testpublic void test()&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("age", 24); map.put("name", "cool"); String jsonString = JSON.toJSONString(map); System.out.println("json字符串是："+jsonString);&#125; Map 转 Json 12345678@Testpublic void test()&#123; Map&lt;String,Object&gt; map = new HashMap&lt;&gt;(); map.put("age", 24); map.put("name", "cool"); JSONObject json = new JSONObject(map); System.out.println("Json对象是：" + json);&#125; ​]]></content>
      <categories>
        <category>FastJson</category>
      </categories>
      <tags>
        <tag>FastJson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[异常处理思路]]></title>
    <url>%2F2018%2F12%2F22%2F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[异常处理思路分为3个层次 使用try catch处理异常，对controller中一个方法的处理 使用@ ExceptionHandler 注解,对整个个controller处理 使用@ControllerAdvice+@ ExceptionHandler全局处理，即所有的controller 1.使用try catch处理处理后，方法以外的方法会走@ ExceptionHandler局部处理 2.@ ExceptionHandler局部处理12345678910111213141516171819@Controller public class GlobalController &#123; /** * 用于处理异常的 * @return */ @ExceptionHandler(&#123;MyException.class&#125;) public String exception(MyException e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); return "exception"; &#125; @RequestMapping("test") public void test() &#123; throw new MyException("出错了！"); &#125; &#125; 处理try catch以外的异常，其他controller的错误，会走全局异常处理。 3.全局异常处理例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@RestControllerAdvicepublic class DefaultExceptionHandler&#123; private static final Logger log = LoggerFactory.getLogger(DefaultExceptionHandler.class); /** * 权限校验失败 */ @ExceptionHandler(AuthorizationException.class) public AjaxResult handleAuthorizationException(AuthorizationException e) &#123; log.error(e.getMessage(), e); return AjaxResult.error(PermissionUtils.getMsg(e.getMessage())); &#125; /** * 请求方式不支持 */ @ExceptionHandler(&#123; HttpRequestMethodNotSupportedException.class &#125;) public AjaxResult handleException(HttpRequestMethodNotSupportedException e) &#123; log.error(e.getMessage(), e); return AjaxResult.error(&quot;不支持&apos; &quot; + e.getMethod() + &quot;&apos;请求&quot;); &#125; /** * 拦截未知的运行时异常 */ @ExceptionHandler(RuntimeException.class) public AjaxResult notFount(RuntimeException e) &#123; log.error(&quot;运行时异常:&quot;, e); return AjaxResult.error(&quot;运行时异常:&quot; + e.getMessage()); &#125; /** * 系统异常 */ @ExceptionHandler(Exception.class) public AjaxResult handleException(Exception e) &#123; log.error(e.getMessage(), e); return AjaxResult.error(&quot;服务器错误，请联系管理员&quot;); &#125; /** * 演示模式异常 */ @ExceptionHandler(DemoModeException.class) public AjaxResult demoModeException(DemoModeException e) &#123; return AjaxResult.error(&quot;演示模式，不允许操作&quot;); &#125;&#125; 处理在try catch 和局部异常处理之后还没有被处理的异常。]]></content>
      <categories>
        <category>异常</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式ID生成Twitter的snowflake算法]]></title>
    <url>%2F2018%2F12%2F22%2F%E5%88%86%E5%B8%83%E5%BC%8FID%E7%94%9F%E6%88%90Twitter%E7%9A%84snowflake%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169/** * &lt;p&gt;名称：IdWorker.java&lt;/p&gt; * &lt;p&gt;描述：分布式自增长ID&lt;/p&gt; * &lt;pre&gt; * Twitter的 Snowflake JAVA实现方案 * &lt;/pre&gt; * 核心代码为其IdWorker这个类实现，其原理结构如下，我分别用一个0表示一位，用—分割开部分的作用： * 1||0---0000000000 0000000000 0000000000 0000000000 0 --- 00000 ---00000 ---000000000000 * 在上面的字符串中，第一位为未使用（实际上也可作为long的符号位），接下来的41位为毫秒级时间， * 然后5位datacenter标识位，5位机器ID（并不算标识符，实际是为线程标识）， * 然后12位该毫秒内的当前毫秒内的计数，加起来刚好64位，为一个Long型。 * 这样的好处是，整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分）， * 并且效率较高，经测试，snowflake每秒能够产生26万ID左右，完全满足需要。 * &lt;p&gt; * 64位ID (42(毫秒)+5(机器ID)+5(业务编码)+12(重复累加)) * * @author Polim */public class IdWorker &#123; // 时间起始标记点，作为基准，一般取系统的最近时间（一旦确定不能变动） private final static long twepoch = 1288834974657L; // 机器标识位数 private final static long workerIdBits = 5L; // 数据中心标识位数 private final static long datacenterIdBits = 5L; // 机器ID最大值 private final static long maxWorkerId = -1L ^ (-1L &lt;&lt; workerIdBits); // 数据中心ID最大值 private final static long maxDatacenterId = -1L ^ (-1L &lt;&lt; datacenterIdBits); // 毫秒内自增位 private final static long sequenceBits = 12L; // 机器ID偏左移12位 private final static long workerIdShift = sequenceBits; // 数据中心ID左移17位 private final static long datacenterIdShift = sequenceBits + workerIdBits; // 时间毫秒左移22位 private final static long timestampLeftShift = sequenceBits + workerIdBits + datacenterIdBits; private final static long sequenceMask = -1L ^ (-1L &lt;&lt; sequenceBits); /* 上次生产id时间戳 */ private static long lastTimestamp = -1L; // 0，并发控制 private long sequence = 0L; private final long workerId; // 数据标识id部分 private final long datacenterId; public IdWorker()&#123; this.datacenterId = getDatacenterId(maxDatacenterId); this.workerId = getMaxWorkerId(datacenterId, maxWorkerId); &#125; /** * @param workerId * 工作机器ID * @param datacenterId * 序列号 */ public IdWorker(long workerId, long datacenterId) &#123; if (workerId &gt; maxWorkerId || workerId &lt; 0) &#123; throw new IllegalArgumentException(String.format("worker Id can't be greater than %d or less than 0", maxWorkerId)); &#125; if (datacenterId &gt; maxDatacenterId || datacenterId &lt; 0) &#123; throw new IllegalArgumentException(String.format("datacenter Id can't be greater than %d or less than 0", maxDatacenterId)); &#125; this.workerId = workerId; this.datacenterId = datacenterId; &#125; /** * 获取下一个ID * * @return */ public synchronized long nextId() &#123; long timestamp = timeGen(); if (timestamp &lt; lastTimestamp) &#123; throw new RuntimeException(String.format("Clock moved backwards. Refusing to generate id for %d milliseconds", lastTimestamp - timestamp)); &#125; if (lastTimestamp == timestamp) &#123; // 当前毫秒内，则+1 sequence = (sequence + 1) &amp; sequenceMask; if (sequence == 0) &#123; // 当前毫秒内计数满了，则等待下一秒 timestamp = tilNextMillis(lastTimestamp); &#125; &#125; else &#123; sequence = 0L; &#125; lastTimestamp = timestamp; // ID偏移组合生成最终的ID，并返回ID long nextId = ((timestamp - twepoch) &lt;&lt; timestampLeftShift) | (datacenterId &lt;&lt; datacenterIdShift) | (workerId &lt;&lt; workerIdShift) | sequence; return nextId; &#125; private long tilNextMillis(final long lastTimestamp) &#123; long timestamp = this.timeGen(); while (timestamp &lt;= lastTimestamp) &#123; timestamp = this.timeGen(); &#125; return timestamp; &#125; private long timeGen() &#123; return System.currentTimeMillis(); &#125; /** * &lt;p&gt; * 获取 maxWorkerId * &lt;/p&gt; */ protected static long getMaxWorkerId(long datacenterId, long maxWorkerId) &#123; StringBuffer mpid = new StringBuffer(); mpid.append(datacenterId); String name = ManagementFactory.getRuntimeMXBean().getName(); if (!name.isEmpty()) &#123; /* * GET jvmPid */ mpid.append(name.split("@")[0]); &#125; /* * MAC + PID 的 hashcode 获取16个低位 */ return (mpid.toString().hashCode() &amp; 0xffff) % (maxWorkerId + 1); &#125; /** * &lt;p&gt; * 数据标识id部分 * &lt;/p&gt; */ protected static long getDatacenterId(long maxDatacenterId) &#123; long id = 0L; try &#123; InetAddress ip = InetAddress.getLocalHost(); NetworkInterface network = NetworkInterface.getByInetAddress(ip); if (network == null) &#123; id = 1L; &#125; else &#123; byte[] mac = network.getHardwareAddress(); id = ((0x000000FF &amp; (long) mac[mac.length - 1]) | (0x0000FF00 &amp; (((long) mac[mac.length - 2]) &lt;&lt; 8))) &gt;&gt; 6; id = id % (maxDatacenterId + 1); &#125; &#125; catch (Exception e) &#123; System.out.println(" getDatacenterId: " + e.getMessage()); &#125; return id; &#125; public static void main(String[] args) &#123; IdWorker idWorker=new IdWorker(0,0); for(int i=0;i&lt;100;i++)&#123; long nextId = idWorker.nextId(); System.out.println(nextId); &#125; &#125;&#125;]]></content>
      <categories>
        <category>snowflake</category>
      </categories>
      <tags>
        <tag>snowflake</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli]]></title>
    <url>%2F2018%2F11%2F22%2Fvue-cli%2F</url>
    <content type="text"><![CDATA[转自https://blog.csdn.net/wulala_hei/article/details/80488674 vue.js有著名的全家桶系列，包含了vue-router，vuex， vue-resource，再加上构建工具vue-cli，就是一个完整的vue项目的核心构成。 vue-cli这个构建工具大大降低了webpack的使用难度，支持热更新，有webpack-dev-server的支持，相当于启动了一个请求服务器，给你搭建了一个测试环境，只关注开发就OK。 1.安装vue-cli① 使用npm（需要安装node环境）全局安装webpack，打开命令行工具输入：npm install webpack -g或者（npm install -g webpack），安装完成之后输入 webpack -v，如果出现相应的版本号，则说明安装成功。 注意：webpack 4.X 开始，需要安装 webpack-cli 依赖 ,所以使用这条命令 npm install webpack webpack-cli -g ② 全局安装vue-cli，在cmd中输入命令: npm install --global vue-cli 安装完成之后输入 vue -V（注意这里是大写的“V”）如果出现相应的版本号，则说明安装成功。 2.用vue-cli来构建项目① 我首先在D盘新建一个文件夹（dxl_vue）作为项目存放地，然后使用命令行cd进入到项目目录输入： vue init webpack baoge baoge是自定义的项目名称，命令执行之后，会在当前目录生成一个以该名称命名的项目文件夹。 输入命令后，会跳出几个选项让你回答： Project name (baoge)： —–项目名称，直接回车，按照括号中默认名字（注意这里的名字不能有大写字母，如果有会报错Sorry, name can no longer contain capital letters），阮一峰老师博客为什么文件名要小写 ，可以参考一下。 Project description (A Vue.js project)： —-项目描述，也可直接点击回车，使用默认名字 Author ()： —-作者，输入你的大名接下来会让用户选择： Runtime + Compiler: recommended for most users 运行加编译，既然已经说了推荐，就选它了Runtime-only: about 6KB lighter min+gzip, but templates (or any Vue-specificHTML) are ONLY allowed in .vue files - render functions are required elsewhere 仅运行时，已经有推荐了就选择第一个了 Install vue-router? (Y/n) 是否安装vue-router，这是官方的路由，大多数情况下都使用，这里就输入“y”后回车即可。 Use ESLint to lint your code? (Y/n) 是否使用ESLint管理代码，ESLint是个代码风格管理工具，是用来统一代码风格的，一般项目中都会使用。接下来也是选择题Pick an ESLint preset (Use arrow keys) 选择一个ESLint预设，编写vue项目时的代码风格，直接y回车 Setup unit tests with Karma + Mocha? (Y/n) 是否安装单元测试，我选择安装y回车 Setup e2e tests with Nightwatch(Y/n)? 是否安装e2e测试 ，我选择安装y回车 回答完毕后上图就开始构建项目了。 ② 配置完成后，可以看到目录下多出了一个项目文件夹baoge，然后cd进入这个文件夹： 安装依赖： npm install ( 如果安装速度太慢。可以安装淘宝镜像，打开命令行工具，输入： npm install -g cnpm --registry=https://registry.npm.taobao.org 然后使用cnpm来安装 ) npm install ：安装所有的模块，如果是安装具体的哪个个模块，在install 后面输入模块的名字即可。而只输入install就会按照项目的根目录下的package.json文件中依赖的模块安装（这个文件里面是不允许有任何注释的），每个使用npm管理的项目都有这个文件，是npm操作的入口文件。因为是初始项目，还没有任何模块，所以我用npm install 安装所有的模块。安装完成后，目录中会多出来一个node_modules文件夹，这里放的就是所有依赖的模块。 然后现在，baoge文件夹里的目录是这样的： 解释下每个文件夹代表的意思(仔细看一下这张图）： 3.启动项目npm run dev 如果浏览器打开之后，没有加载出页面，有可能是本地的 8080 端口被占用，需要修改一下配置文件 config里的index.js 还有，如果本地调试项目时，建议将build 里的assetsPublicPath的路径前缀修改为 ‘ ./ ‘（开始是 ‘ / ‘），因为打包之后，外部引入 js 和 css 文件时，如果路径以 ‘ / ‘ 开头，在本地是无法找到对应文件的（服务器上没问题）。所以如果需要在本地打开打包后的文件，就得修改文件路径。我的端口没有被占用，直接成功（服务启动成功后浏览器会默认打开一个“欢迎页面”）： 4.vue-cli的webpack配置分析从package.json可以看到开发和生产环境的入口。 可以看到dev中的设置，build/webpack.dev.conf.js，该文件是开发环境中webpack的配置入口。 在webpack.dev.conf.js中出现webpack.base.conf.js，这个文件是开发环境和生产环境，甚至测试环境，这些环境的公共webpack配置。可以说，这个文件相当重要。 还有config/index.js 、build/utils.js 、build/build.js等,具体请看这篇介绍：https://segmentfault.com/a/1190000008644830 5.打包上线注意，自己的项目文件都需要放到 src 文件夹下。在项目开发完成之后，可以输入 npm run build 来进行打包工作。 npm run build 打包完成后，会生成 dist 文件夹，如果已经修改了文件路径，可以直接打开本地文件查看。项目上线时，只需要将 dist 文件夹放到服务器就行了。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-cli和webpack配置分析]]></title>
    <url>%2F2018%2F11%2F22%2Fvue-cli%E5%92%8Cwebpack%E9%85%8D%E7%BD%AE%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[转自https://segmentfault.com/a/1190000008644830 入口从package.json可以看到开发和生产环境的入口。 1234"scripts": &#123; "dev": "node build/dev-server.js", "build": "node build/build.js" &#125; 开发环境最新的vue里dev-server.js被替换成了webpack-dev-conf.js！！！开发环境的入口文件是 build/dev-server.js dev-server.js该文件中，使用express作为后端框架，结合一些关于webpack的中间件，搭建了一个开发环境。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105// 配置文件var config = require('../config')// 如果 Node 的环境无法判断当前是 dev / product 环境// 使用 config.dev.env.NODE_ENV 作为当前的环境if (!process.env.NODE_ENV) &#123; process.env.NODE_ENV = JSON.parse(config.dev.env.NODE_ENV)&#125;// 可以强制打开浏览器并跳转到指定 url 的插件// https://github.com/sindresorhus/opnvar opn = require('opn')// node自带的文件路径工具var path = require('path')// express框架var express = require('express')var webpack = require('webpack')// 测试环境，使用的配置与生产环境的配置一样// 非测试环境，即为开发环境，因为此文件只有测试环境和开发环境使用var proxyMiddleware = require('http-proxy-middleware')var webpackConfig = process.env.NODE_ENV === 'testing'// 生产环境配置文件 ? require('./webpack.prod.conf') // 开发环境配置文件 : require('./webpack.dev.conf')// 端口号为命令行输入的PORT参数或者配置文件中的默认值var port = process.env.PORT || config.dev.port// 配置文件中 是否自动打开浏览器var autoOpenBrowser = !!config.dev.autoOpenBrowser// 配置文件中 http代理配置// https://github.com/chimurai/http-proxy-middlewarevar proxyTable = config.dev.proxyTable// 启动 express 服务var app = express()// 启动 webpack 编译var compiler = webpack(webpackConfig)// 可以将编译后的文件暂存到内存中的插件// https://github.com/webpack/webpack-dev-middlewarevar devMiddleware = require('webpack-dev-middleware')(compiler, &#123; // 公共路径，与webpack的publicPath一样 publicPath: webpackConfig.output.publicPath, // 不打印 quiet: true&#125;)// Hot-reload 热重载插件// https://github.com/glenjamin/webpack-hot-middlewarevar hotMiddleware = require('webpack-hot-middleware')(compiler, &#123; log: () =&gt; &#123;&#125;&#125;)// 当tml-webpack-plugin template更改之后，强制刷新浏览器compiler.plugin('compilation', function (compilation) &#123; compilation.plugin('html-webpack-plugin-after-emit', function (data, cb) &#123; hotMiddleware.publish(&#123; action: 'reload' &#125;) cb() &#125;)&#125;)// 将 proxyTable 中的请求配置挂在到启动的 express 服务上Object.keys(proxyTable).forEach(function (context) &#123; var options = proxyTable[context] // 如果options的数据类型为string，则表示只设置了url， // 所以需要将url设置为对象中的 target的值 if (typeof options === 'string') &#123; options = &#123; target: options &#125; &#125; app.use(proxyMiddleware(options.filter || context, options))&#125;)// 使用 connect-history-api-fallback 匹配资源// 如果不匹配就可以重定向到指定地址// https://github.com/bripkens/connect-history-api-fallbackapp.use(require('connect-history-api-fallback')())// 将暂存到内存中的 webpack 编译后的文件挂在到 express 服务上app.use(devMiddleware)// 将 Hot-reload 挂在到 express 服务上app.use(hotMiddleware)// 拼接 static 文件夹的静态资源路径var staticPath = path.posix.join(config.dev.assetsPublicPath, config.dev.assetsSubDirectory)// 静态文件服务app.use(staticPath, express.static('./static'))var uri = 'http://localhost:' + port// 编译成功后打印网址信息devMiddleware.waitUntilValid(function () &#123; console.log('&gt; Listening at ' + uri + '\n')&#125;)module.exports = app.listen(port, function (err) &#123; if (err) &#123; console.log(err) return &#125; // 如果配置了自动打开浏览器，且不是测试环境，则自动打开浏览器并跳到我们的开发地址 if (autoOpenBrowser &amp;&amp; process.env.NODE_ENV !== 'testing') &#123; opn(uri) &#125;&#125;) webpack.dev.conf.jsdev-server.js中使用了webpack.dev.conf.js文件，该文件是开发环境中webpack的配置入口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 工具函数集合var utils = require('./utils')var webpack = require('webpack') // 配置文件var config = require('../config') // webpack 配置合并插件var merge = require('webpack-merge') // webpac基本配置var baseWebpackConfig = require('./webpack.base.conf') // 自动生成 html 并且注入到 .html 文件中的插件 // https://github.com/ampedandwired/html-webpack-pluginvar HtmlWebpackPlugin = require('html-webpack-plugin') // webpack错误信息提示插件 // https://github.com/geowarin/friendly-errors-webpack-pluginvar FriendlyErrorsPlugin = require('friendly-errors-webpack-plugin')// 将 Hol-reload 热重载的客户端代码添加到 webpack.base.conf 的 对应 entry 中，一起打包Object.keys(baseWebpackConfig.entry).forEach(function(name) &#123; baseWebpackConfig.entry[name] = ['./build/dev-client'].concat(baseWebpackConfig.entry[name])&#125;)module.exports = merge(baseWebpackConfig, &#123; module: &#123; // styleLoaders rules: utils.styleLoaders(&#123; sourceMap: config.dev.cssSourceMap &#125;) &#125;, // 最新的配置为 cheap-module-eval-source-map，虽然 cheap-module-eval-source-map更快，但它的定位不准确 // 所以，换成 eval-source-map devtool: '#eval-source-map', plugins: [ // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串 // 此处，插入适当的环境 // https://webpack.js.org/plugins/define-plugin/ new webpack.DefinePlugin(&#123; 'process.env': config.dev.env &#125;), // HotModule 插件在页面进行变更的时候只会重绘对应的页面模块，不会重绘整个 html 文件 // https://github.com/glenjamin/webpack-hot-middleware#installation--usage new webpack.HotModuleReplacementPlugin(), new webpack.NoEmitOnErrorsPlugin(), // 将 index.html 作为入口，注入 html 代码后生成 index.html文件 // https://github.com/ampedandwired/html-webpack-plugin new HtmlWebpackPlugin(&#123; filename: 'index.html', template: 'index.html', inject: true &#125;), // webpack错误信息提示插件 new FriendlyErrorsPlugin() ]&#125;) webpack.base.conf.js在webpack.dev.conf.js中出现webpack.base.conf.js，这个文件是开发环境和生产环境，甚至测试环境，这些环境的公共webpack配置。可以说，这个文件相当重要。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091// node自带的文件路径工具var path = require('path')// 工具函数集合var utils = require('./utils') // 配置文件var config = require('../config') // 工具函数集合var vueLoaderConfig = require('./vue-loader.conf')/** * 获得绝对路径 * @method resolve * @param &#123;String&#125; dir 相对于本文件的路径 * @return &#123;String&#125; 绝对路径 */function resolve(dir) &#123; return path.join(__dirname, '..', dir)&#125;module.exports = &#123; entry: &#123; app: './src/main.js' &#125;, output: &#123; // 编译输出的静态资源根路径 path: config.build.assetsRoot, // 编译输出的文件名 filename: '[name].js', // 正式发布环境下编译输出的上线路径的根路径 publicPath: process.env.NODE_ENV === 'production' ? config.build.assetsPublicPath : config.dev.assetsPublicPath &#125;, resolve: &#123; // 自动补全的扩展名 extensions: ['.js', '.vue', '.json'], // 路径别名 alias: &#123; // 例如 import Vue from 'vue'，会自动到 'vue/dist/vue.common.js'中寻找 'vue$': 'vue/dist/vue.esm.js', '@': resolve('src'), &#125; &#125;, module: &#123; rules: [&#123; // 审查 js 和 vue 文件 // https://github.com/MoOx/eslint-loader test: /\.(js|vue)$/, loader: 'eslint-loader', // 表示预先处理 enforce: "pre", include: [resolve('src'), resolve('test')], options: &#123; formatter: require('eslint-friendly-formatter') &#125; &#125;, &#123; // 处理 vue文件 // https://github.com/vuejs/vue-loader test: /\.vue$/, loader: 'vue-loader', options: vueLoaderConfig &#125;, &#123; // 编译 js // https://github.com/babel/babel-loader test: /\.js$/, loader: 'babel-loader', include: [resolve('src'), resolve('test')] &#125;, &#123; // 处理图片文件 // https://github.com/webpack-contrib/url-loader test: /\.(png|jpe?g|gif|svg)(\?.*)?$/, loader: 'url-loader', query: &#123; limit: 10000, name: utils.assetsPath('img/[name].[hash:7].[ext]') &#125; &#125;, &#123; // 处理字体文件 test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/, loader: 'url-loader', query: &#123; limit: 10000, name: utils.assetsPath('fonts/[name].[hash:7].[ext]') &#125; &#125; ] &#125;&#125; config/index.js该文件在很多文件中都用到，是主要的配置文件，包含静态文件的路径、是否开启sourceMap等。其中，分为两个部分dev（开发环境的配置）和build（生产环境的配置）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 详情见文档：https://vuejs-templates.github.io/webpack/env.htmlvar path = require('path')module.exports = &#123; // production 生产环境 build: &#123; // 构建环境 env: require('./prod.env'), // 构建输出的index.html文件 index: path.resolve(__dirname, '../dist/index.html'), // 构建输出的静态资源路径 assetsRoot: path.resolve(__dirname, '../dist'), // 构建输出的二级目录 assetsSubDirectory: 'static', // 构建发布的根目录，可配置为资源服务器域名或 CDN 域名 assetsPublicPath: '/', // 是否开启 cssSourceMap productionSourceMap: true, // Gzip off by default as many popular static hosts such as // Surge or Netlify already gzip all static assets for you. // Before setting to `true`, make sure to: // npm install --save-dev compression-webpack-plugin // 默认关闭 gzip，因为很多流行的静态资源主机，例如 Surge、Netlify，已经为所有静态资源开启gzip productionGzip: false, // 需要使用 gzip 压缩的文件扩展名 productionGzipExtensions: ['js', 'css'], // Run the build command with an extra argument to // View the bundle analyzer report after build finishes: // `npm run build --report` // Set to `true` or `false` to always turn it on or off // 运行“build”命令行时，加上一个参数，可以在构建完成后参看包分析报告 // true为开启，false为关闭 bundleAnalyzerReport: process.env.npm_config_report &#125;, // dev 开发环境 dev: &#123; // 构建环境 env: require('./dev.env'), // 端口号 port: 3333, // 是否自动打开浏览器 autoOpenBrowser: true, assetsSubDirectory: 'static', // 编译发布的根目录，可配置为资源服务器域名或 CDN 域名 assetsPublicPath: '/', // proxyTable 代理的接口（可跨域） // 使用方法：https://vuejs-templates.github.io/webpack/proxy.html proxyTable: &#123;&#125;, // CSS Sourcemaps off by default because relative paths are "buggy" // with this option, according to the CSS-Loader README // (https://github.com/webpack/css-loader#sourcemaps) // In our experience, they generally work as expected, // just be aware of this issue when enabling this option. // 默认情况下，关闭 CSS Sourcemaps，因为使用相对路径会报错。 // CSS-Loader README：https://github.com/webpack/css-loader#sourcemaps cssSourceMap: false &#125;&#125; utils.jsutils.js也是一个被使用频率的文件，这个文件包含了三个工具函数： 生成静态资源的路径 生成 ExtractTextPlugin对象或loader字符串 生成 style-loader的配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112// node自带的文件路径工具var path = require('path')// 配置文件var config = require('../config')// 提取css的插件// https://github.com/webpack-contrib/extract-text-webpack-pluginvar ExtractTextPlugin = require('extract-text-webpack-plugin')/** * 生成静态资源的路径 * @method assertsPath * @param &#123;String&#125; _path 相对于静态资源文件夹的文件路径 * @return &#123;String&#125; 静态资源完整路径 */exports.assetsPath = function (_path) &#123; var assetsSubDirectory = process.env.NODE_ENV === 'production' ? config.build.assetsSubDirectory : config.dev.assetsSubDirectory // path.posix.join与path.join一样，不过总是以 posix 兼容的方式交互 return path.posix.join(assetsSubDirectory, _path)&#125;/** * 生成处理css的loaders配置 * @method cssLoaders * @param &#123;Object&#125; options 生成配置 * option = &#123; * // 是否开启 sourceMap * sourceMap: true, * // 是否提取css * extract: true * &#125; * @return &#123;Object&#125; 处理css的loaders配置对象 */exports.cssLoaders = function (options) &#123; options = options || &#123;&#125; var cssLoader = &#123; loader: 'css-loader', options: &#123; minimize: process.env.NODE_ENV === 'production', sourceMap: options.sourceMap &#125; &#125; /** * 生成 ExtractTextPlugin对象或loader字符串 * @method generateLoaders * @param &#123;Array&#125; loaders loader名称数组 * @return &#123;String|Object&#125; ExtractTextPlugin对象或loader字符串 */ function generateLoaders (loader, loaderOptions) &#123; var loaders = [cssLoader] if (loader) &#123; loaders.push(&#123; // 例如，sass?indentedSyntax // 在?号前加上“-loader” loader: loader + '-loader', options: Object.assign(&#123;&#125;, loaderOptions, &#123; sourceMap: options.sourceMap &#125;) &#125;) &#125; // extract为true时，提取css // 生产环境中，默认为true if (options.extract) &#123; return ExtractTextPlugin.extract(&#123; use: loaders, fallback: 'vue-style-loader' &#125;) &#125; else &#123; return ['vue-style-loader'].concat(loaders) &#125; &#125; // http://vuejs.github.io/vue-loader/en/configurations/extract-css.html return &#123; css: generateLoaders(), postcss: generateLoaders(), less: generateLoaders('less'), sass: generateLoaders('sass', &#123; indentedSyntax: true &#125;), scss: generateLoaders('sass'), stylus: generateLoaders('stylus'), styl: generateLoaders('stylus') &#125;&#125;/** * 生成 style-loader的配置 * style-loader文档：https://github.com/webpack/style-loader * @method styleLoaders * @param &#123;Object&#125; options 生成配置 * option = &#123; * // 是否开启 sourceMap * sourceMap: true, * // 是否提取css * extract: true * &#125; * @return &#123;Array&#125; style-loader的配置 */exports.styleLoaders = function (options) &#123; var output = [] var loaders = exports.cssLoaders(options) for (var extension in loaders) &#123; var loader = loaders[extension] output.push(&#123; test: new RegExp('\\.' + extension + '$'), use: loader &#125;) &#125; return output&#125; 生产环境开发环境的入口文件是build/build.js build.js该文件，为构建打包文件，会将源码进行构建（编译、压缩等）后打包。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 设置当前环境为生产环境process.env.NODE_ENV = 'production'// loading 插件// https://github.com/sindresorhus/oravar ora = require('ora')// 可以在 node 中执行`rm -rf`的工具// https://github.com/isaacs/rimrafvar rm = require('rimraf')// node自带的文件路径工具var path = require('path')// 在终端输出带颜色的文字// https://github.com/chalk/chalkvar chalk = require('chalk')var webpack = require('webpack')// 配置文件var config = require('../config')var webpackConfig = require('./webpack.prod.conf')// 在终端显示loading效果，并输出提示var spinner = ora('building for production...')spinner.start()// 删除这个文件夹 （递归删除）rm(path.join(config.build.assetsRoot, config.build.assetsSubDirectory), err =&gt; &#123; if (err) throw err // 构建 webpack(webpackConfig, function (err, stats) &#123; // 构建成功 // 停止 loading动画 spinner.stop() if (err) throw err process.stdout.write(stats.toString(&#123; colors: true, modules: false, children: false, chunks: false, chunkModules: false &#125;) + '\n\n') // 打印提示 console.log(chalk.cyan(' Build complete.\n')) console.log(chalk.yellow( ' Tip: built files are meant to be served over an HTTP server.\n' + ' Opening index.html over file:// won\'t work.\n' )) &#125;)&#125;) webpack.prod.conf该文件，为生产环境中webpack的配置入口。同时，它也依赖于前面提到的webpack.base.conf.js、utils.js和config/index.js。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152// node自带的文件路径工具var path = require('path')// 工具函数集合var utils = require('./utils')var webpack = require('webpack')// 配置文件var config = require('../config')// webpack 配置合并插件var merge = require('webpack-merge')// webpack 基本配置var baseWebpackConfig = require('./webpack.base.conf')// webpack 复制文件和文件夹的插件// https://github.com/kevlened/copy-webpack-pluginvar CopyWebpackPlugin = require('copy-webpack-plugin')// 自动生成 html 并且注入到 .html 文件中的插件// https://github.com/ampedandwired/html-webpack-pluginvar HtmlWebpackPlugin = require('html-webpack-plugin')// 提取css的插件// https://github.com/webpack-contrib/extract-text-webpack-pluginvar ExtractTextPlugin = require('extract-text-webpack-plugin')// webpack 优化压缩和优化 css 的插件// https://github.com/NMFR/optimize-css-assets-webpack-pluginvar OptimizeCSSPlugin = require('optimize-css-assets-webpack-plugin')// 如果当前环境为测试环境，则使用测试环境// 否则，使用生产环境var env = process.env.NODE_ENV === 'testing' ? require('../config/test.env') : config.build.envvar webpackConfig = merge(baseWebpackConfig, &#123; module: &#123; // styleLoaders rules: utils.styleLoaders(&#123; sourceMap: config.build.productionSourceMap, extract: true &#125;) &#125;, // 是否开启 sourceMap devtool: config.build.productionSourceMap ? '#source-map' : false, output: &#123; // 编译输出的静态资源根路径 path: config.build.assetsRoot, // 编译输出的文件名 filename: utils.assetsPath('js/[name].[chunkhash].js'), // 没有指定输出名的文件输出的文件名 chunkFilename: utils.assetsPath('js/[id].[chunkhash].js') &#125;, plugins: [ // definePlugin 接收字符串插入到代码当中, 所以你需要的话可以写上 JS 的字符串 // 此处，插入适当的环境 // http://vuejs.github.io/vue-loader/en/workflow/production.html new webpack.DefinePlugin(&#123; 'process.env': env &#125;), // 压缩 js new webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false &#125;, sourceMap: true &#125;), // 提取 css new ExtractTextPlugin(&#123; filename: utils.assetsPath('css/[name].[contenthash].css') &#125;), // 压缩提取出来的 css // 可以删除来自不同组件的冗余代码 // Compress extracted CSS. We are using this plugin so that possible // duplicated CSS from different components can be deduped. new OptimizeCSSPlugin(), // 将 index.html 作为入口，注入 html 代码后生成 index.html文件 // https://github.com/ampedandwired/html-webpack-plugin new HtmlWebpackPlugin(&#123; filename: process.env.NODE_ENV === 'testing' ? 'index.html' : config.build.index, template: 'index.html', inject: true, minify: &#123; removeComments: true, collapseWhitespace: true, removeAttributeQuotes: true // 更多选项 https://github.com/kangax/html-minifier#options-quick-reference &#125;, // 必须通过 CommonsChunkPlugin一致地处理多个 chunks chunksSortMode: 'dependency' &#125;), // 分割公共 js 到独立的文件 // https://webpack.js.org/guides/code-splitting-libraries/#commonschunkplugin new webpack.optimize.CommonsChunkPlugin(&#123; name: 'vendor', minChunks: function (module, count) &#123; // node_modules中的任何所需模块都提取到vendor return ( module.resource &amp;&amp; /\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf( path.join(__dirname, '../node_modules') ) === 0 ) &#125; &#125;), // 将webpack runtime 和模块清单 提取到独立的文件，以防止当 app包更新时导致公共 jsd hash也更新 // extract webpack runtime and module manifest to its own file in order to // prevent vendor hash from being updated whenever app bundle is updated new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest', chunks: ['vendor'] &#125;), // 复制静态资源 // https://github.com/kevlened/copy-webpack-plugin new CopyWebpackPlugin([ &#123; from: path.resolve(__dirname, '../static'), to: config.build.assetsSubDirectory, ignore: ['.*'] &#125; ]) ]&#125;)// 开启 gzip 的情况时，给 webpack plugins添加 compression-webpack-plugin 插件if (config.build.productionGzip) &#123; // webpack 压缩插件 // https://github.com/webpack-contrib/compression-webpack-plugin var CompressionWebpackPlugin = require('compression-webpack-plugin') // 向webpackconfig.plugins中加入下方的插件 webpackConfig.plugins.push( new CompressionWebpackPlugin(&#123; asset: '[path].gz[query]', algorithm: 'gzip', test: new RegExp( '\\.(' + config.build.productionGzipExtensions.join('|') + ')$' ), threshold: 10240, minRatio: 0.8 &#125;) )&#125;// 开启包分析的情况时， 给 webpack plugins添加 webpack-bundle-analyzer 插件if (config.build.bundleAnalyzerReport) &#123; // https://github.com/th0r/webpack-bundle-analyzer var BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin webpackConfig.plugins.push(new BundleAnalyzerPlugin())&#125;module.exports = webpackConfig]]></content>
      <categories>
        <category>webpack</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2F2018%2F11%2F22%2Fwebpack%2F</url>
    <content type="text"><![CDATA[四个核心概念： 入口(entry) 输出(output) loader 插件(plugins) 入口入口起点(entry point)指示 webpack 应该使用哪个模块，来作为构建其内部依赖图的开始。进入入口起点后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的。 每个依赖项随即被处理，最后输出到称之为 bundles 的文件中。 123module.exports = &#123; entry: './path/to/my/entry/file.js'&#125;; 出口output 属性告诉 webpack 在哪里输出它所创建的 bundles，以及如何命名这些文件，默认值为 ./dist。基本上，整个应用程序结构，都会被编译到你指定的输出路径的文件夹中。 123456789const path = require('path');module.exports = &#123; entry: './path/to/my/entry/file.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js' &#125;&#125;; 在上面的示例中，我们通过 output.filename 和 output.path 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成(emit)到哪里。 loaderoader 让 webpack 能够去处理那些非 JavaScript 文件（webpack 自身只理解 JavaScript）。loader 可以将所有类型的文件转换为 webpack 能够处理的有效模块，然后你就可以利用 webpack 的打包能力，对它们进行处理。 在更高层面，在 webpack 的配置中 loader 有两个目标： test 属性，用于标识出应该被对应的 loader 进行转换的某个或某些文件。 use 属性，表示进行转换时，应该使用哪个 loader。 1234567891011121314const path = require('path');const config = &#123; output: &#123; filename: 'my-first-webpack.bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.txt$/, use: 'raw-loader' &#125; ] &#125;&#125;;module.exports = config; 以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息： “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先使用 raw-loader 转换一下。” 插件loader 被用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。插件的范围包括，从打包优化和压缩，一直到重新定义环境中的变量。 123456789101112131415const HtmlWebpackPlugin = require('html-webpack-plugin'); // 通过 npm 安装const webpack = require('webpack'); // 用于访问内置插件const config = &#123; module: &#123; rules: [ &#123; test: /\.txt$/, use: 'raw-loader' &#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123;template: './src/index.html'&#125;) ]&#125;;module.exports = config; 模式123module.exports = &#123; mode: 'production'&#125;; 支持以下字符串值： developmen会将 process.env.NODE_ENV 的值设为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin。 12345678// webpack.development.config.jsmodule.exports = &#123;+ mode: 'development'- plugins: [- new webpack.NamedModulesPlugin(),- new webpack.DefinePlugin(&#123; "process.env.NODE_ENV": JSON.stringify("development") &#125;),- ]&#125; productio会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin. 12345678910// webpack.production.config.jsmodule.exports = &#123;+ mode: 'production',- plugins: [- new UglifyJsPlugin(/* ... */),- new webpack.DefinePlugin(&#123; "process.env.NODE_ENV": JSON.stringify("production") &#125;),- new webpack.optimize.ModuleConcatenationPlugin(),- new webpack.NoEmitOnErrorsPlugin()- ]&#125; 基本配置12345678910var path = require('path');module.exports = &#123; mode: 'development', entry: './foo.js', output: &#123; path: path.resolve(__dirname, 'dist'), filename: 'foo.bundle.js' &#125;&#125;;]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nodejs与npm]]></title>
    <url>%2F2018%2F11%2F19%2Fnodejs%E4%B8%8Enpm%2F</url>
    <content type="text"><![CDATA[nodejs与npm转自 https://www.jianshu.com/p/f581cf9360a2 https://my.oschina.net/dkvirus/blog/1137862 https://blog.csdn.net/u011584949/article/details/80447715 nodejs安装nodejs的安装只需要保持默认即可。 新版的Node.js已自带npm，安装Node.js时会一起安装，npm的作用就是对Node.js依赖的包进行管理，也可以理解为用来安装/卸载Node.js需要装的东西。 环境配置在nodejs安装之后，在C:\Users\你的用户命\AppData\Roaming目录下会生成两个文件夹 npm-cache是缓存文件夹，npm文件夹中有node_modules文件夹用于存储全局暗装的模块。 以后在执行类似：npm install express -g（后面的可选参数-g，g代表global全局安装的意思）的安装语句时 就会安装到npm文件夹下有node_modules中。 如果想要全模块所在路径和缓存路径放在node.js安装的文件夹中就需要配置一下 1.在nodejs安装的文件夹下创建两个文件夹node_global及node_cache2.创建完两个空文件夹之后，打开cmd命令窗口，输入12npm config set prefix &quot;D:\Develop\nodejs\node_global&quot;//根据自己的安装路径npm config set cache &quot;D:\Develop\nodejs\node_cache&quot;//根据自己的安装路径 3.设置环境变量在【系统变量】下新建【NODE_PATH】，输入D:\Develop\nodejs\node_global\node_modules】，将【用户变量】下的【Path】修改为【D:\Develop\nodejs\node_global】 配置完毕！ npm和cnpmnpm:（node package manager）是nodejs的包管理器，用于node插件管理（包括安装、卸载、管理依赖等）, NPM是随同NodeJS一起安装的包管理工具。 cnpm：因为npm安装插件是从国外服务器下载，受网络影响大，可能出现异常，所以我们乐于分享的淘宝团队干了这事。来自官网：“这是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。” cnpm跟npm用法完全一致，只是在执行命令时将npm改为cnpm。 package.json因为node插件包非常大，版本庞杂，所以不加入package信息，模块间的依赖变得非常困难，将配置信息写入package.json并将其加入版本管理，其他开发者对应下载即可（命令提示符执行npm install，则会根据package.json下载所有需要的包）。 每个项目的根目录下面，一般都有一个package.json文件，定义了这个项目所需要的各种模块，以及项目的配置信息（比如名称、版本、许可证等元数据）。npm install 命令根据这个配置文件，自动下载所需的模块，也就是配置项目所需的运行和开发环境。 package.json 文件详解示例12345678910111213141516171819202122"private": true, "dependencies": &#123; "antd": "^2.11.1", "classnames": "^2.2.5" &#125;, "devDependencies": &#123; "axios": "^0.15.3", "babel-eslint": "^6.1.2" &#125;, "bin": &#123;"dk-cli": "./bin/dk-cli.js" &#125;, "scripts": &#123; "start": "node index.js" &#125;, "engines": &#123; "node": "&gt;=6.9.0", "npm": "&gt;=3.10.10" &#125; "publishConfig": &#123; "registry": "http://gongsineibu/nexus/repository/npm-hosted/" &#125; 说明1. private 属性可选字段，布尔值。如果 private 为 true，npm 会拒绝发布。 这可以防止私有 repositories 不小心被发布出去。 2. dependencies 与 devDependencies dependencies 指定了项目生产环境时所依赖的模块； devDependencies 制定了项目开发环境时所依赖的模块。 在开发阶段，我们需要对开发的模块进行单元测试，这时在开发环境 devDependencies 下就要安装单元测试模块 Mocha。 在生产环境 dependencies，用户直接使用项目，此时项目的开发已全部完成。这时就不需要单元测试模块了，再加上只会影响性能。 3. bin 属性如果你需要使用 npm 开发一个命令行工具，那么这个属性就会很有用。 4. scripts 属性scripts 中文名称为脚本，也就是说可以为我们带来便利。 以上面的配置为例： scripts 的脚本运行方式是在命令行中输入 npm run &lt;脚本名称&gt; 上图中只有一个 start 值，那么运行时要输入 npm run start 如果不输入脚本，就需要在命令行中输入 node index.js 这行代码 真实情况是输入 node index.js 但是觉得这么太麻烦，就用 npm run start 去代替 node index.js。 5. engines 属性一直很纳闷一件事，就是怎么通过 package.json 文件就能知道当前项目依赖 node 的哪个版本，依赖 npm 的哪个版本。。。 后来偶然发现，package.json 中已经提供了这个一个属性，用来记录当前项目依赖 node 和 npm 的版本号。写法如下： 1234"engines": &#123; "node": "&gt;=6.9.0", "npm": "&gt;=3.10.10"&#125; 6.publishConfig 属性我们开发完自己的项目想要将它发布到 Npm 仓库就需要使用这个属性。默认情况下我们是往 Npm 公共仓库中发布包，默认地址是：https://www.npmjs.com/，此时在 package.json 文件中可以不加这个属性。 但是如果公司内部搭建了 Npm 私有仓库，此时发布包就不是往 https://www.npmjs.com/ 这个地址上发布了，而是公司内部提供的地址，如：http://gongsineibu/nexus/repository/npm-hosted/。此时配置如下： 123"publishConfig": &#123; "registry": "http://gongsineibu/nexus/repository/npm-hosted/" &#125; npm常用命令npm initnpm init 用于创建 package.json package.json 文件里记录项目的描述信息：项目作者、项目描述、项目依赖哪些包、插件配置信息等等 使用 npm init 指令创建项目描述文件 package.json。 命令行里会以交互的形式让你填一些项目的介绍信息，依次介绍如下：（不知道怎么填的直接回车、回车…） name 项目名称 version 项目的版本号 description 项目的描述信息 entry point 项目的入口文件 test command 项目启动时脚本命令 git repository 如果你有 Git 地址，可以将这个项目放到你的 Git 仓库里 keywords 关键词 author 作者叫啥 license 项目要发行的时候需要的证书 npm install 模块名 -g全局安装 npm install 模块名本地安装 npm install 模块1 模块2 模块3一次性安装多个 npm install 模块名 –save安装运行时依赖包，会加入到package.json的dependencies中 npm install 模块名 –save-dev安装开发时依赖包，会加入到package.json的devDependenciess中 npm root查看项目中模块所在的目录 npm root -g查看全局安装的模块所在目录 npm help查看npm的所有命令的命令 更新node模块12345npm update 模块名 //当然你也可以update 该模块到指定版本 npm update 模块名 @版本号 //如果安装到最新版本可以使用以下命令 npm install 模块名@latest npm view 模块名 dependencies查看某个包对于各种包的依赖关系 npm view 模块名查看一个模块的所有信息 npm outdated检查包是否已经过时 npm uninstall 模块名卸载node模块 npm list查看当前已经安装的模块]]></content>
      <categories>
        <category>nodejs</category>
      </categories>
      <tags>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域总结]]></title>
    <url>%2F2018%2F11%2F16%2F%E8%B7%A8%E5%9F%9F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[后端跨域应用场景前后端分离情况下，前端使用nodejs服务器，后端使用tomcat。前端ajax跨域调用后端接口 解决方式1、使用@CrossOrigin 注解实现如果想要对某一接口配置 CORS，可以在方法上添加 @CrossOrigin 注解 ： 12345678@CrossOrigin(origins = "http://localhost:3000")//允许3000端口的访问@RequestMapping("/findList")@ResponseBodypublic List&lt;Staff&gt; findList()&#123; List&lt;Staff&gt; list = staffService.findList(); return list;&#125; 2.如果想对一系列接口添加 CORS 配置，可以在类上添加注解，对该类声明所有接口都有效1234567891011121314151617@CrossOrigin(origins = "http://localhost:3000")//允许3000端口的访问@Controller@RequestMapping("/staff")public class StaffController extends BaseController&#123; @Autowired private StaffService staffService; @RequestMapping("/findList") @ResponseBody public List&lt;Staff&gt; findList()&#123; List&lt;Staff&gt; list = staffService.findList(); return list; &#125;&#125; 3.如果想添加全局配置，则需要添加一个配置类123456789101112@Configurationpublic class WebMvcConfig extends WebMvcConfigurerAdapter &#123; @Override public void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping("/**") .allowedOrigins("*") .allowedMethods("POST", "GET", "PUT", "OPTIONS", "DELETE") .maxAge(3600) .allowCredentials(true); &#125;&#125; 前端跨域应用场景部署在不同源的前端页面互相调用 下面是 Node 如何跨域的两种方法，均是在服务器设置 方法一123456789101112app.use('*',function (req, res, next) &#123; res.header('Access-Control-Allow-Origin', '*'); //这个表示任意域名都可以访问，这样写不能携带cookie了。//res.header('Access-Control-Allow-Origin', 'http://www.baidu.com'); //这样写，只有www.baidu.com 可以访问。 res.header('Access-Control-Allow-Headers', 'Content-Type, Content-Length, Authorization, Accept, X-Requested-With , yourHeaderFeild'); res.header('Access-Control-Allow-Methods', 'PUT, POST, GET, DELETE, OPTIONS');//设置方法 if (req.method == 'OPTIONS') &#123; res.send(200); // 意思是，在正常的请求之前，会发送一个验证，是否可以请求。 &#125; else &#123; next(); &#125;&#125;); 方法二安装cors 1$ npm install cors 对所有的路由启用cors 12345678910111213var express = require('express') , cors = require('cors') , app = express();app.use(cors());app.get('/products/:id', function(req, res, next)&#123; res.json(&#123;msg: 'This is CORS-enabled for all origins!'&#125;);&#125;);app.listen(80, function()&#123; console.log('CORS-enabled web server listening on port 80');&#125;); 对某个路由启用cors 1234567891011var express = require('express') , cors = require('cors') , app = express();app.get('/products/:id', cors(), function(req, res, next)&#123; res.json(&#123;msg: 'This is CORS-enabled for all origins!'&#125;);&#125;);app.listen(80, function()&#123; console.log('CORS-enabled web server listening on port 80');&#125;); 切记google浏览器跨域调用时的url一定要加www://正确： 1var url = &quot;http://localhost:8888/staff/findList&quot;; 错误： 1var url = &quot;localhost:8888/staff/findList&quot;;]]></content>
      <categories>
        <category>跨域</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot整合Druid监控配置]]></title>
    <url>%2F2018%2F11%2F15%2Fspringboot%E6%95%B4%E5%90%88Druid%E7%9B%91%E6%8E%A7%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[依赖注意添加log4j依赖否则会报错，或者把spring.datasource.filters=stat,wall,log4j中的log4j去掉 1234567891011121314151617181920212223242526272829303132333435363738&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jdbcTemplate --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.26&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql connector --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Druid配置123456789101112131415161718192021222324252627282930#数据库设置spring.datasource.driverClassName=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/druid_demo?useUnicode=true&amp;characterEncoding=utf8&amp;autoReconnect=truespring.datasource.username=rootspring.datasource.password=123#--------------------------# 下面为连接池的补充设置，应用到上面所有数据源中# 初始化大小，最小，最大spring.datasource.initialSize=5spring.datasource.minIdle=1spring.datasource.maxActive=50# 配置获取连接等待超时的时间spring.datasource.maxWait=60000# 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒spring.datasource.timeBetweenEvictionRunsMillis=60000# 配置一个连接在池中最小生存的时间，单位是毫秒spring.datasource.minEvictableIdleTimeMillis=300000spring.datasource.validationQuery=SELECT 1 FROM DUALspring.datasource.testWhileIdle=truespring.datasource.testOnBorrow=falsespring.datasource.testOnReturn=false# 打开PSCache，并且指定每个连接上PSCache的大小spring.datasource.poolPreparedStatements=false#spring.datasource.maxPoolPreparedStatementPerConnectionSize=20# 配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙spring.datasource.filters=stat,wall,log4j# 通过connectProperties属性来打开mergeSql功能；慢SQL记录spring.datasource.connectionProperties=druid.stat.mergeSql=true;druid.stat.slowSqlMillis=5000# 合并多个DruidDataSource的监控数据#spring.datasource.useGlobalDataSourceStat=true 实例化Druid Datasource1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Configuration@PropertySource(value = "classpath:druid.properties")public class DruidConfiguration &#123; @Bean @ConfigurationProperties(prefix = "spring.datasource") public DataSource druidDataSource() &#123; DruidDataSource druidDataSource = new DruidDataSource(); return druidDataSource; &#125; /** * 注册一个StatViewServlet * @return */ @Bean public ServletRegistrationBean druidStatViewServlet()&#123; //org.springframework.boot.context.embedded.ServletRegistrationBean提供类的进行注册. ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean(new StatViewServlet(),"/druid/*"); //添加初始化参数：initParams //白名单： servletRegistrationBean.addInitParameter("allow","127.0.0.1"); //IP黑名单 (存在共同时，deny优先于allow) : 如果满足deny的话提示:Sorry, you are not permitted to view this page. servletRegistrationBean.addInitParameter("deny","192.168.1.73"); //登录查看信息的账号密码. servletRegistrationBean.addInitParameter("loginUsername","admin"); servletRegistrationBean.addInitParameter("loginPassword","123456"); //是否能够重置数据. servletRegistrationBean.addInitParameter("resetEnable","false"); return servletRegistrationBean; &#125; /** * 注册一个：filterRegistrationBean * @return */ @Bean public FilterRegistrationBean druidStatFilter()&#123; FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean(new WebStatFilter()); //添加过滤规则. filterRegistrationBean.addUrlPatterns("/*"); //添加不需要忽略的格式信息. filterRegistrationBean.addInitParameter("exclusions","*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*"); return filterRegistrationBean; &#125;&#125; 监控访问 http://localhost:8080/druid， 使用上面配置的账号密码。 测试1234567891011121314@RestControllerpublic class HelloController&#123; private static final Logger logger = LoggerFactory.getLogger(HelloController.class); @Autowired private JdbcTemplate jdbcTemplate; @RequestMapping("hello") public List&lt;Map&lt;String, Object&gt;&gt; hello() &#123; List&lt;Map&lt;String, Object&gt;&gt; list = jdbcTemplate.queryForList("SELECT user,password FROM user ", new Object[]&#123;&#125;); return list; &#125;&#125; 访问localhost:8080/hello 12345user &quot;东西&quot;password &quot;123&quot;user &quot;南北&quot;password &quot;234&quot; 最新的druid-spring-boot-starter可以直接在配置文件中配置StatViewServlet和filter 所以介绍第二种方法不用写java代码 依赖123456789101112131415161718192021222324252627282930313233343536373839&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jdbcTemplate --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- druid数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql connector --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.38&lt;/version&gt; &lt;/dependency&gt; &lt;!--log4j--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置properties方式1234567891011121314151617181920212223242526272829#数据库设置spring.datasource.type=com.alibaba.druid.pool.DruidDataSourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/druid_demo?useSSL=false&amp;characterEncoding=utf8spring.datasource.username=rootspring.datasource.password=123spring.datasource.druid.initial-size=5spring.datasource.druid.min-idle=5spring.datasource.druid.maxActive=20spring.datasource.druid.maxWait=60000spring.datasource.druid.timeBetweenEvictionRunsMillis=60000spring.datasource.druid.minEvictableIdleTimeMillis=300000spring.datasource.druid.validationQuery=SELECT 1 FROM DUALspring.datasource.druid.testWhileIdle=truespring.datasource.druid.testOnBorrow=falsespring.datasource.druid.testOnReturn=falsespring.datasource.druid.poolPreparedStatements=truespring.datasource.druid.maxPoolPreparedStatementPerConnectionSize=20spring.datasource.druid.filters=stat,wall,log4jspring.datasource.druid.connectionProperties=druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000spring.datasource.druid.web-stat-filter.enabled=truespring.datasource.druid.web-stat-filter.url-pattern=/*spring.datasource.druid.web-stat-filter.exclusions=*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*spring.datasource.druid.stat-view-servlet.url-pattern=/druid/*spring.datasource.druid.stat-view-servlet.allow=127.0.0.1,192.168.163.1spring.datasource.druid.stat-view-servlet.deny=192.168.1.73spring.datasource.druid.stat-view-servlet.reset-enable=falsespring.datasource.druid.stat-view-servlet.login-username=adminspring.datasource.druid.stat-view-servlet.login-password=123456 yml方式示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152spring: application: name: springboot-test-exam1 datasource: # 使用阿里的Druid连接池 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver # 填写你数据库的url、登录名、密码和数据库名 url: jdbc:mysql://localhost:3306/databaseName?useSSL=false&amp;characterEncoding=utf8 username: root password: root druid: # 连接池的配置信息 # 初始化大小，最小，最大 initial-size: 5 min-idle: 5 maxActive: 20 # 配置获取连接等待超时的时间 maxWait: 60000 # 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 timeBetweenEvictionRunsMillis: 60000 # 配置一个连接在池中最小生存的时间，单位是毫秒 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false # 打开PSCache，并且指定每个连接上PSCache的大小 poolPreparedStatements: true maxPoolPreparedStatementPerConnectionSize: 20 # 配置监控统计拦截的filters，去掉后监控界面sql无法统计，'wall'用于防火墙 filters: stat,wall,log4j # 通过connectProperties属性来打开mergeSql功能；慢SQL记录 connectionProperties: druid.stat.mergeSql\=true;druid.stat.slowSqlMillis\=5000 # 配置DruidStatFilter web-stat-filter: enabled: true url-pattern: "/*" exclusions: "*.js,*.gif,*.jpg,*.bmp,*.png,*.css,*.ico,/druid/*" # 配置DruidStatViewServlet stat-view-servlet: url-pattern: "/druid/*" # IP白名单(没有配置或者为空，则允许所有访问) allow: 127.0.0.1,192.168.163.1 # IP黑名单 (存在共同时，deny优先于allow) deny: 192.168.1.73 # 禁用HTML页面上的“Reset All”功能 reset-enable: false # 登录名 login-username: admin # 登录密码 login-password: 123456 访问：http://localhost:8080/druid/，登录名：admin，密码123456]]></content>
      <categories>
        <category>springboot</category>
        <category>druid</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>druid</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UsernamePasswordAuthenticationFilter]]></title>
    <url>%2F2018%2F10%2F31%2FUsernamePasswordAuthenticationFilter%2F</url>
    <content type="text"><![CDATA[内容转载参考自： https://www.cnblogs.com/xuwenjin/p/9565356.html https://www.cnblogs.com/zsxneil/p/6622564.html https://blog.csdn.net/yecong111/article/details/17015199 UsernamePasswordAuthenticationFilterUsernamePasswordAuthenticationFilter，实现了我们最常用的基于用户名和密码的认证逻辑。 UsernamePasswordAuthenticationFilter继承虚拟类AbstractAuthenticationProcessingFilter。 AbstractAuthenticationProcessingFilter要求设置一个authenticationManager。 authenticationManager的实现类将实现处理请求的认证。 AbstractAuthenticationProcessingFilter将拦截符合过滤规则的request，并试图执行认证。子类必须实现 attemptAuthentication 方法，这个方法执行具体的认证。 认证处理：如果认证成功，将会把返回的Authentication对象存放在SecurityContext；然后setAuthenticationSuccessHandler(AuthenticationSuccessHandler)方法将会调用；这里处理认证成功后跳转url的逻辑；可以重新实现AuthenticationSuccessHandler的onAuthenticationSuccess方法，实现自己的逻辑，比如需要返回json格式数据时，就可以在这里重新相关逻辑。 如果认证失败，默认会返回401代码给客户端，当然也可以在&lt;form-login&gt;节点中配置失败后跳转的url，还可以重写AuthenticationFailureHandler的onAuthenticationFailure方法实现自己的逻辑。 AuthenticationManager顾名思义就是认证管理器，用于管理使用什么AuthenticationProvider验证用户的合法性，它拥有2个重要的参数类: List&lt;AuthenticationProvider&gt; providers AuthenticationManager parent 其中providers是AuthenticationProvider（接口，认证实现者）的集合 AuthenticationProvider 可以处理一个特定的Authentication，实现身份验证。它有2个方法 Authentication authenticate(Authentication authentication) throws AuthenticationException;（根据authentication信息实现身份验证） ​ boolean supports(Class&lt;?&gt; authentication); 用于判断该AnonymousAuthenticationProvider能够验证某种类型的Authentication AuthenticationManager的方法authenticate执行逻辑（1）、判断是否有Authentication 对应的AuthenticationProvider，有就执行AuthenticationProvider的authenticate方法，没有就获取父类AuthenticationManager，查看父类中是否有Authentication 对应的AuthenticationProvider，如果也没有则抛出ProviderNotFoundException异常。 （2）执行AuthenticationProvider的authenticate方法 1、根据输入名，查看缓存中是否已经有有用户实体对象，如果有，则对密码重新验证；如果没有，则进行用户的信息验证，及执行DaoAuthenticationProvider中的retrieveUser方法，获取一个UserDetails对象，如果UserDetails对象为null或者获取时出错就抛出异常UsernameNotFoundException或AuthenticationServiceException异常，然后一些属性验证之后，对用户密码进行验证。 2、给新获取的UserDetails对象放入缓存中 3、新建一个UsernamePasswordAuthenticationToken一个对象，将authenticated设为true(原来传入的UsernamePasswordAuthenticationToken对象authenticated为false)并返回。 ProviderManager它是AuthenticationManager的一个实现类，实现了authenticate(Authentication authentication)方法，还有一个成员变量 List&lt;AuthenticationProvider&gt; providers 123456789101112public class ProviderManager implements AuthenticationManager, MessageSourceAware,InitializingBean &#123; ...... private List&lt;AuthenticationProvider&gt; providers = Collections.emptyList(); public Authentication authenticate(Authentication authentication) throws AuthenticationException &#123; ...... &#125;&#125; AuthenticationProviderAuthenticationProvider也是一个接口，包含两个函数authenticate和supports。当Spring Security默认提供的Provider不能满足需求的时候，可以通过实现AuthenticationProvider接口来扩展出不同的认证提供者 12345678910public interface AuthenticationProvider &#123; //通过参数Authentication对象，进行认证 Authentication authenticate(Authentication authentication) throws AuthenticationException; //是否支持该认证类型 boolean supports(Class&lt;?&gt; authentication); &#125; AuthenticationAuthentication是一个接口，通过该接口可以获得用户相关信息、安全实体的标识以及认证请求的上下文信息等 在Spring Security中，有很多Authentication的实现类。如UsernamePasswordAuthenticationToken、AnonymousAuthenticationToken和 RememberMeAuthenticationToken等等 通常不会被扩展，除非是为了支持某种特定类型的认证 123456789101112131415161718192021public interface Authentication extends Principal, Serializable &#123; //权限结合，可使用AuthorityUtils.commaSeparatedStringToAuthorityList("admin, ROLE_ADMIN")返回字符串权限集合 Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); //用户名密码认证时可以理解为密码 Object getCredentials(); //认证时包含的一些信息。如remoteAddress、sessionId Object getDetails(); //用户名密码认证时可理解时用户名 Object getPrincipal(); //是否被认证，认证为true boolean isAuthenticated(); //设置是否被认证 void setAuthenticated(boolean isAuthenticated) throws IllegalArgumentException; &#125; UserDetails12345678910111213141516171819202122public interface UserDetails extends Serializable &#123; //权限集合 Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); //密码 String getPassword(); //用户名 String getUsername(); //用户名是否没有过期 boolean isAccountNonExpired(); //用户名是否没有锁定 boolean isAccountNonLocked(); //用户密码是否没有过期 boolean isCredentialsNonExpired(); //账号是否可用(可理解为是否删除) boolean isEnabled(); &#125; 认证过程总结 AbstractAuthenticationProcessingFilter将拦截符合过滤规则的request，并试图执行认证。 UsernamePasswordAuthenticationFilter为AbstractAuthenticationProcessingFilter子类处理用户名密码的认证逻辑 在UsernamePasswordAuthenticationFilter的attemptAuthentication()方法中，调用AuthenticationManager进行认证 AuthenticationManager接收Authentication对象作为参数，并通过authenticate方法对其进行验证(实际由默认的其实现类ProviderManager完成) 在ProviderManager的authenticate方法中，轮训成员变量List&lt;AuthenticationProvider&gt; providers。该providers中如果有一个AuthenticationProvider的supports函数返回true，那么就会调用该AuthenticationProvider的authenticate函数认证，如果认证成功则整个认证过程结束。如果不成功，则继续使用下一个合适的AuthenticationProvider进行认证，只要有一个认证成功则为认证成功。 UsernamePasswordAuthenticationToken实现了Authentication，主要是将用户输入的用户名密码进行封装，并提供给AuthenticationManager进行验证，验证成功后，返回一个认证成功的UsernamePasswordAuthenticationToken对象]]></content>
      <categories>
        <category>springsecurity</category>
      </categories>
      <tags>
        <tag>springsecurity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring集成Quartz]]></title>
    <url>%2F2018%2F10%2F29%2Fspring%E9%9B%86%E6%88%90Quartz%2F</url>
    <content type="text"><![CDATA[转自https://cloud.tencent.com/developer/article/1335825 spring的整合Quartz，spring提供了几个类、接口（这些类都实现了Job接口）： org.springframework.scheduling.quartz.QuartzJobBean org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean.MethodInvokingJob org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean.StatefulMethodInvokingJob QuartzJobBean和MethodInvokingJob是无状态的，StatefulMethodInvokingJob是有状态的。 可以选择自己的需求选择继承与哪个类。 引入依赖12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;springversion&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;springversion&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;springversion&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;springversion&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;springversion&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;springversion&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;springversion&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;!-- sheduler --&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt; 第一种任务类继承QuartzJobBean12345public class SpringQtz extends QuartzJobBean &#123; protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; System.out.println("继承QuartzJobBean定时任务执行中…"); &#125;&#125; applicationContext.xml配置文件123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- spring配置文件中配置作业类JobDetailBean --&gt; &lt;bean name="springQtz" class="org.springframework.scheduling.quartz.JobDetailFactoryBean"&gt; &lt;property name="jobClass" value="job.SpringQtz" /&gt; &lt;property name="jobDataAsMap"&gt; &lt;map&gt; &lt;entry key="timeout" value="0" /&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置作业调度的触发方式（触发器） --&gt; &lt;!-- 每隔多少时间执行一次 --&gt; &lt;bean id="simpleTrigger" class="org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="springQtz" /&gt; &lt;property name="startDelay" value="0" /&gt; &lt;!-- 调度工厂实例化后，经过0秒开始执行调度 --&gt; &lt;property name="repeatInterval" value="2000" /&gt;&lt;!-- 每2秒调度一次 --&gt; &lt;/bean&gt; &lt;!-- 某个时间点执行一次 --&gt; &lt;bean id="cronTrigger" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="springQtz" /&gt; &lt;!-- 每天12:00运行一次 --&gt; &lt;property name="cronExpression" value="0 0 19 * * ? *" /&gt; &lt;/bean&gt; &lt;!-- 配置调度工厂 --&gt; &lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;ref bean="simpleTrigger" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; cron表达式可以用在线的cron生成器 启动web应用控制台打印 123456继承QuartzJobBean定时任务执行中…继承QuartzJobBean定时任务执行中…继承QuartzJobBean定时任务执行中…继承QuartzJobBean定时任务执行中…继承QuartzJobBean定时任务执行中…... 第二种在配置文件里定义任务类和要执行的方法，类和方法仍然是普通类。1.定义java普通类12345public class SpringQtz2 &#123; public void executeTask()&#123; System.out.println("普通类定时任务执行中…"); &#125;&#125; 2.springContext.xml1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 定义目标bean和bean中的方法 --&gt; &lt;bean id="SpringQtzBean" class="job.SpringQtz2" /&gt; &lt;!-- 方式二：使用MethodInvokingJobDetailFactoryBean，任务类可以不实现Job接口，通过targetMethod指定调用方法 --&gt;&lt;bean id="SpringQtzJobMethod" class="org.springframework.scheduling.quartz.MethodInvokingJobDetailFactoryBean"&gt; &lt;property name="targetObject"&gt; &lt;ref bean="SpringQtzBean" /&gt; &lt;/property&gt; &lt;property name="targetMethod"&gt; &lt;!-- 要执行的方法名称 --&gt; &lt;value&gt;executeTask&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置作业调度的触发方式（触发器） --&gt; &lt;!-- 每隔多少时间执行一次 --&gt; &lt;bean id="simpleTrigger2" class="org.springframework.scheduling.quartz.SimpleTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="SpringQtzJobMethod" /&gt; &lt;property name="startDelay" value="0" /&gt; &lt;!-- 调度工厂实例化后，经过0秒开始执行调度 --&gt; &lt;property name="repeatInterval" value="2000" /&gt;&lt;!-- 每2秒调度一次 --&gt; &lt;/bean&gt; &lt;!-- 某个时间点执行一次 --&gt; &lt;bean id="cronTrigger2" class="org.springframework.scheduling.quartz.CronTriggerFactoryBean"&gt; &lt;property name="jobDetail" ref="SpringQtzJobMethod" /&gt; &lt;!-- 每天12:00运行一次 --&gt; &lt;property name="cronExpression" value="0 0 19 * * ? *" /&gt; &lt;/bean&gt; &lt;!-- 配置调度工厂 --&gt; &lt;bean class="org.springframework.scheduling.quartz.SchedulerFactoryBean"&gt; &lt;property name="triggers"&gt; &lt;list&gt; &lt;ref bean="simpleTrigger2" /&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.执行结果：普通类定时任务执行中… 普通类定时任务执行中… 普通类定时任务执行中… 普通类定时任务执行中… 普通类定时任务执行中… 继承StatefulMethodInvokingJob也是一样的]]></content>
      <categories>
        <category>quartz</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[@InitBinder]]></title>
    <url>%2F2018%2F10%2F29%2FInitBinder%2F</url>
    <content type="text"><![CDATA[转自https://blog.csdn.net/zero__007/article/details/80466392 @InitBinder用于在@Controller中标注于方法上，表示为当前控制器注册一个属性编辑器，只对当前的Controller有效。@InitBinder标注的方法必须有一个参数WebDataBinder。所谓的属性编辑器可以理解就是帮助我们完成参数绑定。 12345678910111213141516@ResponseBody @RequestMapping(value = "/test") public String test(@RequestParam String name,@RequestParam Date date) throws Exception &#123; System.out.println(name); System.out.println(date); return name; &#125; @InitBinder public void initBinder(WebDataBinder binder)&#123; binder.registerCustomEditor(String.class, new StringTrimmerEditor(true)); binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), false)); &#125; 上面例子中，@InitBinder方法会帮助我们把String类型的参数先trim再绑定，而对于Date类型的参数会先格式化在绑定。例如当请求是/test?name=%20zero%20&amp;date=2018-05-22时，会把zero绑定到name，再把时间串格式化为Date类型，再绑定到date。 这里的@InitBinder方法只对当前Controller生效，要想全局生效，可以使用@ControllerAdvice。通过@ControllerAdvice可以将对于控制器的全局配置放置在同一个位置，注解了@ControllerAdvice的类的方法可以使用@ExceptionHandler，@InitBinder，@ModelAttribute注解到方法上，这对所有注解了@RequestMapping的控制器内的方法有效。 12345678910111213@ControllerAdvicepublic class GlobalControllerAdvice &#123; @InitBinder public void initBinder(WebDataBinder binder) &#123; binder.registerCustomEditor(String.class, new StringTrimmerEditor(true)); binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), false)); &#125;&#125; 除了使用@ControllerAdvice来配置全局的WebDataBinder，还可以使用RequestMappingHandlerAdapter 12345678910111213@Bean public RequestMappingHandlerAdapter webBindingInitializer() &#123; RequestMappingHandlerAdapter adapter = new RequestMappingHandlerAdapter(); adapter.setWebBindingInitializer(new WebBindingInitializer()&#123; @Override public void initBinder(WebDataBinder binder, WebRequest request) &#123; binder.registerCustomEditor(Date.class, new CustomDateEditor(new SimpleDateFormat("yyyy-MM-dd"), false)); &#125; &#125;); return adapter; &#125; 可以实现同样的效果。 其实也可以选择集成BaseController类，在BaseController用@InitBinder进行格式转换。]]></content>
      <categories>
        <category>注解</category>
      </categories>
      <tags>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBootServletInitializer和WebApplicationInitializer]]></title>
    <url>%2F2018%2F10%2F29%2FSpringBootServletInitializer%E5%92%8CWebApplicationInitializer%2F</url>
    <content type="text"><![CDATA[转自：https://blog.csdn.net/zq17865815296/article/details/79464403 WebApplicationInitializer现在JavaConfig配置方式在逐步取代xml配置方式。而WebApplicationInitializer可以看做是Web.xml的替代。 通过实现WebApplicationInitializer，在其中可以添加servlet，listener等，在加载Web项目的时候会加载这个接口实现类，从而起到web.xml相同的作用。 为了支持可以不使用web.xml。提供了ServletContainerInitializer，它可以通过SPI机制，当启动web容器的时候，会自动到添加的相应jar包下找到META-INF/services下以ServletContainerInitializer的全路径名称命名的文件，它的内容为ServletContainerInitializer实现类的全路径，将它们实例化。 SpringServletContainerInitializer作为ServletContainerInitializer的实现类，通过SPI机制，在web容器加载的时候会自动的被调用。（这个类上还有一个注解@HandlesTypes，它的作用是将感兴趣的一些类注入到ServletContainerInitializerde）， 而这个类的方法又会扫描找到WebApplicationInitializer的实现类，调用它的onStartup方法，从而起到启动web.xml相同的作用。 自己通过一个实例来实现相同的功能1、定义接口WebParameter，它就相当于WebApplicationInitializer。 12345public interface WebParameter &#123; void loadOnstarp(ServletContext servletContext);&#125; 可以在这里面添加servlet，listener等。 2、定义Servlet。 123456789public class MyServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.getWriter().write("TestSetvlet"); &#125;&#125; 3、定义MyWebParameter作为WebParameter的实现类，将Servlet添加到上下文，并设置好映射。 12345678public class MyWebParameter implements WebParameter &#123; public void loadOnstarp(ServletContext servletContext) &#123; ServletRegistration.Dynamic testSetvelt=servletContext.addServlet("test","com.test.servlet.MyServlet"); testSetvelt.setLoadOnStartup(1); testSetvelt.addMapping("/test"); &#125;&#125; 4、定义好WebConfig作为ServletContainerInitializer的实现类，它的作用是扫描找到WebParameter的实现类，并调用其方法。 12345678910111213141516171819@HandlesTypes(&#123;WebParameter.class&#125;)public class WebConfig implements ServletContainerInitializer &#123; public void onStartup(Set&lt;Class&lt;?&gt;&gt; set, ServletContext servletContext) throws ServletException &#123; Iterator var4; if (set!=null)&#123; var4=set.iterator(); while(var4.hasNext())&#123; Class&lt;?&gt; clazz= (Class&lt;?&gt;) var4.next(); if (!clazz.isInterface()&amp;&amp; !Modifier.isAbstract(clazz.getModifiers())&amp;&amp;WebParameter.class.isAssignableFrom(clazz))&#123; try &#123; ((WebParameter) clazz.newInstance()).loadOnstarp(servletContext); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125;&#125; 5、根据SPI机制，定义一个META-INF/services文件夹，并在其下定义相关文件名称，并将WebConfig的类全名称填入其中。 文件名javax.servlet.ServletContainerInitializer 文件内容：initializer.WebConfig 6.用maven通过install将其作为jar包上传到本地仓库。从另外一个web项目调用这个包进行访问。 7.访问地址localhost:8080/test resp.getWriter().write(“TestSetvlet”);页面打印TestSetvlet SpringBootServletInitializerspringboot项目若要打包成war包,则需要继承 org.springframework.boot.context.web.SpringBootServletInitializer类,覆盖其config(SpringApplicationBuilder)方法 需要注意一下几点： 1.jar包中的打包方式根据自己的需要进行修改 2.若打包成war包,则需要继承 org.springframework.boot.context.web.SpringBootServletInitializer类,覆盖其config(SpringApplicationBuilder)方法 3.打包成war的话,如果打包之后的文件中没有web.xml文件的话自己可以加进去一个最简单的web.xml(只有根节点的定义,而没有子元素)，防止因缺乏web.xml文件而部署失败]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot整合多数据源方式2（动态）]]></title>
    <url>%2F2018%2F10%2F27%2Fspringboot%E6%95%B4%E5%90%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%E6%96%B9%E5%BC%8F2%EF%BC%88%E5%8A%A8%E6%80%81%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这个很厉害了！！这里要用到一个类AbstractRoutingDataSource 它继承于AbstractDataSource而AbstractDataSource又实现了DataSource接口，是一个标准的数据源。 这个类的基本运作方式： 它是一个abstract类，所以我们使用的话，推荐的方式是创建一个类来继承它并且实现它的determineCurrentLookupKey()方法，通过这个方法进行数据源的切换，这个时候你会又疑问，我没设置数据源，它是怎么切换的？上面我贴出了另外一个核心的方法setTargetDataSources(Map targetDataSources)，它需要一个Map，这个Map存储的就是我们配置的多个数据源的键值对。 我们整理一下这个类切换数据源的运作方式，这个类在连接数据库之前会执行determineCurrentLookupKey()方法，这个方法返回的数据将作为key去targetDataSources中查找相应的值，如果查找到相对应的DataSource，那么就使用此DataSource获取数据库连接。 1.建立springboot项目，引入依赖12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;SpringBoorDataSource&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--druid--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.9&lt;/version&gt; &lt;/dependency&gt; &lt;!--aop--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2.application.properties可以看到配置了4个数据源。 12345678910111213141516171819202122232425262728## master1 数据源配置master1.datasource.url=jdbc:mysql://localhost:3306/test01?useUnicode=true&amp;characterEncoding=utf8master1.datasource.username=rootmaster1.datasource.password=123master1.datasource.driverClassName=com.mysql.jdbc.Driver## master2 数据源配置master2.datasource.url=jdbc:mysql://localhost:3306/test02?useUnicode=true&amp;characterEncoding=utf8master2.datasource.username=rootmaster2.datasource.password=123master2.datasource.driverClassName=com.mysql.jdbc.Driver## master3 数据源配置master3.datasource.url=jdbc:mysql://localhost:3306/test03?useUnicode=true&amp;characterEncoding=utf8master3.datasource.username=rootmaster3.datasource.password=123master3.datasource.driverClassName=com.mysql.jdbc.Driver## master4 数据源配置master4.datasource.url=jdbc:mysql://localhost:3306/test04?useUnicode=true&amp;characterEncoding=utf8master4.datasource.username=rootmaster4.datasource.password=123master4.datasource.driverClassName=com.mysql.jdbc.Driver#日志配置logging.config=classpath:logback-spring.xml#控制台打印sql语句logging.level.springboot.datasource.demo.mapper=debug 3.创建枚举类DataSourceKey这里存放的是数据源ID。 123456public enum DataSourceKey &#123; DB_MASTER1, DB_MASTER2, DB_MASTER3, DB_MASTER4&#125; 4.创建DynamicDataSourceContextHolder类，这个类是为了解决多线程访问全局变量的问题123456789101112131415161718192021//动态数据源上下文管理@Slf4jpublic class DynamicDataSourceContextHolder &#123; //存放当前线程使用的数据源ID private static final ThreadLocal&lt;DataSourceKey&gt; contextHolder = new ThreadLocal&lt;DataSourceKey&gt;(); //设置数据源 public static void setDataSource(DataSourceKey key) &#123; contextHolder.set(key); &#125; //获取数据源 public static DataSourceKey getDataSource() &#123; return contextHolder.get(); &#125; //清除数据源 public static void clearDataSource() &#123; contextHolder.remove(); &#125;&#125; 5.创建类DynamicDataSource继承AbstractRoutingDataSource类并且实现determineCurrentLookupKey()方法，设置数据源。123456789@Slf4jpublic class DynamicDataSource extends AbstractRoutingDataSource &#123; @Override protected Object determineCurrentLookupKey() &#123; log.info("当前数据源："+ DynamicDataSourceContextHolder.getDataSource()); return DynamicDataSourceContextHolder.getDataSource(); &#125;&#125; 6.创建配置类DynamicDataSourceConfiguration1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677@MapperScan(basePackages = "springboordatasource.demo.mapper")@Configurationpublic class DynamicDataSourceConfiguration &#123; @Bean @ConfigurationProperties(prefix = "master1.datasource") public DataSource dbMaster1() &#123; return DruidDataSourceBuilder.create().build(); &#125; @Bean @ConfigurationProperties(prefix = "master2.datasource") public DataSource dbMaster2() &#123; return DruidDataSourceBuilder.create().build(); &#125; @Bean @ConfigurationProperties(prefix = "master3.datasource") public DataSource dbMaster3() &#123; return DruidDataSourceBuilder.create().build(); &#125; @Bean @ConfigurationProperties(prefix = "master4.datasource") public DataSource dbMaster4() &#123; return DruidDataSourceBuilder.create().build(); &#125; /** * 核心动态数据源 * * @return 数据源实例 */ @Bean public DataSource dynamicDataSource() &#123; DynamicDataSource dataSource = new DynamicDataSource(); //默认数据源 dataSource.setDefaultTargetDataSource(dbMaster1()); //创建map，key为枚举，value为上面的datasource //DB_MASTER1对应master1.datasource数据源 //DB_MASTER2对应master2.datasource数据源 //DB_MASTER3对应master3.datasource数据源 //DB_MASTER4对应master4.datasource数据源 Map&lt;Object, Object&gt; dataSourceMap = new HashMap&lt;&gt;(4); dataSourceMap.put(DataSourceKey.DB_MASTER1, dbMaster1()); dataSourceMap.put(DataSourceKey.DB_MASTER2, dbMaster2()); dataSourceMap.put(DataSourceKey.DB_MASTER3, dbMaster3()); dataSourceMap.put(DataSourceKey.DB_MASTER4, dbMaster4()); //把map存入TargetDataSources dataSource.setTargetDataSources(dataSourceMap); return dataSource; &#125; //这里注入的datasource为DynamicDataSource @Bean public SqlSessionFactory sqlSessionFactory() throws Exception &#123; SqlSessionFactoryBean sqlSessionFactoryBean = new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dynamicDataSource()); sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources("classpath:mapper/*.xml")); return sqlSessionFactoryBean.getObject(); &#125; @Bean public SqlSessionTemplate sqlSessionTemplate() throws Exception &#123; return new SqlSessionTemplate(sqlSessionFactory()); &#125; /** * 事务管理 * * @return 事务管理实例 */ @Bean //这里注入的datasource为DynamicDataSource public PlatformTransactionManager platformTransactionManager() &#123; return new DataSourceTransactionManager(dynamicDataSource()); &#125;&#125; 7.创建自定义注解类1234567@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface TargetDataSource &#123; //默认值为DB_MASTER1 DataSourceKey dataSourceKey() default DataSourceKey.DB_MASTER1;&#125; 8.编写数据源切换切面类：DynamicDataSourceAspect@After里面的参数是切点表达式，可以是自定义的例如：”execution( com.demo.service..list*(..))” 也可以是前面定义好的pointcut()例如： 前面定义了@Pointcut(“execution( com.demo.service..list*(..))”) public void pointCut() { } 那么可以用@After（value = “pointCut()”）,但是这里用的是注解的方式 后面会在serviceimpl方法上加入@TargetDataSource注解，那么该方法就会被aop处理。在方法执行前通过 DynamicDataSourceContextHolder.setDataSource设定DataSource！ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Aspect@Order(-1)//动态切换数据源的问题，如果事务在前，数据源切换在后，会导致数据源切换失效.//// 保证该AOP在@Transactional之前执行@Component@Slf4jpublic class DynamicDataSourceAspect &#123; /** * 执行方法前更换数据源 * * @param joinPoint 切点 * @param targetDataSource 动态数据源 */ @Before("@annotation(targetDataSource)") public void doBefore(JoinPoint joinPoint, TargetDataSource targetDataSource) &#123; DataSourceKey dataSourceKey = targetDataSource.dataSourceKey(); if (dataSourceKey == DataSourceKey.DB_MASTER2) &#123; log.info(String.format("设置数据源为 %s", DataSourceKey.DB_MASTER2)); DynamicDataSourceContextHolder.setDataSource(DataSourceKey.DB_MASTER2); &#125; else if(dataSourceKey == DataSourceKey.DB_MASTER3)&#123; log.info(String.format("设置数据源为 %s", DataSourceKey.DB_MASTER3)); DynamicDataSourceContextHolder.setDataSource(DataSourceKey.DB_MASTER3); &#125; else if(dataSourceKey == DataSourceKey.DB_MASTER4)&#123; log.info(String.format("设置数据源为 %s", DataSourceKey.DB_MASTER4)); DynamicDataSourceContextHolder.setDataSource(DataSourceKey.DB_MASTER4); &#125; else &#123; log.info(String.format("使用默认数据源 %s", DataSourceKey.DB_MASTER1)); DynamicDataSourceContextHolder.setDataSource(DataSourceKey.DB_MASTER1); &#125; &#125; /** * 执行方法后清除数据源设置 * * @param joinPoint 切点 * @param targetDataSource 动态数据源 */ @After( "@annotation(targetDataSource)") public void doAfter(JoinPoint joinPoint, TargetDataSource targetDataSource) &#123; log.info(String.format("当前数据源 %s 执行清理方法", targetDataSource.dataSourceKey())); DynamicDataSourceContextHolder.clearDataSource(); &#125;&#125; 9.在springboot程序运行入口中设置取消自动配置数据源1234567@SpringBootApplication(exclude = &#123;DataSourceAutoConfiguration.class&#125;)public class DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(DemoApplication.class, args); &#125;&#125; 10.编写mapper和service123public interface UserMapper &#123; User selectById(Integer id);&#125; 12345678&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="springboordatasource.demo.mapper.UserMapper"&gt; &lt;select id="selectById" parameterType="int" resultType="springboordatasource.demo.entity.User"&gt; select * from test_user where uid = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 123456789101112@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserMapper userMapper; //设置动态数据源 @TargetDataSource(dataSourceKey = DataSourceKey.DB_MASTER1) @Override public User selectById(Integer id) &#123; User user = userMapper.selectById(id); return user; &#125;&#125; 11.单元测试这里使用的是上面设置的DB_MASTER1数据源，所以更加properties的配置会访问test01数据库 只需要更改 @TargetDataSource(dataSourceKey = DataSourceKey.DB_MASTER1)的DataSourceKey.DB_MASTER1就可以实现动态切换数据源！！ 123456789public class UserServiceTest extends DemoApplicationTests &#123; @Autowired private UserService userService; @Test public void fun1()&#123; User user = userService.selectById(1); System.out.println(user); &#125;&#125; 12.总结一下整个访问过程： 1.执行单元测试，执行service的selectById方法。 2.selectById方法被@TargetDataSource注解，DynamicDataSourceAspect的设置，被aop处理，方法执行前 下面的代码会判断根据@TargetDataSource注解中的值判断，并把注解中的值放入线程中。 1234567891011121314151617DataSourceKey dataSourceKey = targetDataSource.dataSourceKey(); if (dataSourceKey == DataSourceKey.DB_MASTER2) &#123; log.info(String.format("设置数据源为 %s", DataSourceKey.DB_MASTER2)); DynamicDataSourceContextHolder.setDataSource(DataSourceKey.DB_MASTER2); &#125; else if(dataSourceKey == DataSourceKey.DB_MASTER3)&#123; log.info(String.format("设置数据源为 %s", DataSourceKey.DB_MASTER3)); DynamicDataSourceContextHolder.setDataSource(DataSourceKey.DB_MASTER3); &#125; else if(dataSourceKey == DataSourceKey.DB_MASTER4)&#123; log.info(String.format("设置数据源为 %s", DataSourceKey.DB_MASTER4)); DynamicDataSourceContextHolder.setDataSource(DataSourceKey.DB_MASTER4); &#125; else &#123; log.info(String.format("使用默认数据源 %s", DataSourceKey.DB_MASTER1)); DynamicDataSourceContextHolder.setDataSource(DataSourceKey.DB_MASTER1); &#125; 3.方法执行时由于使用的DataSource其实是自定义的DynamicDataSource()。 12345@Override protected Object determineCurrentLookupKey() &#123; log.info("当前数据源："+ DynamicDataSourceContextHolder.getDataSource()); return DynamicDataSourceContextHolder.getDataSource(); &#125; determineCurrentLookupKey()方法回去线程中拿到前一步存入的@TargetDataSource注解中的值作为key去targetDataSources找对应的value。 4.根据key找到value后就找到了对应的数据源，每个数据源根据@ConfigurationProperties(prefix = “master2.datasource”)对应不同的配置，在application.properties对应了不同的数据库。 123456789101112131415161718192021222324252627282930313233343536373839404142@Bean @ConfigurationProperties(prefix = "master1.datasource") public DataSource dbMaster1() &#123; return DruidDataSourceBuilder.create().build(); &#125; @Bean @ConfigurationProperties(prefix = "master2.datasource") public DataSource dbMaster2() &#123; return DruidDataSourceBuilder.create().build(); &#125; @Bean @ConfigurationProperties(prefix = "master3.datasource") public DataSource dbMaster3() &#123; return DruidDataSourceBuilder.create().build(); &#125; @Bean @ConfigurationProperties(prefix = "master4.datasource") public DataSource dbMaster4() &#123; return DruidDataSourceBuilder.create().build(); &#125; /** * 核心动态数据源 * * @return 数据源实例 */ @Bean public DataSource dynamicDataSource() &#123; DynamicDataSource dataSource = new DynamicDataSource(); //默认数据源 dataSource.setDefaultTargetDataSource(dbMaster1()); Map&lt;Object, Object&gt; dataSourceMap = new HashMap&lt;&gt;(4); dataSourceMap.put(DataSourceKey.DB_MASTER1, dbMaster1()); dataSourceMap.put(DataSourceKey.DB_MASTER2, dbMaster2()); dataSourceMap.put(DataSourceKey.DB_MASTER3, dbMaster3()); dataSourceMap.put(DataSourceKey.DB_MASTER4, dbMaster4()); dataSource.setTargetDataSources(dataSourceMap); return dataSource; &#125; 5.selectById运行，此时数据库已经根据@TargetDataSource注解动态切换好了。 6.@After处理，把@TargetDataSource注解中的值从绑定的线程中移除。 1DynamicDataSourceContextHolder.clearDataSource(); END!]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MavenProfile区分生产-线上-测试环境]]></title>
    <url>%2F2018%2F10%2F27%2FMavenProfile%E5%8C%BA%E5%88%86%E7%94%9F%E4%BA%A7-%E7%BA%BF%E4%B8%8A-%E6%B5%8B%E8%AF%95%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[dev：开发环境pro：线上环境test：测试环境1.tomcat端口的区分引入依赖使用profile标签区分端口如下 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt; &lt;port&gt;9105&lt;/port&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;port&gt;9105&lt;/port&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;pro&lt;/id&gt; &lt;properties&gt; &lt;port&gt;9205&lt;/port&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;!-- 指定端口 --&gt; &lt;port&gt;$&#123;port&#125;&lt;/port&gt; &lt;!-- 请求路径 --&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 如果我们只执行命令tomcat7:run ,也是以9105启动，因为我们一开始定义的变量值就是9105，就是在不指定profileID时的默认值. 执行命令 tomcat7:run -Ppro 发现以9205端口启动 执行命令 tomcat7:run -Pdev 发现以9105端口启动 -P 后边跟的是profile的id 2.切换数据库连接配置修改pom.xml增加json数据库等依赖1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!-- Mybatis --&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.2.8&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.miemiedev&lt;/groupId&gt; &lt;artifactId&gt;mybatis-paginator&lt;/artifactId&gt; &lt;version&gt;1.2.15&lt;/version&gt;&lt;/dependency&gt;&lt;!-- MySql --&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.32&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 连接池 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.0.9&lt;/version&gt;&lt;/dependency&gt;&lt;!-- json数据 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt;&lt;/dependency&gt; 创建filter文件夹，放入数据库开发环境和生产环境配置了不同的数据库，dao的xml读取的是db.properties。 db.properties1234jdbc.driver=$&#123;env.jdbc.driver&#125;jdbc.url=$&#123;env.jdbc.url&#125;jdbc.username=$&#123;env.jdbc.username&#125;jdbc.password=$&#123;env.jdbc.password&#125; db_dev.properties1234env.jdbc.driver=com.mysql.jdbc.Driverenv.jdbc.url=jdbc:mysql://localhost:3306/maven_profile_test01?characterEncoding=utf-8env.jdbc.username=rootenv.jdbc.password=123 db_pro.properties1234env.jdbc.driver=com.mysql.jdbc.Driverenv.jdbc.url=jdbc:mysql://localhost:3306/maven_profile_test02?characterEncoding=utf-8env.jdbc.username=rootenv.jdbc.password=123 applicationContext-dao.xml1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 配置数据库properties位置 --&gt; &lt;!--这个配置会报错，注释掉了用下面的--&gt; &lt;!--&lt;context:property-placeholder location="classpath:dbconfig.properties"&gt;&lt;/context:property-placeholder&gt;--&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:filter/db.properties&lt;/value&gt; &lt;!--db.properties 数据库连接信息--&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean class="com.alibaba.druid.pool.DruidDataSource" id="dataSource"&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt; &lt;property name="driverClassName" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 如果Mapper.xml与Mapper.class在同一个包下且同名，spring扫描Mapper.class的同时会自动扫描同名的Mapper.xml并装配到Mapper.class。 如果Mapper.xml与Mapper.class不在同一个包下或者不同名，就必须使用配置mapperLocations指定mapper.xml的位置。--&gt; &lt;!--此时spring是通过识别mapper.xml中的 namespace的值来确定对应的Mapper.class的--&gt; &lt;!-- 配置SqlSessionFactory对象 --&gt; &lt;!--使用mybatis-plus的SqlSession--&gt; &lt;bean class="org.mybatis.spring.SqlSessionFactoryBean" id="sqlSessionFactory"&gt; &lt;!-- 自动扫描mybatis配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="mapper"/&gt; &lt;/bean&gt;&lt;/beans&gt; mybatis-config.xml12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--用于配合log4j在控制台打印sql语句--&gt; &lt;settings&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING" /&gt; &lt;/settings&gt;&lt;/configuration&gt; spring-mvc.xml12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="controller"&gt;&lt;/context:component-scan&gt; &lt;!-- 开启SpringMVC注解模式 --&gt; &lt;mvc:annotation-driven/&gt; &lt;!-- 解除servlet对静态资源文件访问的限制 --&gt; &lt;mvc:default-servlet-handler/&gt;&lt;/beans&gt; web.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;!-- 解决post乱码 --&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置SpringMVC --&gt; &lt;servlet&gt; &lt;servlet-name&gt;MavenProject&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置springmvc什么时候启动，参数必须为整数 --&gt; &lt;!-- 如果为0或者大于0，则springMVC随着容器启动而启动 --&gt; &lt;!-- 如果小于0，则在第一次请求进来的时候启动 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;MavenProject&lt;/servlet-name&gt; &lt;!-- 所有的请求都进入springMVC --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--加载spring-security.xml,spring-activemq.xml--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext-dao.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt;&lt;/web-app&gt; 修改pom.xml主要的实现在pom.xml 1234567891011121314151617181920212223242526&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt; &lt;-- 默认是9105端口，env=dev环境为开发环境的 --&gt; &lt;port&gt;9105&lt;/port&gt; &lt;env&gt;dev&lt;/env&gt; &lt;/properties&gt;&lt;--。。。。。。。。。。。。。。--&gt;&lt;profiles&gt; &lt;profile&gt; &lt;id&gt;dev&lt;/id&gt; &lt;properties&gt; &lt;port&gt;9105&lt;/port&gt; &lt;env&gt;dev&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;profile&gt; &lt;id&gt;pro&lt;/id&gt; &lt;properties&gt; &lt;port&gt;9205&lt;/port&gt; &lt;env&gt;pro&lt;/env&gt; &lt;/properties&gt; &lt;/profile&gt;&lt;/profiles&gt; 在build标签内增加filter12345678910111213141516171819202122232425&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;!-- 指定端口 --&gt; &lt;port&gt;$&#123;port&#125;&lt;/port&gt; &lt;!-- 请求路径 --&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;filters&gt; &lt;filter&gt;src/main/resources/filter/db_$&#123;env&#125;.properties&lt;/filter&gt; &lt;/filters&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; UserController123456789101112@RestController@RequestMapping("/user")public class UserController &#123; @Autowired private UserMapper userMapper; @RequestMapping("/findUser") public User findUser(Integer uid)&#123; User user = userMapper.findUser(uid); return user; &#125;&#125; UserMapper实体类省略 1234public interface UserMapper &#123; @Select("select * from maven_profile_user where uid = #&#123;id&#125;") User findUser(Integer id);&#125; 测试当我们执行命令tomcat7:run -P pro 开启的是9205端口，访问网址http://localhost:9205/user/findUser.do?uid=1 访问的数据库为maven_profile_test02 当我们执行tomcat7:run -P dev 开启的端口是9105，访问网址http://localhost:9105/user/findUser.do?uid=1 访问的数据库为maven_profile_test01]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PageHelper]]></title>
    <url>%2F2018%2F10%2F27%2FPageHelper%2F</url>
    <content type="text"><![CDATA[引入依赖12345&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt; 在 MyBatis 配置 xml 中配置拦截器插件1234567891011121314151617181920212223&lt;!--使用mybatis-plus的SqlSession--&gt; &lt;bean class="org.mybatis.spring.SqlSessionFactoryBean" id="sqlSessionFactory"&gt; &lt;!-- 自动扫描mybatis配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml"&gt;&lt;/property&gt; &lt;!-- 传入PageHelper的插件 --&gt; &lt;property name="plugins"&gt; &lt;array&gt; &lt;!-- 传入插件的对象 --&gt; &lt;bean class="com.github.pagehelper.PageInterceptor"&gt; &lt;property name="properties"&gt; &lt;props&gt; &lt;prop key="helperDialect"&gt;mysql&lt;/prop&gt; &lt;prop key="reasonable"&gt;true&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 使用PageInfo分页在你需要进行分页的 MyBatis 查询方法前调用 PageHelper.startPage 静态方法即可，紧跟在这个方法后的第一个MyBatis 查询方法会被进行分页。 12345678910111213141516171819//获取第1页，10条内容，默认查询总数countPageHelper.startPage(1, 10);List&lt;Country&gt; list = countryMapper.selectAll();//用PageInfo对结果进行包装PageInfo page = new PageInfo(list);//测试PageInfo全部属性//PageInfo包含了非常全面的分页属性assertEquals(1, page.getPageNum());assertEquals(10, page.getPageSize());assertEquals(1, page.getStartRow());assertEquals(10, page.getEndRow());assertEquals(183, page.getTotal());assertEquals(19, page.getPages());assertEquals(1, page.getFirstPage());assertEquals(8, page.getLastPage());assertEquals(true, page.isFirstPage());assertEquals(false, page.isLastPage());assertEquals(false, page.isHasPreviousPage());assertEquals(true, page.isHasNextPage()); 不使用PageInfo分页时PageResult是自己封装的类 selectByExample返回的是list，为什么可以强转为Page？下面是官方的解释： 分页时，实际返回的结果list类型是Page&lt;E&gt;，如果想取出分页信息，需要强制转换为Page&lt;E&gt; 所以如果要使用自己的PageBean的话可以PageHelper.startPage(pageNum, pageSize); 后面mybatis查询方法返回的list强转为Page类，从Page对象中获取你想要的信息，在封装到自己的PageBean中 1234567@Overridepublic PageResult findPage(int pageNum, int pageSize) &#123; PageHelper.startPage(pageNum, pageSize); //分页时，实际返回的结果list类型是Page&lt;E&gt;，如果想取出分页信息，需要强制转换为Page&lt;E&gt; Page&lt;TbBrand&gt; page= (Page&lt;TbBrand&gt;) brandMapper.selectByExample(null); return new PageResult(page.getTotal(), page.getResult());&#125; 1List&lt;TbBrand&gt; selectByExample(TbBrandExample example);]]></content>
      <categories>
        <category>pageHelper</category>
      </categories>
      <tags>
        <tag>pageHelper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生Quartz]]></title>
    <url>%2F2018%2F10%2F26%2F%E5%8E%9F%E7%94%9FQuartz%2F</url>
    <content type="text"><![CDATA[文章引用自https://www.cnblogs.com/drift-ice/p/3817269.html，写的非常可以说是好了。 几个基本概念：Job、Trigger、Cron expression、JobStores、Scheduler Scheduler调度器。所有的调度都是由它控制。 Job对于任务内容的构建，我们需要创建 Job 的继承类，并实现 execute 方法。 JobDetail定义的是任务数据，而真正的执行逻辑是在Job中 为什么设计成JobDetail + Job，不直接使用Job？这是因为任务是有可能并发执行，如果Scheduler直接使用Job，就会存在对同一个Job实例并发访问的问题。而JobDetail &amp; Job 方式，sheduler每次执行，都会根据JobDetail创建一个新的Job实例，这样就可以规避并发访问的问题。 Trigger其作用是设置调度策略。Quartz 设计了多种类型的 Trigger，其中最常用的是 SimpleTrigger 和 CronTrigger。SimpleTrigger 适用于在某一特定的时间以某一特定时间间隔执行多次。 CronTrigger 的用途更广，主要适用于基于日历的调度安排。例如：每星期二的 16:38:10 执行，每月一号执行，等等。 Cron表达式1234567SecondsMinutesHoursDay-of-MonthMonthDay-of-WeekYear (Optional field) Cron表达式是一个字符串，字符串以5或6个空格隔开，分为6或7个域，每一个域代表一个含义，Cron有如下两种语法格式： （1） Seconds Minutes Hours DayofMonth Month DayofWeek Year （2）Seconds Minutes Hours DayofMonth Month DayofWeek 一、结构 corn从左到右（用空格隔开）：秒 分 小时 月份中的日期 月份 星期中的日期 年份 二、各字段的含义 字段 允许值 允许的特殊字符 秒（Seconds） 0~59的整数 , - * / 四个字符 分（Minutes） 0~59的整数 , - * / 四个字符 小时（Hours） 0~23的整数 , - * / 四个字符 日期（DayofMonth） 1~31的整数（但是你需要考虑你月的天数） ,- * ? / L W C 八个字符 月份（Month） 1~12的整数或者 JAN-DEC , - * / 四个字符 星期（DayofWeek） 1~7的整数或者 SUN-SAT （1=SUN） , - * ? / L C # 八个字符 年(可选，留空)（Year） 1970~2099 , - * / 四个字符 星号(*)：可用在所有字段中，表示对应时间域的每一个时刻，例如，* 在分钟字段时，表示“每分钟”； 问号（?）：该字符只在日期和星期字段中使用，它通常指定为“无意义的值”，相当于点位符； 减号(-)：表达一个范围，如在小时字段中使用“10-12”，则表示从10到12点，即10,11,12； 逗号(,)：表达一个列表值，如在星期字段中使用“MON,WED,FRI”，则表示星期一，星期三和星期五； 斜杠(/)：x/y表达一个等步长序列，x为起始值，y为增量步长值。如在分钟字段中使用0/15，则表示为0,15,30和45秒，而5/15在分钟字段中表示5,20,35,50，你也可以使用*/y，它等同于0/y； L：该字符只在日期和星期字段中使用，代表“Last”的意思，但它在两个字段中意思不同。L在日期字段中，表示这个月份的最后一天，如一月的31号，非闰年二月的28号；如果L用在星期中，则表示星期六，等同于7。但是，如果L出现在星期字段里，而且在前面有一个数值X，则表示“这个月的最后X天”，例如，6L表示该月的最后星期五； W：该字符只能出现在日期字段里，是对前导日期的修饰，表示离该日期最近的工作日。例如15W表示离该月15号最近的工作日，如果该月15号是星期六，则匹配14号星期五；如果15日是星期日，则匹配16号星期一；如果15号是星期二，那结果就是15号星期二。但必须注意关联的匹配日期不能够跨月，如你指定1W，如果1号是星期六，结果匹配的是3号星期一，而非上个月最后的那天。W字符串只能指定单一日期，而不能指定日期范围； LW组合：在日期字段可以组合使用LW，它的意思是当月的最后一个工作日； 井号(#)：该字符只能在星期字段中使用，表示当月某个工作日。如6#3表示当月的第三个星期五(6表示星期五，#3表示当前的第三个)，而4#5表示当月的第五个星期三，假设当月没有第五个星期三，忽略不触发； C：该字符只在日期和星期字段中使用，代表“Calendar”的意思。它的意思是计划所关联的日期，如果日期没有被关联，则相当于日历中所有日期。例如5C在日期字段中就相当于日历5日以后的第一天。1C在星期字段中相当于星期日后的第一天。 Cron表达式对特殊字符的大小写不敏感，对代表星期的缩写英文大小写也不敏感。 三、常用表达式例子 ​ （1）0 0 2 1 * ? * 表示在每月的1日的凌晨2点调整任务 （2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业 （3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作 （4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 （5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 （6）0 0 12 ? * WED 表示每个星期三中午12点 （7）0 0 12 * * ? 每天中午12点触发 （8）0 15 10 ? * * 每天上午10:15触发 （9）0 15 10 * * ? 每天上午10:15触发 （10）0 15 10 * ? 每天上午10:15触发 （11）0 15 10 * * ? 2005 2005年的每天上午10:15触发 （12）0 * 14 ? 在每天下午2点到下午2:59期间的每1分钟触发 （13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 （14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 （15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 （16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 （17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 （18）0 15 10 15 * ? 每月15日上午10:15触发 （19）0 15 10 L * ? 每月最后一日的上午10:15触发 （20）0 15 10 ? * 6L 每月的最后一个星期五上午10:15触发 （21）0 15 10 ? * 6L 2002-2005 2002年至2005年的每月的最后一个星期五上午10:15触发 （22）0 15 10 ? * 6#3 每月的第三个星期五上午10:15触发 JobStores负责对Quartz的持久化，即将任务调度的相关数据保存在数据库中。这样，在系统重启后，任务的调度状态依然存在系统中。当任务错过了触发时间时，还可以重新触发并执行（需要配置）。 原生Quartz1.创建工程，引入依赖123456&lt;!-- sheduler --&gt;&lt;dependency&gt; &lt;groupId&gt;org.quartz-scheduler&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;2.2.1&lt;/version&gt;&lt;/dependency&gt; 2.Job实现类123456789public class DemoJob implements Job &#123; public void execute(JobExecutionContext context) throws JobExecutionException &#123; JobDetail detail = context.getJobDetail(); String name = detail.getJobDataMap().getString("name"); System.out.println("hello " + name + " at " + new Date()); &#125;&#125; 3.QuartzTest12345678910111213141516171819202122232425262728293031323334public class QuartzTest &#123; public static void main(String[] args) &#123; //创建scheduler try &#123; Scheduler scheduler = StdSchedulerFactory.getDefaultScheduler(); //定义一个Trigger Trigger trigger = newTrigger().withIdentity("trigger", "group") //定义name/group .startNow()//一旦加入scheduler，立即生效 .withSchedule(simpleSchedule() //使用SimpleTrigger .withIntervalInSeconds(1) //每隔一秒执行一次 .repeatForever()) //一直执行，奔腾到老不停歇 .build(); //定义一个JobDetail JobDetail job = newJob(DemoJob.class) //定义Job类为DemoJob类，这是真正的执行逻辑所在 .withIdentity("job", "group") //定义name/group .usingJobData("name", "quartz") //定义属性 .build(); //加入这个调度 scheduler.scheduleJob(job, trigger); //启动 scheduler.start(); //运行一段时间后关闭 Thread.sleep(10000); scheduler.shutdown(true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 关于name和groupJobDetail和Trigger都有name和group。 name是它们在这个sheduler里面的唯一标识。如果我们要更新一个JobDetail定义，只需要设置一个name相同的JobDetail实例即可。 group是一个组织单元，sheduler会提供一些对整组操作的API，比如 scheduler.resumeJobs()。 4.运行结果：hello quartz at Fri Oct 26 15:14:34 CST 2018hello quartz at Fri Oct 26 15:14:35 CST 2018hello quartz at Fri Oct 26 15:14:36 CST 2018hello quartz at Fri Oct 26 15:14:37 CST 2018hello quartz at Fri Oct 26 15:14:38 CST 2018hello quartz at Fri Oct 26 15:14:39 CST 2018hello quartz at Fri Oct 26 15:14:40 CST 2018。。。。。。省略 Trigger详解Trigger共性StartTime &amp; EndTime 指定的Trigger会被触发的时间区间。在这个区间之外，Trigger是不会被触发的。所有Trigger都会包含这两个属性 优先级（Priority） 当scheduler比较繁忙的时候，可能在同一个时刻，有多个Trigger被触发了，但资源不足（比如线程池不足）。那么这个时候比剪刀石头布更好的方式，就是设置优先级。优先级高的先执行。 优先级只有在同一时刻执行的Trigger之间才会起作用，如果一个Trigger是9:00，另一个Trigger是9:30。那么无论后一个优先级多高，前一个都是先执行。 优先级的值默认是5，当为负数时使用默认值。最大值似乎没有指定，但建议遵循Java的标准，使用1-10，不然鬼才知道看到【优先级为10】是时，上头还有没有更大的值。 Misfire(错失触发）策略 类似的Scheduler资源不足的时候，或者机器崩溃重启等，有可能某一些Trigger在应该触发的时间点没有被触发，也就是Miss Fire了。这个时候Trigger需要一个策略来处理这种情况。每种Trigger可选的策略各不相同。 两个点需要重点注意： 1.MisFire的触发是有一个阀值，这个阀值是配置在JobStore的。比如RAMJobStore是org.quartz.jobStore.misfireThreshold。只有超过这个阀值，才会算MisFire。小于这个阀值，Quartz是会全部重新触发。 2.所有MisFire的策略实际上都是解答两个问题： 已经MisFire的任务还要重新触发吗？ 如果发生MisFire，要调整现有的调度时间吗？ For example SimpleTrigger的MisFire策略有： MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY 这个不是忽略已经错失的触发的意思，而是说忽略MisFire策略。它会在资源合适的时候，重新触发所有的MisFire任务，并且不会影响现有的调度时间。 比如，SimpleTrigger每15秒执行一次，而中间有5分钟时间它都MisFire了，一共错失了20个，5分钟后，假设资源充足了，并且任务允许并发，它会被一次性触发。 这个属性是所有Trigger都适用。 MISFIRE_INSTRUCTION_FIRE_NOW 忽略已经MisFire的任务，并且立即执行调度。这通常只适用于只执行一次的任务。 MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_EXISTING_REPEAT_COUNT 将startTime设置当前时间，立即重新调度任务，包括的MisFire的 MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_REMAINING_REPEAT_COUNT 类似MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_EXISTING_REPEAT_COUNT，区别在于会忽略已经MisFire的任务 MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_EXISTING_COUNT 在下一次调度时间点，重新开始调度任务，包括的MisFire的 MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT 类似于MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_EXISTING_COUNT，区别在于会忽略已经MisFire的任务。 MISFIRE_INSTRUCTION_SMART_POLICY 所有的Trigger的MisFire默认值都是这个，大致意思是“把处理逻辑交给聪明的Quartz去决定”。基本策略是， 如果是只执行一次的调度，使用MISFIRE_INSTRUCTION_FIRE_NOW 如果是无限次的调度(repeatCount是无限的)，使用MISFIRE_INSTRUCTION_RESCHEDULE_NEXT_WITH_REMAINING_COUNT 否则，使用MISFIRE_INSTRUCTION_RESCHEDULE_NOW_WITH_EXISTING_REPEAT_COUNT Calendar 这里的Calendar不是jdk的java.util.Calendar，不是为了计算日期的。它的作用是在于补充Trigger的时间。可以排除或加入某一些特定的时间点。 Trigger实现类SimpleTrigger指定从某一个时间开始，以一定的时间间隔（单位是毫秒）执行的任务。 它适合的任务类似于：9:00 开始，每隔1小时，执行一次。 它的属性有： repeatInterval 重复间隔 repeatCount 重复次数。实际执行次数是 repeatCount+1。因为在startTime的时候一定会执行一次。 123456789simpleSchedule() .withIntervalInHours(1) //每小时执行一次 .repeatForever() //次数不限 .build();simpleSchedule() .withIntervalInMinutes(1) //每分钟执行一次 .withRepeatCount(10) //次数为10次 .build(); CalendarIntervalTrigger类似于SimpleTrigger，指定从某一个时间开始，以一定的时间间隔执行的任务。 但是不同的是SimpleTrigger指定的时间间隔为毫秒，没办法指定每隔一个月执行一次（每月的时间间隔不是固定值），而CalendarIntervalTrigger支持的间隔单位有秒，分钟，小时，天，月，年，星期。 相较于SimpleTrigger有两个优势：1、更方便，比如每隔1小时执行，你不用自己去计算1小时等于多少毫秒。 2、支持不是固定长度的间隔，比如间隔为月和年。但劣势是精度只能到秒。 它适合的任务类似于：9:00 开始执行，并且以后每周 9:00 执行一次 它的属性有: interval 执行间隔 intervalUnit 执行间隔的单位（秒，分钟，小时，天，月，年，星期） 1234567calendarIntervalSchedule() .withIntervalInDays(1) //每天执行一次 .build();calendarIntervalSchedule() .withIntervalInWeeks(1) //每周执行一次 .build(); DailyTimeIntervalTrigger指定每天的某个时间段内，以一定的时间间隔执行任务。并且它可以支持指定星期。 它适合的任务类似于：指定每天9:00 至 18:00 ，每隔70秒执行一次，并且只要周一至周五执行。 它的属性有: startTimeOfDay 每天开始时间 endTimeOfDay 每天结束时间 daysOfWeek 需要执行的星期 interval 执行间隔 intervalUnit 执行间隔的单位（秒，分钟，小时，天，月，年，星期） repeatCount 重复次数 1234567891011121314dailyTimeIntervalSchedule() .startingDailyAt(TimeOfDay.hourAndMinuteOfDay(9, 0)) //第天9：00开始 .endingDailyAt(TimeOfDay.hourAndMinuteOfDay(16, 0)) //16：00 结束 .onDaysOfTheWeek(MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY) //周一至周五执行 .withIntervalInHours(1) //每间隔1小时执行一次 .withRepeatCount(100) //最多重复100次（实际执行100+1次） .build();dailyTimeIntervalSchedule() .startingDailyAt(TimeOfDay.hourAndMinuteOfDay(9, 0)) //第天9：00开始 .endingDailyAfterCount(10) //每天执行10次，这个方法实际上根据 startTimeOfDay+interval*count 算出 endTimeOfDay .onDaysOfTheWeek(MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY) //周一至周五执行 .withIntervalInHours(1) //每间隔1小时执行一次 .build(); CronTrigger适合于更复杂的任务，它支持类型于Linux Cron的语法（并且更强大）。基本上它覆盖了以上三个Trigger的绝大部分能力（但不是全部）—— 当然，也更难理解。 它适合的任务类似于：每天0:00,9:00,18:00各执行一次。 它的属性只有: Cron表达式。但这个表示式本身就够复杂了。下面会有说明。 12345678cronSchedule("0 0/2 8-17 * * ?") // 每天8:00-17:00，每隔2分钟执行一次 .build();cronSchedule("0 30 9 ? * MON") // 每周一，9:30执行一次.build();weeklyOnDayAndHourAndMinute(MONDAY,9, 30) //等同于 0 30 9 ? * MON .build(); JobDetail &amp; JobJobDetail是任务的定义，而Job是任务的执行逻辑。在JobDetail里会引用一个Job Class定义。一个最简单的例子 123456789101112131415161718192021222324252627282930313233343536public class JobTest &#123; public static void main(String[] args) throws SchedulerException, IOException &#123; JobDetail job=newJob() .ofType(DoNothingJob.class) //引用Job Class .withIdentity("job1", "group1") //设置name/group .withDescription("this is a test job") //设置描述 .usingJobData("age", 18) //加入属性age到JobDataMap .build(); job.getJobDataMap().put("name", "quertz"); //加入属性name到JobDataMap //定义一个每秒执行一次的SimpleTrigger Trigger trigger=newTrigger() .startNow() .withIdentity("trigger1") .withSchedule(simpleSchedule() .withIntervalInSeconds(1) .repeatForever()) .build(); Scheduler sche=StdSchedulerFactory.getDefaultScheduler(); sche.scheduleJob(job, trigger); sche.start(); System.in.read(); sche.shutdown(); &#125;&#125;public class DoNothingJob implements Job &#123; public void execute(JobExecutionContext context) throws JobExecutionException &#123; System.out.println("do nothing"); &#125;&#125; 从上例我们可以看出，要定义一个任务，需要干几件事： 创建一个org.quartz.Job的实现类，并实现实现自己的业务逻辑。比如上面的DoNothingJob。 定义一个JobDetail，引用这个实现类 加入scheduleJob Quartz调度一次任务，会干如下的事： JobClass jobClass=JobDetail.getJobClass() Job jobInstance=jobClass.newInstance()。所以Job实现类，必须有一个public的无参构建方法。 jobInstance.execute(JobExecutionContext context)。JobExecutionContext是Job运行的上下文，可以获得Trigger、Scheduler、JobDetail的信息。 也就是说，每次调度都会创建一个新的Job实例，这样的好处是有些任务并发执行的时候，不存在对临界资源的访问问题——当然，如果需要共享JobDataMap的时候，还是存在临界资源的并发访问的问题。 JobDataMapJob都次都是newInstance的实例，那我怎么传值给它？ 实现的办法是通过JobDataMap。 们可以在定义JobDetail，加入属性值，方式有二： 123newJob().usingJobData("age", 18) //加入属性到ageJobDataMap orgetJobDataMap().put("name", "quertz"); //加入属性name到JobDataMap Job中可以获取这个JobDataMap的值，方式同样有二： 123456789101112131415public class DemoJob implements Job &#123; private String name; public void execute(JobExecutionContext context) throws JobExecutionException &#123; JobDetail detail = context.getJobDetail(); JobDataMap map = detail.getJobDataMap(); //方法一：获得JobDataMap System.out.println("say hello to " + name + "[" + map.getInt("age") + "]" + " at " + new Date()); &#125; //方法二：属性的setter方法，会将JobDataMap的属性自动注入 public void setName(String name) &#123; this.name = name; &#125;&#125; 对于同一个JobDetail实例，执行的多个Job实例，是共享同样的JobDataMap，也就是说，如果你在任务里修改了里面的值，会对其他Job实例（并发的或者后续的）造成影响。 除了JobDetail，Trigger同样有一个JobDataMap，共享范围是所有使用这个Trigger的Job实例。 Job并发有时候我们并不想任务并发执行，比如这个任务要去”获得数据库中所有未发送邮件的名单“，如果是并发执行，就需要一个数据库锁去避免一个数据被多次处理。这个时候一个@DisallowConcurrentExecution解决这个问题。 123456public class DoNothingJob implements Job &#123; @DisallowConcurrentExecution public void execute(JobExecutionContext context) throws JobExecutionException &#123; System.out.println("do nothing"); &#125;&#125; 注意，@DisallowConcurrentExecution是对JobDetail实例生效，也就是如果你定义两个JobDetail，引用同一个Job类，是可以并发执行的。 JobExecutionExceptionJob.execute()方法是不允许抛出除JobExecutionException之外的所有异常的（包括RuntimeException)，所以编码的时候，最好是try-catch住所有的Throwable，小心处理。 SchedulerScheduler就是Quartz的大脑，所有任务都是由它来设施。 Schduelr包含一个两个重要组件: JobStore和ThreadPool。 JobStore是会来存储运行时信息的，包括Trigger,Schduler,JobDetail，业务锁等。它有多种实现RAMJob(内存实现)，JobStoreTX(JDBC，事务由Quartz管理），JobStoreCMT(JDBC，使用容器事务)，ClusteredJobStore(集群实现)、TerracottaJobStore ThreadPool就是线程池，Quartz有自己的线程池实现。所有任务的都会由线程池执行。 SchedulerFactorySchdulerFactory，顾名思义就是来用创建Schduler了，有两个实现：DirectSchedulerFactory和StdSchdulerFactory。前者可以用来在代码里定制你自己的Schduler参数。后者是直接读取classpath下的quartz.properties（不存在就都使用默认值）配置来实例化Schduler。通常来讲，我们使用StdSchdulerFactory也就足够了。 StdSchdulerFactory的配置例子 123456org.quartz.scheduler.instanceName = DefaultQuartzSchedulerorg.quartz.threadPool.class = org.quartz.simpl.SimpleThreadPoolorg.quartz.threadPool.threadCount = 10 org.quartz.threadPool.threadPriority = 5org.quartz.threadPool.threadsInheritContextClassLoaderOfInitializingThread = trueorg.quartz.jobStore.class = org.quartz.simpl.RAMJobStore]]></content>
      <categories>
        <category>Quartz</category>
      </categories>
      <tags>
        <tag>Quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot整合多数据源]]></title>
    <url>%2F2018%2F10%2F25%2Fspringboot%E6%95%B4%E5%90%88%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90%2F</url>
    <content type="text"><![CDATA[springboot整合 多数据源方式1pom.xml1234567891011121314151617181920212223242526272829303132333435363738&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql 依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--druid--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; application.properties12345678910111213141516## master1 数据源配置master1.datasource.url=jdbc:mysql://localhost:3306/test01?useUnicode=true&amp;characterEncoding=utf8master1.datasource.username=rootmaster1.datasource.password=123master1.datasource.driverClassName=com.mysql.jdbc.Driver## master2 数据源配置master2.datasource.url=jdbc:mysql://localhost:3306/test02?useUnicode=true&amp;characterEncoding=utf8master2.datasource.username=rootmaster2.datasource.password=123master2.datasource.driverClassName=com.mysql.jdbc.Driver#日志配置logging.config=classpath:logback-spring.xml#控制台打印sql语句logging.level.springboot.datasource.demo.mapper=debug logback-spring.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration&gt; &lt;!-- %m输出的信息,%p日志级别,%t线程名,%d日期,%c类的全名,%i索引【从数字0开始递增】,,, --&gt; &lt;!-- appender是configuration的子节点，是负责写日志的组件。 --&gt; &lt;!-- ConsoleAppender：把日志输出到控制台 --&gt; &lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;%d %p (%file:%line\)- %m%n&lt;/pattern&gt; &lt;!-- 控制台也要使用UTF-8，不要使用GBK，否则会中文乱码 --&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- RollingFileAppender：滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt; &lt;!-- 以下的大概意思是：1.先按日期存日志，日期变了，将前一天的日志文件名重命名为XXX%日期%索引，新的日志仍然是logs.log --&gt; &lt;!-- 2.如果日期没有发生变化，但是当前日志的文件大小超过1KB时，对当前日志进行分割 重命名--&gt; &lt;appender name="applogs" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;!--日志输出目录--&gt; &lt;File&gt;D:/log/springboot_datasource_log.log&lt;/File&gt; &lt;!-- rollingPolicy:当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名。 --&gt; &lt;!-- TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动 --&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;!-- 活动文件的名字会根据fileNamePattern的值，每隔一段时间改变一次 --&gt; &lt;!-- 文件名：log/logs.2017-12-05.0.log --&gt; &lt;fileNamePattern&gt;log/logs.%d.%i.log&lt;/fileNamePattern&gt; &lt;!-- 每产生一个日志文件，该日志文件的保存期限为30天 --&gt; &lt;maxHistory&gt;30&lt;/maxHistory&gt; &lt;timeBasedFileNamingAndTriggeringPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP"&gt; &lt;!-- maxFileSize:这是活动文件的大小，默认值是10MB，测试时可改成1KB看效果 --&gt; &lt;maxFileSize&gt;1KB&lt;/maxFileSize&gt; &lt;/timeBasedFileNamingAndTriggeringPolicy&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;!-- pattern节点，用来设置日志的输入格式 --&gt; &lt;pattern&gt; %d %p (%file:%line\)- %m%n &lt;/pattern&gt; &lt;!-- 记录日志的编码:此处设置字符集 - --&gt; &lt;charset&gt;UTF-8&lt;/charset&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 控制台输出日志级别 --&gt; &lt;root level="info"&gt; &lt;appender-ref ref="STDOUT" /&gt; &lt;/root&gt; &lt;!-- 指定项目中某个包，当有日志操作行为时的日志记录级别 --&gt; &lt;!-- com.liyan为根包，也就是只要是发生在这个根包下面的所有日志操作行为的权限都是DEBUG --&gt; &lt;!-- 级别依次为【从高到低】：FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE --&gt; &lt;logger name="com.linan" level="DEBUG"&gt; &lt;appender-ref ref="applogs" /&gt; &lt;/logger&gt;&lt;/configuration&gt; 多数据源是以包区分的 Master1DataSourceConfig配置的mapper类在mapper/master1包下 Master1DataSourceConfig扫描的xml在resources/mapper/master1包下 Master2DataSourceConfig配置的mapper类在mapper/master2包下 Master2DataSourceConfig扫描的xml在resources/mapper/master2包下 Master1DataSourceConfig@SpringBootApplication会把@Configuration注解的类注册到容器中。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Configuration@MapperScan(basePackages = Master1DataSourceConfig.PACKAGE,sqlSessionFactoryRef = "master1SqlSessionFactory")public class Master1DataSourceConfig &#123; //扫描持久层 public static final String PACKAGE = "springboot.datasource.demo.mapper.master1"; //扫描mapper.xml public static final String MAPPER_LOCATION = "classpath:mapper/master1/*.xml"; @Value("$&#123;master1.datasource.url&#125;") private String url; @Value("$&#123;master1.datasource.username&#125;") private String user; @Value("$&#123;master1.datasource.password&#125;") private String password; @Value("$&#123;master1.datasource.driverClassName&#125;") private String driverClass; @Bean(name = "master1DataSource") @Primary public DataSource masterDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driverClass); dataSource.setUrl(url); dataSource.setUsername(user); dataSource.setPassword(password); return dataSource; &#125; @Bean(name = "master1TransactionManager") @Primary public DataSourceTransactionManager masterTransactionManager(@Qualifier("master1DataSource") DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; @Bean(name = "master1SqlSessionFactory") @Primary public SqlSessionFactory masterSqlSessionFactory(@Qualifier("master1DataSource") DataSource dataSource) throws Exception &#123; final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource); sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(Master1DataSourceConfig.MAPPER_LOCATION)); return sessionFactory.getObject(); &#125;&#125; Master2DataSourceConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445@Configuration@MapperScan(basePackages = Master2DataSourceConfig.PACKAGE,sqlSessionFactoryRef = "master2SqlSessionFactory")public class Master2DataSourceConfig &#123; //扫描持久层 public static final String PACKAGE = "springboot.datasource.demo.mapper.master2"; //扫描mapper.xml public static final String MAPPER_LOCATION = "classpath:mapper/master2/*.xml"; @Value("$&#123;master2.datasource.url&#125;") private String url; @Value("$&#123;master2.datasource.username&#125;") private String user; @Value("$&#123;master2.datasource.password&#125;") private String password; @Value("$&#123;master2.datasource.driverClassName&#125;") private String driverClass; @Bean(name = "master2DataSource") public DataSource masterDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(driverClass); dataSource.setUrl(url); dataSource.setUsername(user); dataSource.setPassword(password); return dataSource; &#125; @Bean(name = "master2TransactionManager") public DataSourceTransactionManager masterTransactionManager(@Qualifier("master2DataSource") DataSource dataSource) &#123; return new DataSourceTransactionManager(dataSource); &#125; @Bean(name = "master2SqlSessionFactory") public SqlSessionFactory masterSqlSessionFactory(@Qualifier("master2DataSource") DataSource dataSource) throws Exception &#123; final SqlSessionFactoryBean sessionFactory = new SqlSessionFactoryBean(); sessionFactory.setDataSource(dataSource); sessionFactory.setMapperLocations(new PathMatchingResourcePatternResolver() .getResources(Master2DataSourceConfig.MAPPER_LOCATION)); return sessionFactory.getObject(); &#125;&#125; mapper类1234567public interface Test01UserMapper&#123; User selectById(int id);&#125;public interface Test02UserMapper &#123; User selectById(int id);&#125; mapper.xml12345678&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="springboot.datasource.demo.mapper.master1.Test01UserMapper"&gt; &lt;select id="selectById" parameterType="int" resultType="springboot.datasource.demo.entity.User"&gt; select * from test_user where uid = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 12345678&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="springboot.datasource.demo.mapper.master2.Test02UserMapper"&gt; &lt;select id="selectById" parameterType="int" resultType="springboot.datasource.demo.entity.User"&gt; select * from test_user where uid = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 单元测试1234567891011121314151617181920public class MapperTest extends DemoApplicationTests &#123; @Autowired private Test01UserMapper test01UserMapper; @Autowired private Test02UserMapper test02UserMapper; @Test public void fun1()&#123; User user = test01UserMapper.selectById(1); System.out.println(user); //User(uid=1, uname=南北, uage=10) &#125; @Test public void fun2()&#123; User user = test02UserMapper.selectById(1); System.out.println(user); //User(uid=1, uname=当心, uage=30) &#125;&#125; 这里想使用mybatis-plus失败了 即使继承了mybatis-plus通过@Configuration方式的Master1DataSourceConfig，Master2DataSourceConfig会去MAPPER_LOCATION下的mapper.xml找方法，而不会使用mybatis-plus预置的方法。解决方法还没想到。]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring整合cache]]></title>
    <url>%2F2018%2F10%2F25%2Fspring%E6%95%B4%E5%90%88cache%2F</url>
    <content type="text"><![CDATA[写在前面 在未开启事务的情况之下，每次查询，spring都会关闭旧的sqlSession而创建新的sqlSession,因此此时mybatis的一级缓存是没有作用的 在开启事务的情况之下，spring使用threadLocal获取当前资源绑定同一个sqlSession，因此此时mybatis一级缓存是有效的，测试时我们需要排除mybatis一级缓存的影响。 如果开启事务即使用@Transactional注解进行本次测试，如果连续进行查询，只会打印一次sql，即只访问一次数据库。因为有mybatis的一级缓存存在。 所以要关闭事务，不要使用@Transactional注解 cache入门网上很多cache的解释，看了诸多博客后总结如下： 首先spring提供了一个cache接口 提供了缓存操作的读取/写入/移除方法； 12345678910111213public interface Cache &#123; String getName(); //缓存的名字 Object getNativeCache(); //得到底层使用的缓存，如Ehcache ValueWrapper get(Object key); //根据key得到一个ValueWrapper，然后调用其get方法获取值 &lt;T&gt; T get(Object key, Class&lt;T&gt; type);//根据key，和value的类型直接获取value void put(Object key, Object value);//往缓存放数据 void evict(Object key);//从缓存中移除key对应的缓存 void clear(); //清空缓存 interface ValueWrapper &#123; //缓存值的Wrapper Object get(); //得到真实的value &#125; &#125; 并且提供了默认的实现类，整合redis作为缓存的时候其实就是自己通过redis去实现cache接口： ConcurrentMapCache：使用java.util.concurrent.ConcurrentHashMap实现的Cache； GuavaCache：对Guava com.google.common.cache.Cache进行的Wrapper，需要Google Guava 12.0或更高版本，@since spring 4； EhCacheCache：使用Ehcache实现 JCacheCache：对javax.cache.Cache进行的wrapper，@since spring 3.2；spring4将此类更新到JCache 0.11版本； 我们在应用时可能会用到不止一个cache实现类，由此引申出了CacheManager，用于缓存管理 123456package org.springframework.cache; import java.util.Collection; public interface CacheManager &#123; Cache getCache(String name); //根据Cache名字获取Cache Collection&lt;String&gt; getCacheNames(); //得到所有Cache的名字 &#125; CacheManager也是一个接口，也有默认提供的实现类 ConcurrentMapCacheManager/ConcurrentMapCacheFactoryBean：管理ConcurrentMapCache； GuavaCacheManager； EhCacheCacheManager/EhCacheManagerFactoryBean； JCacheCacheManager/JCacheManagerFactoryBean； 另外还提供了CompositeCacheManager用于组合CacheManager。 ssm整合使用cache（ConcurrentMapCache）ConcurrentMap实际上还是是使用JVM的内存来缓存对象的，那么肯定会造成大量的内存消耗。但是使用方便。 这里只介绍使用注解的方法 1.我这边直接创建了一个spring-cache.xml也可以直接并入其他配置文件内，如spring-mybatis.xml 123&lt;cache:annotation-driven /&gt; &lt;cache:annotation-driven cache-manager="cacheManager" /&gt; //省略了 cache-manager="cacheManager" 这个配置项缺省使用了一个名字叫 cacheManager 的缓存管理器，这个缓存管理器有一个 spring 的缺省实现，即 SimpleCacheManager。 123456789101112131415161718192021&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:cache="http://www.springframework.org/schema/cache" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd"&gt; &lt;!-- 开启缓存注解--&gt; &lt;cache:annotation-driven /&gt; &lt;!--配置cacheManager--&gt; &lt;bean id="cacheManager" class="org.springframework.cache.support.SimpleCacheManager"&gt; &lt;property name="caches"&gt; &lt;set&gt; &lt;!--配置cache实现--&gt; &lt;bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean"&gt; &lt;property name="name" value="studentCache"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 2.service方法@Cacheable的value属性代表缓存区的名字，要和上面xml配置的名字一致，否则会报错。 123456789101112@Servicepublic class StudentServiceImpl implements StudentService &#123; @Autowired private StudentDao studentDao; @Cacheable(value = "studentCache") public Student selectStudentByIdFromCache(Integer id)&#123; Student student = studentDao.selectStudentById(id); return student; &#125;&#125; 3.单元测试执行测试的时候发现控制台sql语句只打印了一次 当我们取消StudentServiceImpl 中的@Cacheable(value = “studentCache”) 再次运行测试方法发现sql语句打印了3次 证明缓存是配置成功的！ 123456789101112131415public class CacheTest extends SSMManageTest &#123; @Autowired private StudentService studentService; @Test public void fun1()&#123; studentService.selectStudentByIdFromCache(1); studentService.selectStudentByIdFromCache(1); studentService.selectStudentByIdFromCache(1); &#125;&#125; 4.注意点此次使用的是继承方式的单元测试 所以不要忘记在父类测试类中加载spring-cache.xml 12345678910@WebAppConfiguration//告诉junit spring的配置文件@ContextConfiguration(&#123; "classpath:spring-mybatis.xml", "classpath:spring-mvc.xml","classpath:spring-redis.xml","classpath:spring-cache.xml"&#125;)//配置spring和junit整合，这样junit在启动时就会加载spring容器@RunWith(SpringJUnit4ClassRunner.class)public class SSMManageTest &#123;&#125; 在使用Spring @Cacheable注解的时候，要注意，如果类A的方法f()被标注了@Cacheable注解，那么当类A的其他方法，例如：f2()，去直接调用f()的时候，@Cacheable是不起作用的，原因是@Cacheable是基于Spring AOP代理类，f2()属于内部方法，直接调用f()时，是不走代理的。 ssm整合使用encache上面整合cache使用的是ConcurrentMapCache，下面用encache来实现 1.引入依赖123456&lt;!-- 引入ehcache缓存 --&gt;&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;2.10.4&lt;/version&gt;&lt;/dependency&gt; 2.编写ehcache.xml123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd"&gt; &lt;!-- 磁盘缓存位置 --&gt; &lt;!--java.io.tmpdir是获取操作系统缓存的临时目录，不同操作系统的缓存临时目录不一样--&gt; &lt;!--Windows: java.io.tmpdir:[C:\Users\登录用户~1\AppData\Local\Temp\]--&gt; &lt;diskStore path="java.io.tmpdir"/&gt; &lt;!-- 默认缓存 --&gt; &lt;defaultCache maxEntriesLocalHeap="10000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" maxEntriesLocalDisk="10000000" diskExpiryThreadIntervalSeconds="120" memoryStoreEvictionPolicy="LRU"&gt; &lt;persistence strategy="localTempSwap"/&gt; &lt;/defaultCache&gt; &lt;cache name="studentCache" maxElementsInMemory="1000" eternal="false" timeToIdleSeconds="3" timeToLiveSeconds="3" maxEntriesLocalDisk="10000000" overflowToDisk="false" memoryStoreEvictionPolicy="LRU"/&gt;&lt;/ehcache&gt; 3.cache元素的属性：name：缓存名称 maxElementsInMemory：内存中最大缓存对象数 maxElementsOnDisk：硬盘中最大缓存对象数，若是0表示无穷大 eternal：true表示对象永不过期，此时会忽略timeToIdleSeconds和timeToLiveSeconds属性，默认为false overflowToDisk：true表示当内存缓存的对象数目达到了 maxElementsInMemory界限后，会把溢出的对象写到硬盘缓存中。注意：如果缓存的对象要写入到硬盘中的话，则该对象必须实现了Serializable接口才行。 diskSpoolBufferSizeMB：磁盘缓存区大小，默认为30MB。每个Cache都应该有自己的一个缓存区。 diskPersistent：是否缓存虚拟机重启期数据，是否持久化磁盘缓存,当这个属性的值为true时,系统在初始化时会在磁盘中查找文件名 为cache名称,后缀名为index的文件，这个文件中存放了已经持久化在磁盘中的cache的index,找到后会把cache加载到内存，要想把 cache真正持久化到磁盘,写程序时注意执行net.sf.ehcache.Cache.put(Element element)后要调用flush()方法。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认为120秒 timeToIdleSeconds： 设定允许对象处于空闲状态的最长时间，以秒为单位。当对象自从最近一次被访问后，如果处于空闲状态的时间超过了timeToIdleSeconds属性 值，这个对象就会过期，EHCache将把它从缓存中清空。只有当eternal属性为false，该属性才有效。如果该属性值为0，则表示对象可以无限 期地处于空闲状态 timeToLiveSeconds：设定对象允许存在于缓存中的最长时间，以秒为单位。当对象自从被存放到缓存中后，如果处于缓存中的时间超过了 timeToLiveSeconds属性值，这个对象就会过期，EHCache将把它从缓存中清除。只有当eternal属性为false，该属性才有 效。如果该属性值为0，则表示对象可以无限期地存在于缓存中。timeToLiveSeconds必须大于timeToIdleSeconds属性，才有 意义 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 4.修改spring-cache.xml把SimpleCacheManager注解掉。 1234567891011121314151617181920212223242526272829&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:cache="http://www.springframework.org/schema/cache" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd"&gt; &lt;!-- 开启缓存注解--&gt; &lt;cache:annotation-driven /&gt; &lt;!-- &lt;bean id="cacheManager" class="org.springframework.cache.support.SimpleCacheManager"&gt; &lt;property name="caches"&gt; &lt;set&gt; &lt;bean class="org.springframework.cache.concurrent.ConcurrentMapCacheFactoryBean"&gt; &lt;property name="name" value="studentCache"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt;--&gt; &lt;bean id="cacheManager" class="org.springframework.cache.ehcache.EhCacheCacheManager"&gt; &lt;property name="cacheManager" ref="ehcache"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="ehcache" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean"&gt; &lt;!--引入ehcache.xml--&gt; &lt;property name="configLocation" value="classpath:ehcache.xml"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 5.service实现类这里的@Cacheable的value 值使用的是ehcache.xml配置的name属性。 123456789101112@Servicepublic class StudentServiceImpl implements StudentService &#123; @Autowired private StudentDao studentDao; @Cacheable(value = "studentCache") public Student selectStudentByIdFromCache(Integer id)&#123; Student student = studentDao.selectStudentById(id); return student; &#125;&#125; 6.单元测试1234567891011121314public class CacheTest extends SSMManageTest &#123; @Autowired private StudentService studentService; @Test public void fun1()&#123; studentService.selectStudentByIdFromCache(1); studentService.selectStudentByIdFromCache(1); studentService.selectStudentByIdFromCache(1); &#125;&#125; 运行单元测试控制台打印一次sql，只访问了一次数据库 当去掉@Cacheable(value = “studentCache”)时则访问了三次数据库 。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注册短信业务逻辑代码]]></title>
    <url>%2F2018%2F10%2F24%2F%E6%B3%A8%E5%86%8C%E7%9F%AD%E4%BF%A1%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[总体思路点击页面上的”获取短信验证码”链接，向后端传递手机号。后端随机生成6位数字作为短信验证码，将其保存在redis中（手机号作为KEY）。同时发送参数（手机号，验证码，短信模板号，签名）给消息中间件（此处用的是ActiveMQ）。 短信微服务通过监听消息，获得 手机号，验证码，短信模板号，签名后，通过短信平台发送短信此处使用的是阿里大于。 用户注册时，后端根据手机号查询redis中的验证码与用户填写的验证码是否相同，如果不同则提示用户不能注册。 短信微服务使用的是springboot。 构建一个通用的短信发送服务（独立于品优购的单独工程），接收activeMQ的消息（MAP类型） 消息包括手机号（mobile）、短信模板号（template_code）、签名（sign_name）、参数字符串（param ） 2.入门小Demo工程搭建,引入依赖123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-dysmsapi&lt;/artifactId&gt; &lt;version&gt;1.0.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.aliyun&lt;/groupId&gt; &lt;artifactId&gt;aliyun-java-sdk-core&lt;/artifactId&gt; &lt;version&gt;3.2.5&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 创建配置文件application.properties12345server.port=9003#activaMQ服务器ip及activaMQ端口spring.activemq.broker-url=tcp://192.168.25.128:61616 accessKeyId=自己的accessKeyIdaccessKeySecret=自己的accessKeySecre 短信工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113@Componentpublic class SmsUtil &#123; //产品名称:云通信短信API产品,开发者无需替换 static final String product = "Dysmsapi"; //产品域名,开发者无需替换 static final String domain = "dysmsapi.aliyuncs.com"; // TODO 此处需要替换成开发者自己的AK(在阿里云访问控制台寻找) @Autowired private Environment env; public SendSmsResponse sendSms(String mobile, String template_code, String sign_name, String param) throws ClientException &#123; String accessKeyId=env.getProperty("accessKeyId"); String accessKeySecret=env.getProperty("accessKeySecret"); //可自助调整超时时间 System.setProperty("sun.net.client.defaultConnectTimeout", "10000"); System.setProperty("sun.net.client.defaultReadTimeout", "10000"); //初始化acsClient,暂不支持region化 IClientProfile profile = DefaultProfile.getProfile("cn-hangzhou", accessKeyId, accessKeySecret); DefaultProfile.addEndpoint("cn-hangzhou", "cn-hangzhou", product, domain); IAcsClient acsClient = new DefaultAcsClient(profile); //组装请求对象-具体描述见控制台-文档部分内容 SendSmsRequest request = new SendSmsRequest(); //必填:待发送手机号 request.setPhoneNumbers(mobile); //必填:短信签名-可在短信控制台中找到 request.setSignName(sign_name); //必填:短信模板-可在短信控制台中找到 request.setTemplateCode(template_code); //可选:模板中的变量替换JSON串,如模板内容为"亲爱的$&#123;name&#125;,您的验证码为$&#123;code&#125;"时,此处的值为 request.setTemplateParam(param); //选填-上行短信扩展码(无特殊需求用户请忽略此字段) //request.setSmsUpExtendCode("90997"); //可选:outId为提供给业务方扩展字段,最终在短信回执消息中将此值带回给调用者 request.setOutId("yourOutId"); //hint 此处可能会抛出异常，注意catch SendSmsResponse sendSmsResponse = acsClient.getAcsResponse(request); return sendSmsResponse; &#125; public QuerySendDetailsResponse querySendDetails(String mobile, String bizId) throws ClientException&#123; String accessKeyId=env.getProperty("accessKeyId"); String accessKeySecret=env.getProperty("accessKeySecret"); //可自助调整超时时间 System.setProperty("sun.net.client.defaultConnectTimeout", "10000"); System.setProperty("sun.net.client.defaultReadTimeout", "10000"); //初始化acsClient,暂不支持region化 IClientProfile profile = DefaultProfile.getProfile("cn-hangzhou", accessKeyId, accessKeySecret); DefaultProfile.addEndpoint("cn-hangzhou", "cn-hangzhou", product, domain); IAcsClient acsClient = new DefaultAcsClient(profile); //组装请求对象 QuerySendDetailsRequest request = new QuerySendDetailsRequest(); //必填-号码 request.setPhoneNumber(mobile); //可选-流水号 request.setBizId(bizId); //必填-发送日期 支持30天内记录查询，格式yyyyMMdd SimpleDateFormat ft = new SimpleDateFormat("yyyyMMdd"); request.setSendDate(ft.format(new Date())); //必填-页大小 request.setPageSize(10L); //必填-当前页码从1开始计数 request.setCurrentPage(1L); //hint 此处可能会抛出异常，注意catch QuerySendDetailsResponse querySendDetailsResponse = acsClient.getAcsResponse(request); return querySendDetailsResponse; &#125; /* public static void main(String[] args) throws ClientException, InterruptedException &#123; //发短信 SendSmsResponse response = sendSms(); System.out.println("短信接口返回的数据----------------"); System.out.println("Code=" + response.getCode()); System.out.println("Message=" + response.getMessage()); System.out.println("RequestId=" + response.getRequestId()); System.out.println("BizId=" + response.getBizId()); Thread.sleep(3000L); //查明细 if(response.getCode() != null &amp;&amp; response.getCode().equals("OK")) &#123; QuerySendDetailsResponse querySendDetailsResponse = querySendDetails(response.getBizId()); System.out.println("短信明细查询接口返回数据----------------"); System.out.println("Code=" + querySendDetailsResponse.getCode()); System.out.println("Message=" + querySendDetailsResponse.getMessage()); int i = 0; for(QuerySendDetailsResponse.SmsSendDetailDTO smsSendDetailDTO : querySendDetailsResponse.getSmsSendDetailDTOs()) &#123; System.out.println("SmsSendDetailDTO["+i+"]:"); System.out.println("Content=" + smsSendDetailDTO.getContent()); System.out.println("ErrCode=" + smsSendDetailDTO.getErrCode()); System.out.println("OutId=" + smsSendDetailDTO.getOutId()); System.out.println("PhoneNum=" + smsSendDetailDTO.getPhoneNum()); System.out.println("ReceiveDate=" + smsSendDetailDTO.getReceiveDate()); System.out.println("SendDate=" + smsSendDetailDTO.getSendDate()); System.out.println("SendStatus=" + smsSendDetailDTO.getSendStatus()); System.out.println("Template=" + smsSendDetailDTO.getTemplateCode()); &#125; System.out.println("TotalCount=" + querySendDetailsResponse.getTotalCount()); System.out.println("RequestId=" + querySendDetailsResponse.getRequestId()); &#125; &#125;*/&#125; 消息监听类12345678910111213141516171819202122@Componentpublic class SmsListener &#123; @Autowired private SmsUtil smsUtil; @JmsListener(destination="sms") public void sendSms(Map&lt;String,String&gt; map)&#123; try &#123; SendSmsResponse response = smsUtil.sendSms( map.get("mobile"), map.get("template_code"), map.get("sign_name"), map.get("param") ); System.out.println("Code=" + response.getCode()); System.out.println("Message=" + response.getMessage()); System.out.println("RequestId=" + response.getRequestId()); System.out.println("BizId=" + response.getBizId()); &#125; catch (ClientException e) &#123; e.printStackTrace(); &#125; &#125;&#125; user-interface模块依赖entity 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;con.demo&lt;/groupId&gt; &lt;artifactId&gt;entity&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; user-service模块引入依赖，父工程版本控制略，需要依赖dao，common，user-interface，dao略，common略。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103 &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- dubbo相关 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;dubbo&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt; &lt;artifactId&gt;zookeeper&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.sgroschupf&lt;/groupId&gt; &lt;artifactId&gt;zkclient&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-codec&lt;/groupId&gt; &lt;artifactId&gt;commons-codec&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.demo&lt;/groupId&gt; &lt;artifactId&gt;dao&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.demo&lt;/groupId&gt; &lt;artifactId&gt;user-interface&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.demo&lt;/groupId&gt; &lt;artifactId&gt;common&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-client&lt;/artifactId&gt; &lt;version&gt;5.13.4&lt;/version&gt; &lt;/dependency&gt;添加tomcat插件，端口为9006 &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;!-- 指定端口 --&gt; &lt;port&gt;9006&lt;/port&gt; &lt;!-- 请求路径 --&gt; &lt;path&gt;/&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; 添加web.xml12345678&lt;!-- 加载spring容器 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:applicationContext*.xml&lt;/param-value&gt;&lt;/context-param&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt; 创建配置文件applicationContext-jms-producer.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jms="http://www.springframework.org/schema/jms" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.128:61616"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name="connectionFactory" ref="connectionFactory"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id="smsDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="sms"/&gt; &lt;/bean&gt; &lt;/beans&gt; applicationContext-service.xml 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:dubbo="http://code.alibabatech.com/schema/dubbo" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;dubbo:protocol name="dubbo" port="20886"&gt;&lt;/dubbo:protocol&gt; &lt;dubbo:application name="pinyougou-user-service"/&gt; &lt;dubbo:registry address="zookeeper://192.168.25.128:2181"/&gt; &lt;dubbo:annotation package="service.impl" /&gt;读取sms.properties支持@value注解的方式来获取 &lt;bean id="configProperties" class="org.springframework.beans.factory.config.PropertiesFactoryBean"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:sms.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; sms.properties 12template_code=your模板号sign_name=your签名 common模块中redis配置 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:cache="http://www.springframework.org/schema/cache" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd"&gt; &lt;context:property-placeholder location="classpath*:*.properties" /&gt; &lt;!-- redis 相关配置 --&gt; &lt;bean id="poolConfig" class="redis.clients.jedis.JedisPoolConfig"&gt; &lt;property name="maxIdle" value="300" /&gt; &lt;property name="maxWaitMillis" value="3000" /&gt; &lt;property name="testOnBorrow" value="true" /&gt; &lt;/bean&gt; &lt;bean id="JedisConnectionFactory" class="org.springframework.data.redis.connection.jedis.JedisConnectionFactory" p:host-name="127.0.0.1" p:port="6379" p:password="" p:pool-config-ref="poolConfig"/&gt; &lt;bean id="redisTemplate" class="org.springframework.data.redis.core.RedisTemplate"&gt; &lt;property name="connectionFactory" ref="JedisConnectionFactory" /&gt; &lt;/bean&gt; &lt;/beans&gt; 1234567891011121314# Redis settings # server IP redis.host=127.0.0.1 # server port redis.port=6379 # server pass redis.pass=redis.database=0 # \u63A7\u5236\u4E00\u4E2Apool\u6700\u591A\u6709\u591A\u5C11\u4E2A\u72B6\u6001\u4E3Aidle(\u7A7A\u95F2\u7684)\u7684jedis\u5B9E\u4F8B redis.maxIdle=300 # \u8868\u793A\u5F53borrow(\u5F15\u5165)\u4E00\u4E2Ajedis\u5B9E\u4F8B\u65F6\uFF0C\u6700\u5927\u7684\u7B49\u5F85\u65F6\u95F4\uFF0C\u5982\u679C\u8D85\u8FC7\u7B49\u5F85\u65F6\u95F4(\u6BEB\u79D2)\uFF0C\u5219\u76F4\u63A5\u629B\u51FAJedisConnectionException\uFF1B redis.maxWait=3000 # \u5728borrow\u4E00\u4E2Ajedis\u5B9E\u4F8B\u65F6\uFF0C\u662F\u5426\u63D0\u524D\u8FDB\u884Cvalidate\u64CD\u4F5C\uFF1B\u5982\u679C\u4E3Atrue\uFF0C\u5219\u5F97\u5230\u7684jedis\u5B9E\u4F8B\u5747\u662F\u53EF\u7528\u7684 redis.testOnBorrow=true UserServiceImpl.javaUserService接口代码略 保存注册用户方法12345678@Override public void add(TbUser user) &#123; user.setCreated(new Date());//创建日期 user.setUpdated(new Date());//修改日期 String password = DigestUtils.md5Hex(user.getPassword());//对密码加密 user.setPassword(password); userMapper.insert(user); &#125; 生成验证码方法12345678910111213141516171819202122232425262728293031323334353637383940@Autowired private RedisTemplate&lt;String , Object&gt; redisTemplate;@Autowired private Destination smsDestination; @Value("$&#123;template_code&#125;") private String template_code; @Value("$&#123;sign_name&#125;") private String sign_name;@Overridepublic void createSmsCode(final String phone) &#123; //1.生成一个6位随机数（验证码） final String smscode= (long)(Math.random()*1000000)+""; System.out.println("验证码："+smscode); //2.将验证码放入redis redisTemplate.boundHashOps("smscode").put(phone, smscode); //3.将短信内容发送给activeMQ jmsTemplate.send(smsDestination, new MessageCreator() &#123; @Override public Message createMessage(Session session) throws JMSException &#123; MapMessage message = session.createMapMessage(); message.setString("mobile", phone);//手机号 message.setString("template_code", template_code);//验证码 //此处应该使用sign_name，sign_name值从sms.properties读取，但是可能是因为中文的原因，导致 //报错：签名不合法。所以此处直接写死了，没有从sms.properties读取，发现短信发送成功。 message.setString("sign_name", "your签名");//签名 Map map=new HashMap(); //此处的code为与模板是对应的 //例如我的模板为：您正在申请手机注册，验证码为：$&#123;code&#125;，5分钟内有效！ //如果模板为$&#123;number&#125;则此处也应为number。 map.put("code", smscode); message.setString("param", JSON.toJSONString(map)); return message; &#125; &#125;); 用户注册判断验证码12345678910111213@Overridepublic boolean checkSmsCode(String phone, String code) &#123; String systemcode= (String) redisTemplate.boundHashOps("smscode").get(phone); if(systemcode==null)&#123; return false; &#125; if(!systemcode.equals(code))&#123; return false; &#125; return true;&#125; user-web代码发送验证码123456789101112131415@RequestMapping("/sendCode")public Result sendCode(String phone)&#123; if(!PhoneFormatCheckUtils.isPhoneLegal(phone))&#123; return new Result(false, "手机格式不正确"); &#125; try &#123; userService.createSmsCode(phone); return new Result(true, "验证码发送成功"); &#125; catch (Exception e) &#123; e.printStackTrace(); return new Result(false, "验证码发送失败"); &#125;&#125; 其中PhoneFormatCheckUtils工具类 123456789101112131415161718192021222324252627282930313233343536public class PhoneFormatCheckUtils &#123; /** * 大陆号码或香港号码均可 */ public static boolean isPhoneLegal(String str)throws PatternSyntaxException &#123; return isChinaPhoneLegal(str) || isHKPhoneLegal(str); &#125; /** * 大陆手机号码11位数，匹配格式：前三位固定格式+后8位任意数 * 此方法中前三位格式有： * 13+任意数 * 15+除4的任意数 * 18+除1和4的任意数 * 17+除9的任意数 * 147 */ public static boolean isChinaPhoneLegal(String str) throws PatternSyntaxException &#123; String regExp = "^((13[0-9])|(15[^4])|(18[0,2,3,5-9])|(17[0-8])|(147))\\d&#123;8&#125;$"; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches(); &#125; /** * 香港手机号码8位数，5|6|8|9开头+7位任意数 */ public static boolean isHKPhoneLegal(String str)throws PatternSyntaxException &#123; String regExp = "^(5|6|8|9)\\d&#123;7&#125;$"; Pattern p = Pattern.compile(regExp); Matcher m = p.matcher(str); return m.matches(); &#125; &#125; 保存注册用户1234567891011121314151617@RequestMapping("/add")public Result add(@RequestBody TbUser user,String smscode)&#123; //校验验证码是否正确 boolean checkSmsCode = userService.checkSmsCode(user.getPhone(), smscode); if(!checkSmsCode)&#123; return new Result(false, "验证码不正确！"); &#125; try &#123; userService.add(user); return new Result(true, "增加成功"); &#125; catch (Exception e) &#123; e.printStackTrace(); return new Result(false, "增加失败"); &#125;&#125; 流程总结 点击获得短信验证码 @RequestMapping(“/sendCode”)检验手机号是否合法后调用userService的createSmsCode方法，传递号码 createSmsCode方法生成6位验证码放入Redis，并发送号码，签名，模板，验证码等信息给消息中间件activeMQ 短信微服务监听到消息后，取出消息中参数，通过短信平台发送短信。 用户获得短信，输入验证码，提交表单 @RequestMapping(“/add”)，用户输入的验证码与redis中存的验证码对比校验，成功后保存用户注册信息。]]></content>
      <categories>
        <category>业务逻辑</category>
      </categories>
      <tags>
        <tag>业务逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring整合JMS]]></title>
    <url>%2F2018%2F10%2F14%2FSpring%E6%95%B4%E5%90%88JMS%2F</url>
    <content type="text"><![CDATA[点对点模式消息生产者1.创建工程springjms_producer，在POM文件中引入SpringJms 、activeMQ以及单元测试相关依赖 。 1234567891011121314151617181920&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-client&lt;/artifactId&gt; &lt;version&gt;5.13.4&lt;/version&gt; &lt;/dependency&gt; 2.在src/main/resources下创建spring配置文件applicationContext-jms-producer.xml 12345678910111213141516171819&lt;context:component-scan base-package="com.demo"&gt;&lt;/context:component-scan&gt; &lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.135:61616"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt; &lt;/bean&gt; &lt;!-- Spring提供的JMS工具类，它可以进行消息发送、接收等 --&gt; &lt;bean id="jmsTemplate" class="org.springframework.jms.core.JmsTemplate"&gt; &lt;!-- 这个connectionFactory对应的是我们定义的Spring提供的那个ConnectionFactory对象 --&gt; &lt;property name="connectionFactory" ref="connectionFactory"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id="queueTextDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="queue_text"/&gt; &lt;/bean&gt; 3.在com.demo包下创建消息生产者类 123456789101112131415161718192021@Componentpublic class QueueProducer &#123; @Autowired private JmsTemplate jmsTemplate; @Autowired private Destination queueTextDestination;//与xml中对应 /** * 发送文本消息 * @param text */ public void sendTextMessage(final String text)&#123; jmsTemplate.send(queueTextDestination, new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage(text); &#125; &#125;); &#125;&#125; 4.单元测试 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-jms-producer.xml")public class TestQueue &#123; @Autowired private QueueProducer queueProducer; @Test public void testSend()&#123; queueProducer.sendTextMessage("SpringJms-点对点"); &#125; &#125; 消息消费者1.创建工程springjms_consumer，在POM文件中引入依赖（同上一个工程） 2.创建配置文件 applicationContext-jms-consumer-queue.xml 123456789101112131415161718192021&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.135:61616"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id="queueTextDestination" class="org.apache.activemq.command.ActiveMQQueue"&gt; &lt;constructor-arg value="queue_text"/&gt; &lt;/bean&gt; &lt;!-- 我的监听类 --&gt;&lt;bean id="myMessageListener" class="com.demo.MyMessageListener"&gt;&lt;/bean&gt;&lt;!-- 消息监听容器 --&gt;&lt;bean class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="queueTextDestination" /&gt; &lt;property name="messageListener" ref="myMessageListener" /&gt;&lt;/bean&gt; 3.编写监听类 12345678910public class MyMessageListener implements MessageListener &#123; public void onMessage(Message message) &#123; TextMessage textMessage=(TextMessage)message; try &#123; System.out.println("接收到消息："+textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 4.创建测试类 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-jms-consumer-queue.xml")public class TestQueue &#123; @Test public void testQueue()&#123; try &#123; System.in.read(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 发布/订阅模式消息生产者1.在工程springjms_producer的applicationContext-jms-producer.xml增加配置 1234&lt;!--这个是订阅模式 文本信息--&gt; &lt;bean id="topicTextDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="topic_text"/&gt; &lt;/bean&gt; 2.创建生产者类 1234567891011121314151617181920@Componentpublic class TopicProducer &#123; @Autowired private JmsTemplate jmsTemplate; @Autowired private Destination topicTextDestination; /** * 发送文本消息 * @param text */ public void sendTextMessage(final String text)&#123; jmsTemplate.send(topicTextDestination, new MessageCreator() &#123; public Message createMessage(Session session) throws JMSException &#123; return session.createTextMessage(text); &#125; &#125;); &#125;&#125; 3.编写测试类 12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-activemq-producer.xml")public class TestTopic &#123; @Autowired private TopicProducer topicProducer; @Test public void sendTextQueue()&#123; topicProducer.sendTextMessage(); &#125; &#125; 消息消费者1.在activemq-spring-consumer工程中创建配置文件applicationContext-jms-consumer-topic.xml 123456789101112131415161718192021&lt;!-- 真正可以产生Connection的ConnectionFactory，由对应的 JMS服务厂商提供--&gt; &lt;bean id="targetConnectionFactory" class="org.apache.activemq.ActiveMQConnectionFactory"&gt; &lt;property name="brokerURL" value="tcp://192.168.25.135:61616"/&gt; &lt;/bean&gt; &lt;!-- Spring用于管理真正的ConnectionFactory的ConnectionFactory --&gt; &lt;bean id="connectionFactory" class="org.springframework.jms.connection.SingleConnectionFactory"&gt; &lt;!-- 目标ConnectionFactory对应真实的可以产生JMS Connection的ConnectionFactory --&gt; &lt;property name="targetConnectionFactory" ref="targetConnectionFactory"/&gt; &lt;/bean&gt; &lt;!--这个是队列目的地，点对点的 文本信息--&gt; &lt;bean id="topicTextDestination" class="org.apache.activemq.command.ActiveMQTopic"&gt; &lt;constructor-arg value="topic_text"/&gt; &lt;/bean&gt; &lt;!-- 我的监听类 --&gt;&lt;bean id="myMessageListener" class="com.demo.MyMessageListener"&gt;&lt;/bean&gt;&lt;!-- 消息监听容器 --&gt;&lt;bean class="org.springframework.jms.listener.DefaultMessageListenerContainer"&gt; &lt;property name="connectionFactory" ref="connectionFactory" /&gt; &lt;property name="destination" ref="topicTextDestination" /&gt; &lt;property name="messageListener" ref="myMessageListener" /&gt;&lt;/bean&gt; 2.编写测试类 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext-jms-consumer-topic.xml")public class TestTopic &#123; @Test public void testTopic()&#123; try &#123; System.in.read(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;]]></content>
      <categories>
        <category>activeMQ</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>activeMQ</tag>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ入门]]></title>
    <url>%2F2018%2F10%2F14%2FActiveMQ%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[1.ActiveMQ下载与安装需要把ActiveMQ安装到linux系统上。具体不赘述。 账号密码默认都为admin 列表各列信息含义如下： Number Of Pending Messages ：等待消费的消息 这个是当前未出队列的数量。 Number Of Consumers ：消费者 这个是消费者端的消费者数量 Messages Enqueued ：进入队列的消息 进入队列的总数量,包括出队列的。 Messages Dequeued ：出了队列的消息 可以理解为是消费这消费掉的数量。 2.入门小Demo点对点模式消息生产者12345&lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-client&lt;/artifactId&gt; &lt;version&gt;5.13.4&lt;/version&gt; &lt;/dependency&gt; 创建类QueueProducer main方法代码如下： 1234567891011121314151617181920//1.创建连接工厂 ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.25.135:61616");//ip为虚拟机中ip，61616是给java用的tcp端口 //2.获取连接 Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.获取session (参数1：是否启动事务,参数2：消息确认模式) Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建队列对象 Queue queue = session.createQueue("test-queue"); //6.创建消息生产者 MessageProducer producer = session.createProducer(queue); //7.创建消息 TextMessage textMessage = session.createTextMessage("ActiveMQ入门demo"); //8.发送消息 producer.send(textMessage); //9.关闭资源 producer.close(); session.close(); connection.close(); 上述代码中第4步创建session 的两个参数： 第1个参数是否使用事务 第2个参数消息的确认模式 AUTO_ACKNOWLEDGE = 1 自动确认 CLIENT_ACKNOWLEDGE = 2 客户端手动确认 DUPS_OK_ACKNOWLEDGE = 3 自动批量确认 SESSION_TRANSACTED = 0 事务提交并确认 运行后可以通过ActiveMQ管理界面查询 消息消费者创建类QueueConsumer ，main方法代码如下： 12345678910111213141516171819202122232425262728293031//1.创建连接工厂 ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.25.135:61616"); //2.获取连接 Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.获取session (参数1：是否启动事务,参数2：消息确认模式) Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建队列对象 Queue queue = session.createQueue("test-queue"); //6.创建消息消费 MessageConsumer consumer = session.createConsumer(queue); //7.监听消息 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage=(TextMessage)message; try &#123; System.out.println("接收到消息："+textMessage.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;); //8.等待键盘输入 System.in.read(); //9.关闭资源 consumer.close(); session.close(); connection.close(); 执行后看到控制台输出 /* 接收到消息：ActiveMQ入门demo */ 同时开启2个以上的消费者，再次运行生产者，观察每个消费者控制台的输出，会发现只有一个消费者会接收到消息。 发布/订阅模式消息生产者创建类TopicProducer ，main方法代码如下： 1234567891011121314151617181920//1.创建连接工厂 ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.25.135:61616"); //2.获取连接 Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.获取session (参数1：是否启动事务,参数2：消息确认模式) Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建主题对象 Topic topic = session.createTopic("test-topic"); //6.创建消息生产者 MessageProducer producer = session.createProducer(topic); //7.创建消息 TextMessage textMessage = session.createTextMessage("欢迎来到神奇的品优购世界"); //8.发送消息 producer.send(textMessage); //9.关闭资源 producer.close(); session.close(); connection.close(); 消息消费者创建类TopicConsumer ,main方法代码如下： 1234567891011121314151617181920212223242526272829303132//1.创建连接工厂 ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("tcp://192.168.25.135:61616"); //2.获取连接 Connection connection = connectionFactory.createConnection(); //3.启动连接 connection.start(); //4.获取session (参数1：是否启动事务,参数2：消息确认模式) Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //5.创建主题对象 //Queue queue = session.createQueue("test-queue"); Topic topic = session.createTopic("test-topic"); //6.创建消息消费 MessageConsumer consumer = session.createConsumer(topic); //7.监听消息 consumer.setMessageListener(new MessageListener() &#123; public void onMessage(Message message) &#123; TextMessage textMessage=(TextMessage)message; try &#123; System.out.println("接收到消息："+textMessage.getText()); &#125; catch (JMSException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; &#125;); //8.等待键盘输入 System.in.read(); //9.关闭资源 consumer.close(); session.close(); connection.close(); 同时开启2个以上的消费者，再次运行生产者，观察每个消费者控制台的输出，会发现每个消费者会接收到消息。]]></content>
      <categories>
        <category>activeMQ</category>
      </categories>
      <tags>
        <tag>activeMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页模板引擎Freemarker]]></title>
    <url>%2F2018%2F10%2F14%2F%E7%BD%91%E9%A1%B5%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8EFreemarker%2F</url>
    <content type="text"><![CDATA[网页静态化技术和缓存技术的共同点都是为了减轻数据库的访问压力，我们如果将网页以纯静态化的形式展现，就可以使用Nginx这样的高性能的web服务器来部署。 Freemarker入门小DEMO工程引入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.23&lt;/version&gt;&lt;/dependency&gt; 创建模板文件模板文件中四种元素 1、文本，直接输出的部分 2、注释，即&lt;#–…–&gt;格式不会输出 3、插值（Interpolation）：即${..}部分,将使用数据模型中的部分替代输出 4、FTL指令：FreeMarker指令，和HTML标记类似，名字前加#予以区分，不会输出。 我们现在就创建一个简单的创建模板文件test.ftl 12345678910&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;Freemarker入门小DEMO &lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;#--我只是一个注释，我不会有任何输出 --&gt;$&#123;name&#125;,你好。$&#123;message&#125;&lt;/body&gt;&lt;/html&gt; 生成文件第一步：创建一个 Configuration 对象，直接 new 一个对象。构造方法的参数就是 freemarker的版本号。 第二步：设置模板文件所在的路径。 第三步：设置模板文件使用的字符集。一般就是 utf-8. 第四步：加载一个模板，创建一个模板对象。 第五步：创建一个模板使用的数据集，可以是 pojo 也可以是 map。一般是 Map。 第六步：创建一个 Writer 对象，一般创建一FileWriter 对象，指定生成的文件名。 第七步：调用模板对象的 process 方法输出文件。 第八步：关闭流 123456789101112131415161718//1.创建配置类 Configuration configuration=new Configuration(Configuration.getVersion()); //2.设置模板所在的目录 configuration.setDirectoryForTemplateLoading(new File("D:/freemarkerDemo/src/main/resources/")); //3.设置字符集 configuration.setDefaultEncoding("utf-8"); //4.加载模板 Template template = configuration.getTemplate("test.ftl"); //5.创建数据模型 Map map=new HashMap(); map.put("name", "张三 "); map.put("message", "Freemarker入门小DEMO"); //6.创建Writer对象 Writer out =new FileWriter(new File("d:\\test.html")); //7.输出 template.process(map, out); //8.关闭Writer对象 out.close(); 执行后，在D盘根目录即可看到生成的test.html 。 FTL指令assign指令定义简单类型： 12&lt;#assign linkman="周先生"&gt;联系人：$&#123;linkman&#125; 定义对象类型： 12&lt;#assign info=&#123;"mobile":"13301231212",'address':'北京市昌平区王府街'&#125; &gt;电话：$&#123;info.mobile&#125; 地址：$&#123;info.address&#125; include指令可以在模板文件中使用include指令引入刚才我们建立的其他模板 1&lt;#include &quot;head.ftl&quot;&gt; if指令12345&lt;#if success=true&gt; 你已通过实名认证&lt;#else&gt; 你未通过实名认证&lt;/#if&gt; list指令代码中对变量goodsList赋值 1234567891011121314List goodsList=new ArrayList(); Map goods1=new HashMap(); goods1.put("name", "苹果"); goods1.put("price", 5.8); Map goods2=new HashMap(); goods2.put("name", "香蕉"); goods2.put("price", 2.5); Map goods3=new HashMap(); goods3.put("name", "橘子"); goods3.put("price", 3.2); goodsList.add(goods1); goodsList.add(goods2); goodsList.add(goods3); map.put("goodsList", goodsList); 在模板文件上使用list指令 123&lt;#list goodsList as goods&gt; $&#123;goods_index+1&#125; 商品名称： $&#123;goods.name&#125; 价格：$&#123;goods.price&#125;&lt;br&gt;&lt;/#list&gt; 如果想在循环中得到索引，使用循环变量+_index就可以得到。 内建函数内建函数语法格式： 变量+?+函数名称 获取集合大小我们使用size函数来实现 1$&#123;goodsList?size&#125; 转换JSON字符串为对象123 &lt;#assign text="&#123;'bank':'工商银行','account':'10101920201920212'&#125;" /&gt;&lt;#assign data=text?eval /&gt;开户行：$&#123;data.bank&#125; 账号：$&#123;data.account&#125; 日期格式化1234当前日期：$&#123;today?date&#125; &lt;br&gt;当前时间：$&#123;today?time&#125; &lt;br&gt; 当前日期+时间：$&#123;today?datetime&#125; &lt;br&gt; 日期格式化： $&#123;today?string("yyyy年MM月")&#125; 空值处理运算符如果你在模板中使用了变量但是在代码中没有对变量赋值，那么运行生成时会抛出异常。但是有些时候，有的变量确实是null，怎么解决这个问题呢？ 判断某变量是否存在:“??”用法为:variable??,如果该变量存在,返回true,否则返回false 12345&lt;#if aaa??&gt; aaa变量存在&lt;#else&gt; aaa变量不存在&lt;/#if&gt; 缺失变量默认值:“!”我们除了可以判断是否为空值，也可以使用!对null值做转换处理 1$&#123;aaa!&apos;-&apos;&#125; 在代码中不对aaa赋值，也不会报错了 ，当aaa为null则返回！后边的内容’-‘]]></content>
      <categories>
        <category>freemarker</category>
      </categories>
      <tags>
        <tag>freemarker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AOP日志]]></title>
    <url>%2F2018%2F10%2F10%2FAOP%E6%97%A5%E5%BF%97%2F</url>
    <content type="text"><![CDATA[1.日志实体类1234567891011public class SysLog &#123; private String id; private Date visitTime; private String visitTimeStr; private String username; private String ip; private String url; private Long executionTime; private String method;｝ 2.创建切面类处理日志123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172@Component@Aspectpublic class LogAop &#123; @Autowired private HttpServletRequest request; @Autowired private ISysLogService sysLogService; private Date visitTime; //开始时间 private Class clazz; //访问的类 private Method method;//访问的方法 //@SysLog作为切点 @Pointcut("@annotation(annotation.SysLog)") public void pointcut() &#123; // do nothing &#125; //前置通知 主要是获取开始时间，执行的类是哪一个，执行的是哪一个方法 @Before("pointcut()") public void doBefore(JoinPoint jp) throws NoSuchMethodException &#123; visitTime = new Date();//当前时间就是开始访问的时间 clazz = jp.getTarget().getClass(); //具体要访问的类 MethodSignature signature = (MethodSignature) jp.getSignature(); method = signature.getMethod(); &#125; //后置通知 @After("pointcut()") public void doAfter(JoinPoint jp) throws Exception &#123; long time = new Date().getTime() - visitTime.getTime(); //获取访问的时长 String url = ""; //获取url //LogAop放在controller包内所以要排除 if (clazz != null &amp;&amp; method != null &amp;&amp; clazz != LogAop.class) &#123; //1.获取类上的@RequestMapping("/orders") RequestMapping classAnnotation = (RequestMapping) clazz.getAnnotation(RequestMapping.class); if (classAnnotation != null) &#123; String[] classValue = classAnnotation.value(); //2.获取方法上的@RequestMapping(xxx) RequestMapping methodAnnotation = method.getAnnotation(RequestMapping.class); if (methodAnnotation != null) &#123; String[] methodValue = methodAnnotation.value(); url = classValue[0] + methodValue[0]; //获取访问的ip String ip = request.getRemoteAddr(); //获取当前操作的用户 SecurityContext context = SecurityContextHolder.getContext();//从上下文中获了当前登录的用户 User user = (User) context.getAuthentication().getPrincipal(); String username = user.getUsername(); //将日志相关信息封装到SysLog对象 SysLog sysLog = new SysLog(); sysLog.setExecutionTime(time); //执行时长 sysLog.setIp(ip); sysLog.setMethod("[类名] " + clazz.getName() + "[方法名] " + method.getName()); sysLog.setUrl(url); sysLog.setUsername(username); sysLog.setVisitTime(visitTime); //调用Service完成操作，保存sysLog sysLogService.save(sysLog); &#125; &#125; &#125; &#125;&#125; 3.SysLog12345@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface SysLog &#123; String value() default "";&#125; 在切面类中我们需要获取登录用户的username，还需要获取ip地址，我们怎么处理？ username获取SecurityContextHolder获取ip地址获取ip地址的获取我们可以通过request.getRemoteAddr()方法获取到。在Spring中可以通过RequestContextListener来获取request或session对象。 4.SysLogController12345678910111213141516@Controller@RequestMapping("/sysLog")public class SysLogController &#123; @Autowired private ISysLogService sysLogService; @RequestMapping("/findAll.do") public ModelAndView findAll() throws Exception &#123; ModelAndView mv=new ModelAndView(); List&lt;SysLog&gt; sysLogList= sysLogService.findAll(); mv.addObject("sysLogs",sysLogList); mv.setViewName("syslog-list"); return mv; &#125;&#125; 5.SysLogServiceImpl123456789101112@Autowired private ISysLogDao sysLogDao; @Override public List&lt;SysLog&gt; findAll() throws Exception &#123; return sysLogDao.findAll(); &#125; @Override public void save(SysLog sysLog) throws Exception &#123; sysLogDao.save(sysLog); &#125; 6.SysLogDao12345678public interface ISysLogDao &#123; @Insert("insert into syslog(visitTime,username,ip,url,executionTime,method) values(#&#123;visitTime&#125;,#&#123;username&#125;,#&#123;ip&#125;,#&#123;url&#125;,#&#123;executionTime&#125;,#&#123;method&#125;)") public void save(SysLog sysLog) throws Exception; @Select("select * from sysLog") List&lt;SysLog&gt; findAll() throws Exception;&#125;]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FastDFS]]></title>
    <url>%2F2018%2F10%2F10%2FFastDFS%2F</url>
    <content type="text"><![CDATA[入门demo使用装有FastDFS服务器的linux镜像ip地址为192.168.25.133 引入依赖1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.csource.fastdfs&lt;/groupId&gt; &lt;artifactId&gt;fastdfs&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 配置文件 fdfs_client.conf重点在IP地址：tracker_server=192.168.25.133:22122 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# connect timeout in seconds# default value is 30sconnect_timeout=30# network timeout in seconds# default value is 30snetwork_timeout=60# the base path to store log filesbase_path=/home/fastdfs# tracker_server can ocur more than once, and tracker_server format is# &quot;host:port&quot;, host can be hostname or ip addresstracker_server=192.168.25.133:22122#standard log level as syslog, case insensitive, value list:### emerg for emergency### alert### crit for critical### error### warn for warning### notice### info### debuglog_level=info# if use connection pool# default value is false# since V4.05use_connection_pool = false# connections whose the idle time exceeds this time will be closed# unit: second# default value is 3600# since V4.05connection_pool_max_idle_time = 3600# if load FastDFS parameters from tracker server# since V4.05# default value is falseload_fdfs_parameters_from_tracker=false# if use storage ID instead of IP address# same as tracker.conf# valid only when load_fdfs_parameters_from_tracker is false# default value is false# since V4.05use_storage_id = false# specify storage ids filename, can use relative or absolute path# same as tracker.conf# valid only when load_fdfs_parameters_from_tracker is false# since V4.05storage_ids_filename = storage_ids.conf#HTTP settingshttp.tracker_server_port=80#use &quot;#include&quot; directive to include HTTP other settiongs##include http.conf 编写测试12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) throws FileNotFoundException, IOException, Exception &#123; // 1.加载配置文件 ClientGlobal.init("D:\\ideawork\\FastDFS-demo\\src\\main\\resources\\fdfs_client.conf"); // 2.构建一个管理者客户端 TrackerClient client=new TrackerClient(); // 3.连接管理者服务端 TrackerServer trackerServer = client.getConnection(); //4. 声明存储服务端 StorageServer storageServer=null; //5. 获取存储服务器的客户端对象 StorageClient storageClient=new StorageClient(trackerServer, storageServer); //6.上传文件 //构造第三个参数用于指定图片尺寸，宽度，高度等属性 String[] strings = storageClient.upload_file("E:\\timg.jpg", "jpg", null); //7.显示上传结果 file_id for(String str:strings)&#123; System.out.println(str); &#125; &#125;&#125; 控制台打印 /* group1M00/00/00/wKgZhVu8h5OAbZl0AADfeUVZABs368.jpg */ 与ip地址拼接即可访问，镜像是使用了nginx反向代理的。 访问网址即可看到图片http://192.168.25.133/group1/M00/00/00/wKgZhVu8h5OAbZl0AADfeUVZABs368.jpg 结合项目示例引入fileupload和fastdfs依赖1234567891011&lt;dependency&gt; &lt;groupId&gt;org.csource.fastdfs&lt;/groupId&gt; &lt;artifactId&gt;fastdfs&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;!-- 文件上传组件 --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;$&#123;commons-fileupload.version&#125;&lt;/version&gt;&lt;/dependency&gt; fdfs_client.conf12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061# connect timeout in seconds# default value is 30sconnect_timeout=30# network timeout in seconds# default value is 30snetwork_timeout=60# the base path to store log filesbase_path=/home/fastdfs# tracker_server can ocur more than once, and tracker_server format is# &quot;host:port&quot;, host can be hostname or ip addresstracker_server=192.168.25.133:22122#standard log level as syslog, case insensitive, value list:### emerg for emergency### alert### crit for critical### error### warn for warning### notice### info### debuglog_level=info# if use connection pool# default value is false# since V4.05use_connection_pool = false# connections whose the idle time exceeds this time will be closed# unit: second# default value is 3600# since V4.05connection_pool_max_idle_time = 3600# if load FastDFS parameters from tracker server# since V4.05# default value is falseload_fdfs_parameters_from_tracker=false# if use storage ID instead of IP address# same as tracker.conf# valid only when load_fdfs_parameters_from_tracker is false# default value is false# since V4.05use_storage_id = false# specify storage ids filename, can use relative or absolute path# same as tracker.conf# valid only when load_fdfs_parameters_from_tracker is false# since V4.05storage_ids_filename = storage_ids.conf#HTTP settingshttp.tracker_server_port=80#use &quot;#include&quot; directive to include HTTP other settiongs##include http.conf 在mvc 的xml文件中配置多媒体解析器1234567&lt;!-- 配置多媒体解析器 --&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;property name="defaultEncoding" value="UTF-8"&gt;&lt;/property&gt; &lt;!-- 设定文件上传的最大值 5MB，5*1024*1024 --&gt; &lt;property name="maxUploadSize" value="5242880"&gt;&lt;/property&gt; &lt;/bean&gt; 编写Controller这里的file_server_url选择不写死，从配置文件中读取。 1FILE_SERVER_URL=http://192.168.25.133/ 123456789101112131415161718192021222324252627@RestControllerpublic class UploadController &#123; @Value("$&#123;FILE_SERVER_URL&#125;") private String file_server_url; @RequestMapping("/upload") public Result upload(MultipartFile file)&#123; String originalFilename = file.getOriginalFilename();//获取文件名 String extName=originalFilename.substring( originalFilename.lastIndexOf(".")+1);//得到扩展名 try &#123; util.FastDFSClient client=new FastDFSClient("classpath:fdfs_client.conf"); String fileId = client.uploadFile(file.getBytes(), extName); String url=file_server_url+fileId;//图片完整地址 //上传成功返回url地址。image标签内使用该url地址即能显示图片。 return new Result(true, url); &#125; catch (Exception e) &#123; e.printStackTrace(); return new Result(false, "上传失败"); &#125; &#125; &#125;]]></content>
      <categories>
        <category>FastDFS</category>
      </categories>
      <tags>
        <tag>FastDFS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringSecurity]]></title>
    <url>%2F2018%2F10%2F10%2FSpringSecurity%2F</url>
    <content type="text"><![CDATA[1.入门demo1.引入依赖这里使用的SpringSecurity版本为4.1.0。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;spring.version&gt;4.2.4.RELEASE&lt;/spring.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring-security--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-web&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-config&lt;/artifactId&gt; &lt;version&gt;4.1.0.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.spring-security.xml12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans:beans xmlns="http://www.springframework.org/schema/security" xmlns:beans="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd"&gt; &lt;!-- 设置页面不登陆也可以访问 --&gt; &lt;http pattern="/login.html" security="none"&gt;&lt;/http&gt; &lt;http pattern="/login_error.html" security="none"&gt;&lt;/http&gt; &lt;!-- 页面的拦截规则 use-expressions:是否启动SPEL表达式 默认是true --&gt; &lt;!--如果使用use-expressions，下面配置为 access="hasRole('ROLE_USER')" --&gt; &lt;http use-expressions="false"&gt; &lt;!-- 当前用户必须有ROLE_USER的角色 才可以访问根目录及所属子目录的资源 --&gt; &lt;intercept-url pattern="/**" access="ROLE_USER"/&gt; &lt;!-- 开启表单登陆功能 --&gt; &lt;!--登录页面，登录成功页面，和登录失败页面--&gt; &lt;form-login login-page="/login.html" default-target-url="/index.html" authentication-failure-url="/login_error.html"/&gt; &lt;!--CSRF(Cross-site request forgery)跨站请求伪造--&gt; &lt;!--spring security默认情况下csrf protection是开启的,由于我们的登录页没有配置csrf的相关信息，因此spring security内置的过滤器将此链接置为无效链接--&gt; &lt;csrf disabled="true"/&gt; &lt;!-- 登出， invalidate-session 是否删除session logout-url：登出处理链接 logout-success-url：登出成功页面 注：登出操作 只需要链接到 logout即可登出当前用户 --&gt; &lt;logout/&gt; &lt;/http&gt; &lt;!-- 认证管理器 --&gt; &lt;authentication-manager&gt; &lt;authentication-provider&gt; &lt;user-service&gt; &lt;user name="admin" password="123456" authorities="ROLE_USER"/&gt; &lt;/user-service&gt; &lt;/authentication-provider&gt; &lt;/authentication-manager&gt; &lt;/beans:beans&gt; form-login属性详解form-login是spring security命名空间配置登录相关信息的标签,它包含如下属性： login-page 自定义登录页url,默认为/login login-processing-url 登录请求拦截的url,也就是form表单提交时指定的action default-target-url 默认登录成功后跳转的url always-use-default-target 是否总是使用默认的登录成功后跳转url authentication-failure-url 登录失败后跳转的url username-parameter 用户名的请求字段 默认为userName password-parameter 密码的请求字段 默认为password authentication-success-handler-ref 指向一个AuthenticationSuccessHandler用于处理认证成功的请求,不能和default-target-url还有always-use-default-target同时使用 authentication-success-forward-url 用于authentication-failure-handler-ref authentication-failure-handler-ref 指向一个AuthenticationFailureHandler用于处理失败的认证请求 authentication-failure-forward-url 用于authentication-failure-handler-ref authentication-details-source-ref 指向一个AuthenticationDetailsSource,在认证过滤器中使用 logout几个重要的属性 invalidate-session 是否删除session logout-url：登出处理链接 logout-success-url：登出成功页面 网上看到过的配置 123&lt;http auto-config="true"&gt; &lt;intercept-url pattern="/admin**" access="ROLE_USER" /&gt; &lt;/http&gt; 1&lt;http auto-config="true"&gt; 自动配置过滤器(Filter)的属性 这是一个预留的属性，他可以自动配置login form,BSIC 认证和logout URL 和logout services,如果没有特殊表明，这个的默认值是false。我们推荐你避免使用这个属性。 使用auto-config=”true”后可以不配置form-login,logout等属性 3.web.xml1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-security.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 4.html页面login.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;登陆&lt;/title&gt;&lt;/head&gt;&lt;body&gt;--欢迎的登陆我的系统--&lt;form action="/login" method="post"&gt; 用户名：&lt;input name="username"&gt;&lt;br&gt; 密码：&lt;input name="password"&gt;&lt;br&gt; &lt;button&gt;登陆&lt;/button&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; index.html12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;欢迎进入神奇的spring security世界~~~&lt;/body&gt;&lt;/html&gt; login_error.html12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;用户名或密码错误~~~&lt;/body&gt;&lt;/html&gt; 配置完毕，请求会被拦截到login.html。登录账户为admin，密码为123456.成功后跳转到index.html。失败后跳转到login_error.html。 2.Spring Security使用数据库认证（非加密）不加密情况下，存储注册用户时，密码也不经过加密处理，SpringSecurity验证时也不经过加密处理。 下面使用的是SpringSecurity5版本 1&lt;spring.security.version&gt;5.0.1.RELEASE&lt;/spring.security.version&gt; 在Spring Security中如果想要使用数据进行认证操作，有很多种操作方式，这里我们介绍使用UserDetails、UserDetailsService来完成操作。 1.UserDetails123456789 public interface UserDetails extends Serializable &#123; Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); String getPassword(); String getUsername(); boolean isAccountNonExpired(); boolean isAccountNonLocked(); boolean isCredentialsNonExpired(); boolean isEnabled();&#125; UserDetails是一个接口，我们可以认为UserDetails作用是于封装当前进行认证的用户信息，但由于其是一个接口，所以我们可以对其进行实现，也可以使用Spring Security提供的一个UserDetails的实现类User来完成操作 以下是User类的部分代码 1234567891011 public class User implements UserDetails, CredentialsContainer &#123; private String password; private final String username; private final Set&lt;GrantedAuthority&gt; authorities; private final boolean accountNonExpired; //帐户是否过期 private final boolean accountNonLocked; //帐户是否锁定 private final boolean credentialsNonExpired; //认证是否过期 private final boolean enabled; //帐户是否可用 ｝ 2.UserDetailsService也是一个接口，需要我们实现方法。 1234 public interface UserDetailsService &#123; UserDetails loadUserByUsername(String username) throws UsernameNotFoundException;&#125; 3.UserInfo12345678910111213141516171819public class UserInfo &#123; private String id; private String username; private String email; private String password; private String phoneNum; private int status; private String statusStr; private List&lt;Role&gt; roles; public String getStatusStr() &#123; //状态0 未开启 1 开启 if (status == 0) &#123; statusStr = "未开启"; &#125; else if (status == 1) &#123; statusStr = "开启"; &#125; return statusStr; &#125;&#125; 4.Service接口继承UserDetailsService123 public interface UserService extends UserDetailsService&#123;&#125; 5.UserServiceImpl123456789101112131415161718192021222324252627@Service("userService")@Transactionalpublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; UserInfo userInfo = userDao.findByUsername(username); List&lt;Role&gt; roles = userInfo.getRoles(); List&lt;SimpleGrantedAuthority&gt; authoritys = getAuthority(roles); //&#123;noop&#125;前缀代表不加密 User user = new User(userInfo.getUsername(), "&#123;noop&#125;" + userInfo.getPassword(), userInfo.getStatus() == 0 ? false : true, true, true, true, authoritys); //根据status的数据判断是否激活。 return user; &#125; //作用就是返回一个List集合，集合中装入的是角色描述 private List&lt;SimpleGrantedAuthority&gt; getAuthority(List&lt;Role&gt; roles) &#123; List&lt;SimpleGrantedAuthority&gt; authoritys = new ArrayList(); for (Role role : roles) &#123; authoritys.add(new SimpleGrantedAuthority(role.getRoleName())); &#125; return authoritys; &#125;&#125; 6.对应的DaoUserDao1234567891011121314151617public interface UserDao &#123; @Select("select * from user where id=#&#123;id&#125;") public UserInfo findById(Long id) throws Exception; @Select("select * from user where username=#&#123;username&#125;") @Results(&#123; @Result(id = true, property = "id", column = "id"), @Result(column = "username", property = "username"), @Result(column = "email", property = "email"), @Result(column = "password", property = "password"), @Result(column = "phoneNum", property = "phoneNum"), @Result(column = "status", property = "status"), @Result(column = "id", property = "roles", javaType = java.util.List.class, many = @Many(select = "dao.RoleDao.findRoleByUserId")) &#125;) public UserInfo findByUsername(String username); &#125; RoleDao123456789//根据用户id查询出所有对应的角色 @Select("select * from role where id in (select roleId from users_role where userId=#&#123;userId&#125;)") @Results(&#123; @Result(id = true, property = "id", column = "id"), @Result(property = "roleName", column = "roleName"), @Result(property = "roleDesc", column = "roleDesc"), @Result(property = "permissions",column = "id",javaType = java.util.List.class,many = @Many(select = "dao.PermissionDao.findPermissionByRoleId")) &#125;) public List&lt;Role&gt; findRoleByUserId(String userId) throws Exception; PermissionDao123//查询与role关联的所有的权限 @Select("select * from permission where id in (select permissionId from role_permission where roleId=#&#123;id&#125; )") public List&lt;Permission&gt; findPermissionByRoleId(String id) throws Exception; 7.修改spring-security的配置使用自己实现的UserService。这里的xml标签与上面的不太一样，是因为约束的不同，两种都可以的。 12345678910&lt;!-- 切换成数据库中的用户名和密码 --&gt; &lt;security:authentication-manager&gt; &lt;security:authentication-provider user-service-ref="userService"&gt; &lt;!-- 配置加密的方式，注意这里没有开启，虽然配置了加密类--&gt; &lt;!--&lt;security:password-encoder ref="passwordEncoder"/&gt;--&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt; &lt;!-- 配置加密类 --&gt; &lt;bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/&gt; 完整版： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:security="http://www.springframework.org/schema/security" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/security http://www.springframework.org/schema/security/spring-security.xsd"&gt; &lt;!--&lt;security:global-method-security pre-post-annotations="enabled" jsr250-annotations="enabled" secured-annotations="enabled"&gt;&lt;/security:global-method-security&gt;--&gt; &lt;!-- 配置不拦截的资源 --&gt; &lt;security:http pattern="/login.jsp" security="none"/&gt; &lt;security:http pattern="/failer.jsp" security="none"/&gt; &lt;security:http pattern="/css/**" security="none"/&gt; &lt;security:http pattern="/img/**" security="none"/&gt; &lt;security:http pattern="/plugins/**" security="none"/&gt; &lt;!-- 配置具体的规则 auto-config="true" 不用自己编写登录的页面，框架提供默认登录页面 use-expressions="false" 是否使用SPEL表达式（没学习过） --&gt; &lt;security:http auto-config="true" use-expressions="true"&gt; &lt;!-- 配置具体的拦截的规则 pattern="请求路径的规则" access="访问系统的人，必须有ROLE_USER的角色" --&gt; &lt;security:intercept-url pattern="/**" access="hasAnyRole('ROLE_USER','ROLE_ADMIN')"/&gt; &lt;!-- 定义跳转的具体的页面 --&gt; &lt;security:form-login login-page="/login.jsp" login-processing-url="/login.do" default-target-url="/index.jsp" authentication-failure-url="/failer.jsp" authentication-success-forward-url="/pages/main.jsp" /&gt; &lt;!-- 关闭跨域请求 --&gt; &lt;security:csrf disabled="true"/&gt; &lt;!-- 退出 --&gt; &lt;security:logout invalidate-session="true" logout-url="/logout.do" logout-success-url="/login.jsp"/&gt; &lt;/security:http&gt; &lt;!-- 切换成数据库中的用户名和密码 --&gt; &lt;security:authentication-manager&gt; &lt;security:authentication-provider user-service-ref="userService"&gt; &lt;!-- 配置加密的方式--&gt; &lt;!--&lt;security:password-encoder ref="passwordEncoder"/&gt;--&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt; &lt;!-- 配置加密的方式，注意这里没有开启，虽然配置了加密类--&gt; &lt;bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/&gt; &lt;!-- &lt;bean id="webexpressionHandler" class="org.springframework.security.web.access.expression.DefaultWebSecurityExpressionHandler" /&gt;--&gt; &lt;!-- 提供了入门的方式，在内存中存入用户名和密码 &lt;security:authentication-manager&gt; &lt;security:authentication-provider&gt; &lt;security:user-service&gt; &lt;security:user name="admin" password="&#123;noop&#125;admin" authorities="ROLE_USER"/&gt; &lt;/security:user-service&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt; --&gt;&lt;/beans&gt; 关于{noop}的补充spring security PasswordEncoderspring security 5不需要配置密码的加密方式，而是用户密码加前缀的方式表明加密方式，如： {MD5}88e2d8cd1e92fd5544c8621508cd706b代表使用的是MD5加密方式； {bcrypt}$2a$10$eZeGvVV2ZXr/vgiVFzqzS.JLV878ApBgRT9maPK1Wrg0ovsf4YuI6代表使用的是bcrypt加密方式。 spring security官方推荐使用更加安全的bcrypt加密方式。 spring security 5支持的加密方式在PasswordEncoderFactories中定义： 1234567891011121314151617181920public class PasswordEncoderFactories &#123; public static PasswordEncoder createDelegatingPasswordEncoder() &#123; String encodingId = "bcrypt"; Map&lt;String, PasswordEncoder&gt; encoders = new HashMap(); encoders.put(encodingId, new BCryptPasswordEncoder()); encoders.put("ldap", new LdapShaPasswordEncoder()); encoders.put("MD4", new Md4PasswordEncoder()); encoders.put("MD5", new MessageDigestPasswordEncoder("MD5")); encoders.put("noop", NoOpPasswordEncoder.getInstance()); encoders.put("pbkdf2", new Pbkdf2PasswordEncoder()); encoders.put("scrypt", new SCryptPasswordEncoder()); encoders.put("SHA-1", new MessageDigestPasswordEncoder("SHA-1")); encoders.put("SHA-256", new MessageDigestPasswordEncoder("SHA-256")); encoders.put("sha256", new StandardPasswordEncoder()); return new DelegatingPasswordEncoder(encodingId, encoders); &#125; private PasswordEncoderFactories() &#123; &#125;&#125; 8.web.xml12345678&lt;filter&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 3.密码加密（bcrypt加密方式）当使用加密时： 1.注册用户，即保存到数据库中的密码是经过加密处理的123456789 @Autowired private BCryptPasswordEncoder bCryptPasswordEncoder;@Override public void save(UserInfo userInfo) throws Exception &#123; //对密码进行加密处理 userInfo.setPassword(bCryptPasswordEncoder.encode(userInfo.getPassword())); userDao.save(userInfo); &#125; 2.spring-security.xml开启加密12345678910&lt;!-- 切换成数据库中的用户名和密码 --&gt; &lt;security:authentication-manager&gt; &lt;security:authentication-provider user-service-ref="userService"&gt; &lt;!-- 配置加密的方式，注意这里没有开启，虽然配置了加密类--&gt; &lt;security:password-encoder ref="passwordEncoder"/&gt; &lt;/security:authentication-provider&gt; &lt;/security:authentication-manager&gt; &lt;!-- 配置加密类 --&gt; &lt;bean id="passwordEncoder" class="org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"/&gt; 3.SpringSecurity验证时开启加密去掉{noop}，按照上面的理论加上{scrypt}前缀应该也可以。 1234567891011@Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException &#123; UserInfo userInfo = userDao.findByUsername(username); List&lt;Role&gt; roles = userInfo.getRoles(); List&lt;SimpleGrantedAuthority&gt; authoritys = getAuthority(roles); //&#123;noop&#125;前缀代表不加密 User user = new User(userInfo.getUsername(), userInfo.getPassword(), userInfo.getStatus() == 0 ? false : true, true, true, true, authoritys); //根据status的数据判断是否激活。 return user; &#125; 4.注解权限控制在服务器端我们可以通过Spring security提供的注解对方法来进行权限控制。Spring Security在方法的权限控制上支持三种类型的注解，JSR-250注解、@Secured注解和支持表达式的注解，这三种注解默认都是没有启用的，需要单独通过global-method-security元素的对应属性进行启用 1.配置文件12345&lt;dependency&gt; &lt;groupId&gt;javax.annotation&lt;/groupId&gt; &lt;artifactId&gt;jsr250-api&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; jsr需要依赖 123&lt;security:global-method-security jsr250-annotations="enabled"/&gt; &lt;security:global-method-security secured-annotations="enabled"/&gt; &lt;security:global-method-security pre-post-annotations="disabled"/&gt; 2.注解开启@EnableGlobalMethodSecurity ：Spring Security默认是禁用注解的，要想开启注解，需要在继承WebSecurityConﬁgurerAdapter的类上加@EnableGlobalMethodSecurity注解，并在该类中将AuthenticationManager定义为Bean。 这个是针对@Configuration配合@Bean的方式的 3.使用注解JSR-250注解@RolesAllowed表示访问对应方法时所应该具有的角色 示例：@RolesAllowed({“USER”, “ADMIN”}) 该方法只要具有”USER”, “ADMIN”任意一种权限就可以访问。这里可以省略前缀ROLE_，实际的权限可能是ROLE_ADMIN @PermitAll表示允许所有的角色进行访问，也就是说不进行权限控制 @DenyAll是和PermitAll相反的，表示无论什么角色都不能访问 支持表达式的注解@PreAuthorize 在方法调用之前,基于表达式的计算结果来限制对方法的访问 示例： 123@PreAuthorize(&quot;#userId == authentication.principal.userId or hasAuthority(‘ADMIN’)&quot;) void changePassword(@P(&quot;userId&quot;) long userId )&#123; &#125; 这里表示在changePassword方法执行之前，判断方法参数userId的值是否等于principal中保存的当前用户的userId，或者当前用户是否具有ROLE_ADMIN权限，两种符合其一，就可以访问该方法。 @PostAuthorize 允许方法调用,但是如果表达式计算结果为false,将抛出一个安全性异常 1234示例： @PostAuthorize User getUser(&quot;returnObject.userId == authentication.principal.userId or hasPermission(returnObject, &apos;ADMIN&apos;)&quot;); @PostFilter 允许方法调用,但必须按照表达式来过滤方法的结果 @PreFilter 允许方法调用,但必须在进入方法之前过滤输入值 @Secured注解@Secured注解标注的方法进行权限控制的支持，其值默认为disabled。 1234示例： @Secured("IS_AUTHENTICATED_ANONYMOUSLY") public Account readAccount(Long id); @Secured("ROLE_TELLER") 5.页面端标签控制权限在jsp页面中我们可以使用spring security提供的权限标签来进行权限控制 导入依赖12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-taglibs&lt;/artifactId&gt; &lt;version&gt;version&lt;/version&gt; &lt;/dependency&gt; 页面导入1&lt;%@taglib uri="http://www.springframework.org/security/tags" prefix="security"%&gt; 常用标签在jsp中我们可以使用以下三种标签，其中authentication代表的是当前认证对象，可以获取当前认证对象信息，例如用户名。其它两个标签我们可以用于权限控制 authentication1&lt;security:authentication property="" htmlEscape="" scope="" var=""/&gt; property： 只允许指定Authentication所拥有的属性，可以进行属性的级联获取，如“principle.username”，不允许直接通过方法进行调用htmlEscape：表示是否需要将html进行转义。默认为true。scope：与var属性一起使用，用于指定存放获取的结果的属性名的作用范围，默认我pageContext。Jsp中拥有的作用范围都进行进行指定var： 用于指定一个属性名，这样当获取到了authentication的相关信息后会将其以var指定的属性名进行存放，默认是存放在pageConext中 authorize1&lt;security:authorize access="" method="" url="" var=""&gt;&lt;/security:authorize&gt; access： 需要使用表达式来判断权限，当表达式的返回结果为true时表示拥有对应的权限method：method属性是配合url属性一起使用的，表示用户应当具有指定url指定method访问的权限，method的默认值为GET，可选值为http请求的7种方法url：url表示如果用户拥有访问指定url的权限即表示可以显示authorize标签包含的内容var：用于指定将权限鉴定的结果存放在pageContext的哪个属性中 accesscontrollistaccesscontrollist标签是用于鉴定ACL权限的。其一共定义了三个属性：hasPermission、domainObject和var，其中前两个是必须指定的 1&lt;security:accesscontrollist hasPermission="" domainObject="" var=""&gt;&lt;/security:accesscontrollist&gt; hasPermission：hasPermission属性用于指定以逗号分隔的权限列表domainObject：domainObject用于指定对应的域对象var：var则是用以将鉴定的结果以指定的属性名存入pageContext中，以供同一页面的其它地方使用]]></content>
      <categories>
        <category>springsecurity</category>
      </categories>
      <tags>
        <tag>springsecurity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring集成shiro示例（包括注解和缓存，加密）]]></title>
    <url>%2F2018%2F10%2F04%2Fspring%E9%9B%86%E6%88%90shiro%E7%A4%BA%E4%BE%8B%EF%BC%88%E5%8C%85%E6%8B%AC%E6%B3%A8%E8%A7%A3%E5%92%8C%E7%BC%93%E5%AD%98%EF%BC%8C%E5%8A%A0%E5%AF%86%EF%BC%89%2F</url>
    <content type="text"><![CDATA[1.引入依赖123456789101112131415161718192021222324252627282930&lt;!--shiro--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- shiro-encache--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-ehcache&lt;/artifactId&gt; &lt;version&gt;1.4.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--ehcache--&gt; &lt;dependency&gt; &lt;groupId&gt;org.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;3.4.0&lt;/version&gt; &lt;/dependency&gt; 2.web.xml配置，读取shiro.xml123456789101112131415161718&lt;!--shiroFilter--&gt;&lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; &lt;!-- 读取配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mybatis.xml, classpath:applicationContext.xml, classpath:shiro.xml &lt;/param-value&gt; &lt;/context-param&gt; 3.shiro.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:cache="http://www.springframework.org/schema/cache" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/cache http://www.springframework.org/schema/cache/spring-cache.xsd"&gt; &lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;!--注入securityManager--&gt; &lt;property name="securityManager" ref="securityManager"&gt;&lt;/property&gt; &lt;!-- 要求登录时的链接(可根据项目的URL进行替换),非必须的属性,默认会自动寻找Web工程根目录下的"/login.jsp"页面 --&gt; &lt;property name="loginUrl" value="/pages/login.jsp"&gt;&lt;/property&gt; &lt;!--权限不够跳转页面--&gt; &lt;property name="unauthorizedUrl" value="/pages/failer.jsp"&gt;&lt;/property&gt; &lt;!-- 登录后跳转到业务页面 --&gt; &lt;property name="successUrl" value="/pages/main.jsp"/&gt; &lt;!--过滤器链--&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; &lt;!--从上往下过滤--&gt; /pages/login.jsp = anon&lt;!--无需认证--&gt; /user/login = anon /css/** = anon /img/** = anon /plugins/** = anon /** = authc&lt;!--需要认证--&gt; &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--创建securityManager--&gt; &lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;!--注入jdbcRealm--&gt; &lt;property name="realm" ref="myRealm"&gt;&lt;/property&gt; &lt;property name="cacheManager" ref="shiroCacheManager" /&gt; &lt;/bean&gt; &lt;bean id="myRealm" class="shiro.MyRealm"&gt; &lt;!--配置加密--&gt; &lt;property name="credentialsMatcher" ref="credentialsMatcher"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置密码匹配对象 --&gt; &lt;bean id="credentialsMatcher" class="org.apache.shiro.authc.credential.HashedCredentialsMatcher"&gt; &lt;!--加密方式--&gt; &lt;property name="hashAlgorithmName" value="md5"&gt;&lt;/property&gt; &lt;!--加密次数--&gt; &lt;property name="hashIterations" value="1"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 缓存配置 start--&gt; &lt;bean id="ehCache" class="org.springframework.cache.ehcache.EhCacheManagerFactoryBean"&gt; &lt;property name="configLocation" value="classpath:ehcache.xml" /&gt; &lt;/bean&gt; &lt;!--cacheManager --&gt; &lt;bean id="shiroCacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager"&gt; &lt;property name="cacheManager" ref="ehCache" /&gt; &lt;/bean&gt; &lt;!-- 缓存配置 end--&gt; &lt;!--注解开启设置 start--&gt; &lt;!-- 保证实现了Shiro内部lifecycle函数的bean执行 --&gt; &lt;bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/&gt; &lt;!--开启aop，对类代理--&gt; &lt;aop:config proxy-target-class="true"&gt;&lt;/aop:config&gt; &lt;bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"&gt; &lt;property name="securityManager" ref="securityManager" /&gt; &lt;/bean&gt; &lt;!--注解开启设置 end--&gt;&lt;/beans&gt; 4.ehcache.xml123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd"&gt; &lt;!-- 磁盘缓存位置 --&gt; &lt;!--java.io.tmpdir是获取操作系统缓存的临时目录，不同操作系统的缓存临时目录不一样--&gt; &lt;!--Windows: java.io.tmpdir:[C:\Users\登录用户~1\AppData\Local\Temp\]--&gt; &lt;diskStore path="java.io.tmpdir"/&gt; &lt;!-- 默认缓存 --&gt; &lt;defaultCache maxEntriesLocalHeap="10000" eternal="false" timeToIdleSeconds="120" timeToLiveSeconds="120" maxEntriesLocalDisk="10000000" diskExpiryThreadIntervalSeconds="120" memoryStoreEvictionPolicy="LRU"&gt; &lt;persistence strategy="localTempSwap"/&gt; &lt;/defaultCache&gt; &lt;cache name="shiroCache" maxElementsInMemory="1000" eternal="false" timeToIdleSeconds="3" timeToLiveSeconds="3" maxEntriesLocalDisk="10000000" overflowToDisk="false" memoryStoreEvictionPolicy="LRU"/&gt;&lt;/ehcache&gt; 5.编写MyRealm里面的主要查询其实就是查询user用户下的所有角色和以及角色下的所有权限 一个用户可以对应很多角色，一个角色又可以对应很多的权限。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class MyRealm extends AuthorizingRealm&#123; @Autowired private UserService userService; @Autowired private PermissionService permissionService; @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) &#123; //当涉及到权限操作时会执行这里的方法，而且是每次，如果配置了缓存的话 //只有第一次会，后面就不会了。用户退出的时候要清楚缓存。 String username = (String) principalCollection.getPrimaryPrincipal(); User user = findUserByUsername(username); List&lt;String&gt; roleList = new ArrayList&lt;&gt;(); List&lt;String&gt; permissionList = new ArrayList&lt;&gt;(); if(user!=null)&#123; for (Role role : user.getRoles()) &#123; //根据role id获得permission集合 List&lt;Permission&gt; permissions = permissionService.findPermissionsByRoleId(role.getId()); //遍历集合获得permissionName存到list集合中。 for (Permission permission : permissions) &#123; if(StringUtil.isNotEmpty(permission.getPermissionName()))&#123; permissionList.add(permission.getPermissionName()); &#125; &#125; roleList.add(role.getRoleName()); &#125; SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); authorizationInfo.addRoles(roleList); authorizationInfo.addStringPermissions(permissionList); return authorizationInfo; &#125; return null; &#125; @Override//验证操作 protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException &#123; String username = (String) authenticationToken.getPrincipal(); User user = findUserByUsername(username); if(user!=null)&#123; if(user.getStatus()!=0)&#123; /*把email作为盐*/ ByteSource credentialsSalt = ByteSource.Util.bytes(user.getEmail()); AuthenticationInfo info = new SimpleAuthenticationInfo(user.getUsername(), user.getPassword(),credentialsSalt ,getName());//getName()获得的是shiro.xml中配置的myRealm return info; &#125;else &#123; //这里是自定义的异常，验证方法内产生的异常都是AuthenticationException的子类 //包括UnknownAccountException，没有用户异常，IncorrectCredentialsException //密码错误异常等等，但是没有未激活对应的异常，所以要自己定义让后继承AuthenticationException就好了，而且要自己抛。 throw new NotActivatedException("账户未激活"); &#125; &#125; return null; &#125; private User findUserByUsername(String username)&#123; return userService.findUserByUsername(username); &#125;&#125; 6.验证和权限草操作是的dao执行及对应mapper.xml12345678public interface UserDao extends BaseMapper&lt;User&gt; &#123; User findUserByUsername(@Param("username") String username);&#125;public interface PermissionDao extends BaseMapper&lt;Permission&gt;&#123; List&lt;Permission&gt; findPermissionsByRoleId(String id);&#125; UserMapper.xml12345678910111213141516171819202122232425262728&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.UserDao"&gt; &lt;resultMap id="BaseMapper" type="entity.User"&gt; &lt;id property="id" column="user_id"&gt;&lt;/id&gt; &lt;result property="username" column="username"&gt;&lt;/result&gt; &lt;result property="email" column="email"&gt;&lt;/result&gt; &lt;result property="password" column="password"&gt;&lt;/result&gt; &lt;result property="phoneNum" column="phoneNum"&gt;&lt;/result&gt; &lt;result property="status" column="status"&gt;&lt;/result&gt; &lt;collection property="roles" ofType="entity.Role"&gt; &lt;id property="id" column="role_id"&gt;&lt;/id&gt; &lt;result property="roleName" column="roleName"&gt;&lt;/result&gt; &lt;result property="roleDesc" column="roleDesc"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id="findUserByUsername" resultMap="BaseMapper"&gt; select u.ID as user_id,u.USERNAME,u.EMAIL,u.PHONENUM,u.PASSWORD,u.STATUS,r.ID as role_id,r.ROLEDESC,r.ROLENAME from USERS u LEFT JOIN USERS_ROLE ur on u.ID = ur.USERID LEFT JOIN ROLE r on r.ID = ur.ROLEID WHERE u.USERNAME = #&#123;username&#125; &lt;/select&gt;&lt;/mapper&gt; PermissionMapper.xml123456789101112&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.PermissionDao"&gt; &lt;select id="findPermissionsByRoleId" resultType="entity.Permission" parameterType="String"&gt; select p.ID as permission_id,p.PERMISSIONNAME,p.URL from ROLE R LEFT JOIN ROLE_PERMISSION RP ON R.ID = RP.ROLEID LEFT JOIN PERMISSION P ON RP.PERMISSIONID = P.ID where r.ID = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 7.用户，角色，权限实体类用户和角色是多对多，角色和权限是多对多。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950@Getter@Setter@ToString@TableName("users")public class User implements Serializable &#123; @TableId(value = "id",type = IdType.UUID) private String id;//id private String username;//用户名 private String email;//邮箱 private String password;//密码 private String phoneNum;//电话 private int status;//状态 @TableField(exist=false) private String statusStr;//状态 String @TableField(exist=false) private List&lt;Role&gt; roles; public String getStatusStr() &#123; //状态0 未开启 1 开启 if (status == 0) &#123; statusStr = "未开启"; &#125; else if (status == 1) &#123; statusStr = "开启"; &#125; return statusStr; &#125;&#125;@Getter@Setter@ToStringpublic class Role implements Serializable &#123; private String id;//id private String roleName;//角色名 private String roleDesc;//角色描述 private List&lt;Permission&gt; permissions; private List&lt;User&gt; users;&#125;@Getter@Setter@ToStringpublic class Permission implements Serializable &#123; private String id;//id private String permissionName;//权限名 private String url;//资源路径 private List&lt;Role&gt; roles;&#125; 8.自定义异常12345678910111213141516public class NotActivatedException extends AuthenticationException &#123; private String msg; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; public NotActivatedException() &#123; &#125; public NotActivatedException(String msg) &#123; this.msg = msg; &#125;&#125; 9.登录conreoller根据异常不同添加不同的msg，但是都是AuthenticationException 的子类。 123456789101112131415161718192021222324252627@Controller@RequestMapping("/user")public class UserController &#123; @Autowired private UserService userService; @RequestMapping("/login") public String login(User user, Model model, HttpSession session)&#123; Subject subject = SecurityUtils.getSubject(); try&#123; UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(),user.getPassword()); subject.login(token); session.setAttribute("user",user); return "redirect:/pages/main.jsp"; &#125;catch (AuthenticationException e)&#123; String simpleName = e.getClass().getSimpleName();//获得异常名称 if("UnknownAccountException".equals(simpleName))&#123; model.addAttribute("msg", "用户不存在"); &#125;else if("IncorrectCredentialsException".equals(simpleName))&#123; model.addAttribute("msg", "密码不正确"); &#125;else if(e instanceof NotActivatedException)&#123; model.addAttribute("msg","账户未激活"); &#125; return "login"; &#125; &#125;&#125; 10.权限操作示例需要用户下有admin的角色，才能操作这个方法，否则会报错，可以捕捉错误让后跳转到对应页面。 而且由于配置了encache缓存，只在第一次执行改方法时回去查询是否有权限，之后再执行该方法，不会进入MyRealm的doGetAuthorizationInfo方法，从而不会去查询是否有权限。 123456789@RequestMapping("/save")@RequiresRoles("admin")public String saveUser(User user)&#123; //把密码加密后存入 Md5Hash md5Hash = new Md5Hash(user.getPassword(),user.getEmail()); user.setPassword(md5Hash.toString()); userService.saveUser(user); return "redirect:findAllUser";&#125;]]></content>
      <categories>
        <category>shiro</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>shrio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot整合logback实现日志管理]]></title>
    <url>%2F2018%2F10%2F04%2FSpringboot%E6%95%B4%E5%90%88logback%E5%AE%9E%E7%8E%B0%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Spring Boot 默认实现的日志管理就是使用的logback。 保持默认依赖即可12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;springboot&lt;/groupId&gt; &lt;artifactId&gt;demo&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;demo&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 创建logback-spring.xml官方推荐使用的xml名字的格式为：logback-spring.xml而不是logback.xml。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;configuration scan="true" scanPeriod="60 seconds" debug="false"&gt; &lt;contextName&gt;febs&lt;/contextName&gt; &lt;property name="log.path" value="log" /&gt; &lt;property name="log.maxHistory" value="15" /&gt; &lt;property name="log.colorPattern" value="%d&#123;yyyy-MM-dd HH:mm:ss&#125; | %highlight(%-5level) | %boldYellow(%thread) | %boldGreen(%logger) | %msg%n"/&gt; &lt;property name="log.pattern" value="%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; %contextName [%thread] %-5level %logger&#123;36&#125; - %msg%n" /&gt; &lt;!--输出到控制台--&gt; &lt;appender name="console" class="ch.qos.logback.core.ConsoleAppender"&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.colorPattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!--输出到文件--&gt; &lt;appender name="file_info" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/info/info.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;MaxHistory&gt;$&#123;log.maxHistory&#125;&lt;/MaxHistory&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;INFO&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;appender name="file_error" class="ch.qos.logback.core.rolling.RollingFileAppender"&gt; &lt;rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy"&gt; &lt;fileNamePattern&gt;$&#123;log.path&#125;/error/error.%d&#123;yyyy-MM-dd&#125;.log&lt;/fileNamePattern&gt; &lt;/rollingPolicy&gt; &lt;encoder&gt; &lt;pattern&gt;$&#123;log.pattern&#125;&lt;/pattern&gt; &lt;/encoder&gt; &lt;filter class="ch.qos.logback.classic.filter.LevelFilter"&gt; &lt;level&gt;ERROR&lt;/level&gt; &lt;onMatch&gt;ACCEPT&lt;/onMatch&gt; &lt;onMismatch&gt;DENY&lt;/onMismatch&gt; &lt;/filter&gt; &lt;/appender&gt; &lt;root level="debug"&gt; &lt;appender-ref ref="console" /&gt; &lt;/root&gt; &lt;root level="info"&gt; &lt;appender-ref ref="file_info" /&gt; &lt;appender-ref ref="file_error" /&gt; &lt;/root&gt;&lt;/configuration&gt; 新建log存放文件夹 在项目中创建文件夹log，log下新建error和info 让日志存放在项目内 application properties配置1logging.config=classpath:logback-spring.xml]]></content>
      <categories>
        <category>springboot</category>
        <category>日志</category>
      </categories>
      <tags>
        <tag>日志</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm和springboot设置控制台打印sql语句]]></title>
    <url>%2F2018%2F10%2F04%2Fssm%E5%92%8Cspringboot%E8%AE%BE%E7%BD%AE%E6%8E%A7%E5%88%B6%E5%8F%B0%E6%89%93%E5%8D%B0sql%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[springboot设置springboot比较简单 application.properties增加配置 logging.level+包名=debug 即使使用的是mybatis-plus仍然是有效的，如果不能打印是下面的路径配置错了！！ 1logging.level.springboot.demo.dao=debug ssm设置创建mybatis配置文件：mybatis-config.xml 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--用于配合log4j在控制台打印sql语句--&gt; &lt;settings&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING" /&gt; &lt;/settings&gt;&lt;/configuration&gt; spring-mybatis.xml整合mybatis-config.xml 123456789101112&lt;!-- 配置SqlSessionFactory对象 --&gt;&lt;bean class="org.mybatis.spring.SqlSessionFactoryBean" id="sqlSessionFactory"&gt; &lt;!-- 自动扫描mybatis配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml"&gt;&lt;/property&gt; &lt;!-- 扫描model包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="entity"&gt;&lt;/property&gt; &lt;!--配置使用pageHelper--&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>日志</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>日志</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis注解开发]]></title>
    <url>%2F2018%2F10%2F04%2FMybatis%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Mybatis注解开发实体类12345678public class User implements Serializable&#123; private Integer id; private String username; private String address; private String sex; private Date birthday; &#125; Dao123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("select * from user") List&lt;User&gt; findAll(); /** * 保存用户 * @param user */ @Insert("insert into user(username,address,sex,birthday)values(#&#123;username&#125;,#&#123;address&#125;,#&#123;sex&#125;,#&#123;birthday&#125;)") void saveUser(User user); /** * 更新用户 * @param user */ @Update("update user set username=#&#123;username&#125;,sex=#&#123;sex&#125;,birthday=#&#123;birthday&#125;,address=#&#123;address&#125; where id=#&#123;id&#125;") void updateUser(User user); /** * 删除用户 * @param userId */ @Delete("delete from user where id=#&#123;id&#125; ") void deleteUser(Integer userId); /** * 根据id查询用户 * @param userId * @return */ @Select("select * from user where id=#&#123;id&#125; ") User findById(Integer userId); /** * 根据用户名称模糊查询 * @param username * @return */// @Select("select * from user where username like #&#123;username&#125; ") @Select("select * from user where username like '%$&#123;value&#125;%' ") List&lt;User&gt; findUserByName(String username); /** * 查询总用户数量 * @return */ @Select("select count(*) from user ") int findTotalUser();&#125; 多对一,多对一注解开发实体类123456789public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; //多对一（mybatis中称之为一对一）的映射：一个账户只能属于一个用户 private User user;&#125; 1234567891011public class User implements Serializable&#123; private Integer userId; private String userName; private String userAddress; private String userSex; private Date userBirthday; //一对多关系映射：一个用户对应多个账户 private List&lt;Account&gt; accounts;&#125; IAccountDao1234567891011121314151617181920212223public interface IAccountDao &#123; /** * 查询所有账户，并且获取每个账户所属的用户信息 * @return */ @Select("select * from account") @Results(id="accountMap",value = &#123; @Result(id=true,column = "id",property = "id"), @Result(column = "uid",property = "uid"), @Result(column = "money",property = "money"), @Result(property = "user",column = "uid",one=@One(select="com.itheima.dao.IUserDao.findById",fetchType= FetchType.EAGER)) &#125;)//懒加载 List&lt;Account&gt; findAll(); /** * 根据用户id查询账户信息 * @param userId * @return */ @Select("select * from account where uid = #&#123;userId&#125;") List&lt;Account&gt; findAccountByUid(Integer userId);&#125; IUserDao123456789101112131415161718192021222324252627282930313233343536373839@CacheNamespace(blocking = true)public interface IUserDao &#123; /** * 查询所有用户 * @return */ @Select("select * from user") @Results(id="userMap",value=&#123; @Result(id=true,column = "id",property = "userId"), @Result(column = "username",property = "userName"), @Result(column = "address",property = "userAddress"), @Result(column = "sex",property = "userSex"), @Result(column = "birthday",property = "userBirthday"), @Result(property = "accounts",column = "id", many = @Many(select = "com.itheima.dao.IAccountDao.findAccountByUid", fetchType = FetchType.LAZY))//懒加载 &#125;) List&lt;User&gt; findAll(); /** * 根据id查询用户 * @param userId * @return */ @Select("select * from user where id=#&#123;id&#125; ") @ResultMap("userMap") User findById(Integer userId); /** * 根据用户名称模糊查询 * @param username * @return */ @Select("select * from user where username like #&#123;username&#125; ") @ResultMap("userMap") List&lt;User&gt; findUserByName(String username);&#125;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis的mapper.xml参考配置实例]]></title>
    <url>%2F2018%2F10%2F04%2Fmybatis%E7%9A%84mapper-xml%E5%8F%82%E8%80%83%E9%85%8D%E7%BD%AE%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[更新数据后返回主键id1234567&lt;insert id="save" parameterType="category"&gt; /*往数据库插入一条数据，返回插入数据的id配置*/ &lt;selectKey resultType="java.lang.Integer" keyProperty="id" order="AFTER" keyColumn="id"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; insert into category values(null,#&#123;name&#125;)&lt;/insert&gt; 动态sql–if标签1234567&lt;select id="getTotalCountByNameWithId" resultType="int"&gt; SELECT count(*) from tab_route where cid = #&#123;id&#125; &lt;if test="name!=null and name != ''"&gt; and rname LIKE '%$&#123;name&#125;%' &lt;/if&gt;&lt;/select&gt; 动态sql–where标签简化where 1 = 1 条件拼装。 1234567891011&lt;select id="findUserByCondition" resultMap="userMap" parameterType="user"&gt; select * from user &lt;where&gt; &lt;if test="userName != null"&gt; and username = #&#123;userName&#125; &lt;/if&gt; &lt;if test="userSex != null"&gt; and sex = #&#123;userSex&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 动态sql–foreach标签1234567891011&lt;!-- 根据queryvo中的Id集合实现查询用户列表 --&gt; &lt;select id="findUserInIds" resultMap="userMap" parameterType="queryvo"&gt; select * from user &lt;where&gt; &lt;if test="ids != null and ids.size()&gt;0"&gt; &lt;foreach collection="ids" open="and id in (" close=")" item="uid" separator=","&gt; #&#123;uid&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 12345public class QueryVo &#123; private User user; private List&lt;Integer&gt; ids; 多对一配置12345678910111213141516171819&lt;!-- 定义封装account和user的resultMap --&gt; &lt;resultMap id="accountUserMap" type="account"&gt; &lt;id property="id" column="aid"&gt;&lt;/id&gt; &lt;result property="uid" column="uid"&gt;&lt;/result&gt; &lt;result property="money" column="money"&gt;&lt;/result&gt; &lt;!-- 一对一的关系映射：配置封装user的内容--&gt; &lt;association property="user" column="uid" javaType="user"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"&gt;&lt;/result&gt; &lt;result column="address" property="address"&gt;&lt;/result&gt; &lt;result column="sex" property="sex"&gt;&lt;/result&gt; &lt;result column="birthday" property="birthday"&gt;&lt;/result&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id="findAll" resultMap="accountUserMap"&gt; select u.*,a.id as aid,a.uid,a.money from account a , user u where u.id = a.uid; &lt;/select&gt; 1234567891011public class User implements Serializable &#123; private Integer id; private String username; private String address; private String sex; private Date birthday; //一对多关系映射：主表实体应该包含从表实体的集合引用 private List&lt;Account&gt; accounts; &#125; 123456789public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; //从表实体应该包含一个主表实体的对象引用 private User user; &#125; 一对多配置12345678910111213141516171819&lt;!-- 定义User的resultMap--&gt; &lt;resultMap id="userAccountMap" type="user"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="username" column="username"&gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt; &lt;collection property="accounts" ofType="account"&gt; &lt;id column="aid" property="id"&gt;&lt;/id&gt; &lt;result column="uid" property="uid"&gt;&lt;/result&gt; &lt;result column="money" property="money"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id="findAll" resultMap="userAccountMap"&gt; select * from user u left outer join account a on u.id = a.uid &lt;/select&gt; 1234567891011public class User implements Serializable &#123; private Integer id; private String username; private String address; private String sex; private Date birthday; //一对多关系映射：主表实体应该包含从表实体的集合引用 private List&lt;Account&gt; accounts; &#125; 123456789public class Account implements Serializable &#123; private Integer id; private Integer uid; private Double money; //从表实体应该包含一个主表实体的对象引用 private User user; &#125; 多对多配置123456789public class Role implements Serializable &#123; private Integer roleId; private String roleName; private String roleDesc; //多对多的关系映射：一个角色可以赋予多个用户 private List&lt;User&gt; users; &#125; 1234567891011public class User implements Serializable &#123; private Integer id; private String username; private String address; private String sex; private Date birthday; //多对多的关系映射：一个用户可以具备多个角色 private List&lt;Role&gt; roles;&#125; IRoleDao.xml主要是在sql语句的书写。user_role为中间表 1234567891011121314151617181920212223&lt;mapper namespace="com.itheima.dao.IRoleDao"&gt; &lt;!--定义role表的ResultMap--&gt; &lt;resultMap id="roleMap" type="role"&gt; &lt;id property="roleId" column="rid"&gt;&lt;/id&gt; &lt;result property="roleName" column="role_name"&gt;&lt;/result&gt; &lt;result property="roleDesc" column="role_desc"&gt;&lt;/result&gt; &lt;collection property="users" ofType="user"&gt; &lt;id column="id" property="id"&gt;&lt;/id&gt; &lt;result column="username" property="username"&gt;&lt;/result&gt; &lt;result column="address" property="address"&gt;&lt;/result&gt; &lt;result column="sex" property="sex"&gt;&lt;/result&gt; &lt;result column="birthday" property="birthday"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!--查询所有--&gt; &lt;select id="findAll" resultMap="roleMap"&gt; select u.*,r.id as rid,r.role_name,r.role_desc from role r left outer join user_role ur on r.id = ur.rid left outer join user u on u.id = ur.uid &lt;/select&gt;&lt;/mapper&gt; IUserDao.xml123456789101112131415161718192021222324252627282930&lt;mapper namespace="com.itheima.dao.IUserDao"&gt; &lt;!-- 定义User的resultMap--&gt; &lt;resultMap id="userMap" type="user"&gt; &lt;id property="id" column="id"&gt;&lt;/id&gt; &lt;result property="username" column="username"&gt;&lt;/result&gt; &lt;result property="address" column="address"&gt;&lt;/result&gt; &lt;result property="sex" column="sex"&gt;&lt;/result&gt; &lt;result property="birthday" column="birthday"&gt;&lt;/result&gt; &lt;!-- 配置角色集合的映射 --&gt; &lt;collection property="roles" ofType="role"&gt; &lt;id property="roleId" column="rid"&gt;&lt;/id&gt; &lt;result property="roleName" column="role_name"&gt;&lt;/result&gt; &lt;result property="roleDesc" column="role_desc"&gt;&lt;/result&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;!-- 查询所有 --&gt; &lt;select id="findAll" resultMap="userMap"&gt; select u.*,r.id as rid,r.role_name,r.role_desc from user u left outer join user_role ur on u.id = ur.uid left outer join role r on r.id = ur.rid &lt;/select&gt; &lt;!-- 根据id查询用户 --&gt; &lt;select id="findById" parameterType="INT" resultType="user"&gt; select * from user where id = #&#123;uid&#125; &lt;/select&gt;&lt;/mapper&gt;]]></content>
      <categories>
        <category>mybatis</category>
      </categories>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring集成shiro简单版]]></title>
    <url>%2F2018%2F10%2F04%2Fspring%E9%9B%86%E6%88%90shiro%E7%AE%80%E5%8D%95%E7%89%88%2F</url>
    <content type="text"><![CDATA[这里没有用自定义的Realm，使用了JdbcRealm。spring集成shiro简单版，坑比较多。1.创建maven项目，引入依赖 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;dependencies&gt; &lt;!-- javaee依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-core&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.16&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- json数据 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2.web.xml配置shirofilter12345678 &lt;filter&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;shiroFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 3.web.xml监听配置文件12345678910 &lt;!-- 配置监听器加载spring --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt;&lt;!-- 读取配置文件 --&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt;&lt;/context-param&gt; 4.spring.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"&gt; &lt;bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean"&gt; &lt;!--注入securityManager--&gt; &lt;property name="securityManager" ref="securityManager"&gt;&lt;/property&gt; &lt;!-- 要求登录时的链接(可根据项目的URL进行替换),非必须的属性,默认会自动寻找Web工程根目录下的"/login.jsp"页面 --&gt; &lt;property name="loginUrl" value="/html/login.html"&gt;&lt;/property&gt; &lt;!--未认证跳转页面--&gt; &lt;property name="unauthorizedUrl" value="error.html"&gt;&lt;/property&gt; &lt;!--过滤器链--&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; &lt;!--从上往下过滤--&gt; /shiro/html/login.html = anon&lt;!--无需认证--&gt; /shiro/user/login = anon /* = authc&lt;!--需要认证--&gt; &lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 这个东西很有用,可以读取配置文件不用写死--&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;!--dbconfig.properties 数据库连接信息--&gt; &lt;value&gt;classpath:dbconfig.properties&lt;/value&gt; &lt;value&gt;classpath:shiroQuery.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- dataSource --&gt; &lt;bean class="com.alibaba.druid.pool.DruidDataSource" id="dataSource"&gt; &lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;username&#125;"&gt;&lt;/property&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;url&#125;"&gt;&lt;/property&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--创建securityManager--&gt; &lt;bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager"&gt; &lt;!--注入jdbcRealm--&gt; &lt;property name="realm" ref="jdbcRealm"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置密码匹配对象 --&gt; &lt;bean id="credentialsMatcher" class="org.apache.shiro.authc.credential.HashedCredentialsMatcher"&gt; &lt;!--加密方式--&gt; &lt;property name="hashAlgorithmName" value="md5"&gt;&lt;/property&gt; &lt;!--加密次数--&gt; &lt;property name="hashIterations" value="1"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id="jdbcRealm" class="org.apache.shiro.realm.jdbc.JdbcRealm"&gt; &lt;property name="credentialsMatcher" ref="credentialsMatcher"&gt;&lt;/property&gt; &lt;property name="permissionsLookupEnabled" value="true"&gt;&lt;/property&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!--认证校验语句--&gt; &lt;!--下面的sql语句都从properties中读取--&gt; &lt;property name="authenticationQuery" value="$&#123;AUTHENTICATION_QUERY&#125;"&gt;&lt;/property&gt; &lt;!--校验用户下是否有对应角色--&gt; &lt;property name="userRolesQuery" value="$&#123;USER_ROLES_QUERY&#125;"&gt;&lt;/property&gt; &lt;!--验证角色是否有对应的权限.--&gt; &lt;property name="permissionsQuery" value="$&#123;PERMISSIONS_QUERY&#125;"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 5.spring-mvc.xml123456789101112131415161718192021&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"&gt; &lt;!--扫描controller--&gt; &lt;context:component-scan base-package="controller"&gt;&lt;/context:component-scan&gt; &lt;!--开启注解--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt; &lt;!-- 解除servlet对静态资源文件访问的限制 --&gt; &lt;mvc:default-servlet-handler/&gt;&lt;/beans&gt; 这里很坑！刚开始的时候login.html直接建在webapp下。访问html时，明明配置了 1&lt;mvc:default-servlet-handler/&gt; 发现不能访问login.html，反而去访问controller中的login方法，原因是过滤器链没有放行就去找了loginUrl然后就转到controller了具体过程不是很明了。在webapp下新建文件夹html，把login.html放到html文件夹下就可以访问了。同时因为路径都变了修改了shiro的过滤器链，shiro为虚拟路径。 这里还有controller的访问路径问题。一开始的时候controller类上没有@RequestMapping(“/user”) ，但是提交表单的时候/shiro/user/login = anon没有放行，和上面的是一样的问题，反而被拦截到了loginUrl，无奈加了@RequestMapping(“/user”)之后可以放行了。 无论是静态资源还是controller访问都不能直接放在虚拟路径下。123456789101112&lt;property name="loginUrl" value="/html/login.html"&gt;&lt;/property&gt; &lt;!--未认证跳转页面--&gt; &lt;property name="unauthorizedUrl" value="error.html"&gt;&lt;/property&gt; &lt;!--过滤器链--&gt; &lt;property name="filterChainDefinitions"&gt; &lt;value&gt; &lt;!--从上往下过滤--&gt; /shiro/html/login.html = anon&lt;!--无需认证--&gt; /shiro/user/login = anon /* = authc&lt;!--需要认证--&gt; &lt;/value&gt; &lt;/property&gt; 6.login.html1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;登录页面&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="/shiro/user/login" method="post"&gt; 用户名:&lt;input type="text" name="username"&gt;&lt;br&gt; 密码:&lt;input type="password" name="password"&gt;&lt;br&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 7.dbconfig.properties1234567url=jdbc:mysql:///shiro_testdriverClassName=com.mysql.jdbc.Driverusername=rootpassword=123maxActive=20minIdle=10maxWait=60000 8.shiroQuery.properties123AUTHENTICATION_QUERY=select password from users where username = ?USER_ROLES_QUERY=select role_name from user_roles where username = ?PERMISSIONS_QUERY=select permission from roles_permissions where role_name = ?&quot; 9.实体类12345678@Getter@Setter@ToStringpublic class User &#123; private Integer id; private String username; private String password;&#125; 10.controller这里是根据catch的错误类型来判断是什么问题，然后返回对应信息。 要注意的是由于使用了MD5加密，所以数据库中的密码要用MD5加密后的数据。 下面很多错误都没有遇到过，测试时主要是UnknownAccountException和IncorrectCredentialsException。 12345678910111213141516171819202122232425262728293031@Controller@RequestMapping("/user")public class UserController &#123; @RequestMapping(value = "/login",produces = "application/json;charset=utf-8") @ResponseBody public String login(User user)&#123; try&#123; Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(user.getUsername(),user.getPassword()); subject.login(token); System.out.println(user); &#125;catch (UnknownAccountException e)&#123; return "账号不存在"; &#125;catch (IncorrectCredentialsException e)&#123; return "密码错误"; &#125;catch (ExcessiveAttemptsException e)&#123; return "登陆次数过多"; &#125;catch (LockedAccountException e)&#123; return "账户已被锁定"; &#125;catch (DisabledAccountException e)&#123; return "账户已经被禁用"; &#125;catch (ExpiredCredentialsException e)&#123; return "账户已经过期"; &#125;catch (UnauthorizedException e)&#123; return "没有授权"; &#125; return "登录成功"; &#125;&#125;]]></content>
      <categories>
        <category>shiro</category>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>shiro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis-plus操作示例]]></title>
    <url>%2F2018%2F09%2F30%2Fmybatis-plus%E6%93%8D%E4%BD%9C%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[实体类映射12345678910111213@Getter@Setter@ToString@TableName("person")public class Person &#123; @TableId private Integer pid; private String pname; private String page;&#125; insert1234567@Testpublic void fun2()&#123; Person person = new Person(); person.setPage("10"); person.setPname("南北"); personMapper.insert(person);&#125; deleteById1234@Testpublic void fun3()&#123; personMapper.deleteById(3);&#125; deleteByMap12345678@Testpublic void fun4()&#123; Map&lt;String, Object&gt; columnMap = new HashMap&lt;&gt;(); String name = "南北"; columnMap.put("pname",name); //删除所有pname列是南北的数据 personMapper.deleteByMap(columnMap);&#125; deleteUpdateWrapper为更新操作的条件构造器，父类是AbstractWrapper allEq有一个入参是Map&lt;R, V&gt; paramsR为泛型，在普通wrapper中是String，他这里区分了两种wrapper，一种是普通的 一种是LambdaWrapper 在LambdaWrapper中是R泛型为函数 (例:Entity::getId,Entity为实体类,getId为字段id的getMethod) R表示数据库字段，V表示值。 12345678910111213//删除名字是南北同时年龄是8的数据@Testpublic void fun5()&#123; Map&lt;String, Object&gt; columnMap = new HashMap&lt;&gt;(); String name = "南北"; columnMap.put("pname",name); columnMap.put("page",8); int delete = personMapper.delete( new UpdateWrapper&lt;Person&gt;() .allEq(columnMap) ); System.out.println(delete);&#125; (k,v) -&gt; k.indexOf(“n”) &gt; 0会过滤掉不含n的条件。即下面的page并没有加入到条件构造中。 123456789101112@Testpublic void fun6()&#123; Map&lt;String, Object&gt; columnMap = new HashMap&lt;&gt;(); String name = "南北"; columnMap.put("pname",name); columnMap.put("page",10); int delete = personMapper.delete( new UpdateWrapper&lt;Person&gt;() .allEq((k,v) -&gt; k.indexOf("n") &gt; 0,columnMap) ); System.out.println(delete);&#125; 12345678@Testpublic void fun7()&#123; personMapper.delete( new UpdateWrapper&lt;Person&gt;() //删除pname是南北的数据 .eq("pname","南北") );&#125; 12345678@Testpublic void fun8()&#123; personMapper.delete( new UpdateWrapper&lt;Person&gt;() //删除pname不是左右的数据 .ne("pname","左右") );&#125; 12345678@Testpublic void fun9()&#123; personMapper.delete( new UpdateWrapper&lt;Person&gt;() //删除page&gt;15的数据 .gt("page",15) );&#125; 12345678@Testpublic void fun10()&#123; personMapper.delete( new UpdateWrapper&lt;Person&gt;() //删除page在15到20之间的数据，包含头和包含尾 .between("page",15,20) );&#125; 12345678@Testpublic void fun11()&#123; personMapper.delete( new UpdateWrapper&lt;Person&gt;() //删除pname包含东的数据 .like("pname","东") );&#125; 123456789@Testpublic void fun12()&#123; personMapper.delete( new UpdateWrapper&lt;Person&gt;() //pname like '%东' //删除pname以东结尾的数据 .likeLeft("pname","东") );&#125; 12345678@Testpublic void fun13()&#123; personMapper.delete( new UpdateWrapper&lt;Person&gt;() //删除pname为null的数据 .isNull("pname") );&#125; 后面的条件构造方式省略 deleteBatchIds根据id批量删除，把id放到集合中 1234567@Testpublic void fun14()&#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList(); arrayList.add(16); arrayList.add(18); personMapper.deleteBatchIds(arrayList);&#125; updateById根据id更新数据 12345678@Testpublic void fun15()&#123; Person person = new Person(); person.setPname("东西"); person.setPage("10"); person.setPid(20); personMapper.updateById(person);&#125; update更新pname以东开头的数据。 12345678910@Testpublic void fun16()&#123; Person person = new Person(); person.setPname("南北"); person.setPage("10"); personMapper.update(person, new UpdateWrapper&lt;Person&gt;() .likeRight("pname","东") );&#125; selectById12345@Testpublic void fun17()&#123; Person person = personMapper.selectById(13); System.out.println(person);&#125; selectBatchIds批量根据id查询，把id放到集合中即可 12345678910@Testpublic void fun18()&#123; ArrayList&lt;Integer&gt; arrayList = new ArrayList(); arrayList.add(13); arrayList.add(20); List&lt;Person&gt; peoples = personMapper.selectBatchIds(arrayList); for (Person people : peoples) &#123; System.out.println(people); &#125;&#125; selectByMap封装成map查询 12345678910@Testpublic void fun19()&#123; Map&lt;String, Object&gt; columnMap = new HashMap&lt;&gt;(); String name = "南北"; columnMap.put("pname",name); columnMap.put("page",10); List&lt;Person&gt; peoples = personMapper.selectByMap(columnMap); System.out.println(peoples.size());&#125; selectOne查询一条记录，如果条件导致查询到多条记录，会报错!! 123456789@Testpublic void fun20()&#123; Person person = personMapper.selectOne( new QueryWrapper&lt;Person&gt;() .likeRight("pname", "东") ); System.out.println(person);&#125; selectCount查询记录 123456789@Testpublic void fun21()&#123; Integer integer = personMapper.selectCount( new QueryWrapper&lt;Person&gt;() .likeRight("pname", "东") ); System.out.println(integer);&#125; selectList123456789101112@Testpublic void fun22()&#123; List&lt;Person&gt; peoples = personMapper.selectList( new QueryWrapper&lt;Person&gt;() .likeRight("pname", "东") ); for (Person people : peoples) &#123; System.out.println(people); &#125;&#125; selectMaps把结果封装成map 1234567891011121314@Testpublic void fun23()&#123; List&lt;Map&lt;String, Object&gt;&gt; maps = personMapper.selectMaps( new QueryWrapper&lt;Person&gt;() .likeRight("pname", "东") ); for (Map&lt;String, Object&gt; map : maps) &#123; Set&lt;String&gt; keySet = map.keySet(); for (String key : keySet) &#123; Object o = map.get(key); System.out.println(key+" : "+o.toString()); &#125; &#125;&#125; 打印结果 123456pname : 东西pid : 21page : 15pname : 东北pid : 23page : 20 selectObjs12345678910@Testpublic void fun24()&#123; List&lt;Object&gt; objects = personMapper.selectObjs( new QueryWrapper&lt;Person&gt;() .likeRight("pname", "东") ); for (Object object : objects) &#123; System.out.println(object.toString()); &#125;&#125; 12Person(pid=21, pname=东西, page=15)Person(pid=23, pname=东北, page=20) selectPage分页 123456789@Test public void fun25()&#123; IPage&lt;Person&gt; iPage = personMapper.selectPage(new Page&lt;&gt;(1, 5), new QueryWrapper&lt;Person&gt;() .likeRight("pname", "东") ); System.out.println(iPage.getSize()); &#125; 这里的分页有点懵，另外在开一篇介绍mybatis-plus的分页。]]></content>
      <categories>
        <category>mybatis-plus</category>
      </categories>
      <tags>
        <tag>mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis-plus条件构造器]]></title>
    <url>%2F2018%2F09%2F30%2Fmybatis-plus%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[你可能在网上看到很多EntityWrapper，这里却没用，因为从2.x升级到3.xEntityWrapper已经废弃Wrapper分为QueryWrapper、UpdateWrapper、LambdaQueryWrapper、LambdaUpdateWrapper了。 以下出现的第一个入参boolean condition表示该条件是否加入最后生成的sql中 以下代码块内的多个方法均为从上往下补全个别boolean类型的入参,默认为true 以下出现的泛型This均为具体使用的Wrapper的实例 以下方法在入参中出现的R为泛型,在普通wrapper中是String,在LambdaWrapper中是函数(例:Entity::getId,Entity为实体类,getId为字段id的getMethod) 以下方法入参中的R column均表示数据库字段,当R为String时则为数据库字段名(字段名是数据库关键字的自己用转义符包裹!)!而不是实体类数据字段名!!! 以下举例均为使用普通wrapper,入参为Map和List的均以json形式表现! 使用中如果入参的Map或者List为空,则不会加入最后生成的sql中!!! AbstractWrapper12QueryWrapper(LambdaQueryWrapper) 和 UpdateWrapper(LambdaUpdateWrapper) 的父类用于生成 sql 的 where 条件, entity 属性也用于生成 sql 的 where 条件 allEq123allEq(Map&lt;R, V&gt; params)allEq(Map&lt;R, V&gt; params, boolean null2IsNull)allEq(boolean condition, Map&lt;R, V&gt; params, boolean null2IsNull) 全部eq(或个别isNull) 1234个别参数说明:params : key为数据库字段名,value为字段值null2IsNull : 为true则在map的value为null时调用 isNull 方法,为false时则忽略 value为null的 例1: allEq({id:1,name:&quot;老王&quot;,age:null})—&gt;id = 1 and name = &#39;老王&#39; and age is null 例2: allEq({id:1,name:&quot;老王&quot;,age:null}, false)—&gt;id = 1 and name = &#39;老王&#39; 123allEq(BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params)allEq(BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params, boolean null2IsNull)allEq(boolean condition, BiPredicate&lt;R, V&gt; filter, Map&lt;R, V&gt; params, boolean null2IsNull) filter : 过滤函数,是否允许字段传入比对条件中 params 与 null2IsNull : 同上 例1: allEq((k,v) -&gt; k.indexOf(&quot;a&quot;) &gt; 0, {id:1,name:&quot;老王&quot;,age:null})—&gt;name = &#39;老王&#39; and age is null 例2: allEq((k,v) -&gt; k.indexOf(&quot;a&quot;) &gt; 0, {id:1,name:&quot;老王&quot;,age:null}, false)—&gt;name = &#39;老王&#39; eq12eq(R column, Object val)eq(boolean condition, R column, Object val) 等于 = 例: eq(&quot;name&quot;, &quot;老王&quot;)—&gt;name = &#39;老王&#39; ne12ne(R column, Object val)ne(boolean condition, R column, Object val) 不等于 &lt;&gt; 例: ne(&quot;name&quot;, &quot;老王&quot;)—&gt;name &lt;&gt; &#39;老王&#39; gt12gt(R column, Object val)gt(boolean condition, R column, Object val) 大于 &gt; 例: gt(&quot;age&quot;, 18)—&gt;age &gt; 18 ge12ge(R column, Object val)ge(boolean condition, R column, Object val) 大于等于 &gt;= 例: ge(&quot;age&quot;, 18)—&gt;age &gt;= 18 lt12lt(R column, Object val)lt(boolean condition, R column, Object val) 小于 &lt; 例: lt(&quot;age&quot;, 18)—&gt;age &lt; 18 le12le(R column, Object val)le(boolean condition, R column, Object val) 小于等于 &lt;= 例: le(&quot;age&quot;, 18)—&gt;age &lt;= 18 between12between(R column, Object val1, Object val2)between(boolean condition, R column, Object val1, Object val2) BETWEEN 值1 AND 值2 例: between(&quot;age&quot;, 18, 30)—&gt;age between 18 and 30 notBetween12notBetween(R column, Object val1, Object val2)notBetween(boolean condition, R column, Object val1, Object val2) NOT BETWEEN 值1 AND 值2 例: notBetween(&quot;age&quot;, 18, 30)—&gt;age not between 18 and 30 like12like(R column, Object val)like(boolean condition, R column, Object val) LIKE ‘%值%’ 例: like(&quot;name&quot;, &quot;王&quot;)—&gt;name like &#39;%王%&#39; notLike12notLike(R column, Object val)notLike(boolean condition, R column, Object val) NOT LIKE ‘%值%’ 例: notLike(&quot;name&quot;, &quot;王&quot;)—&gt;name not like &#39;%王%&#39; likeLeft12likeLeft(R column, Object val)likeLeft(boolean condition, R column, Object val) LIKE ‘%值’ 例: likeLeft(&quot;name&quot;, &quot;王&quot;)—&gt;name like &#39;%王&#39; likeRight12likeRight(R column, Object val)likeRight(boolean condition, R column, Object val) LIKE ‘值%’ 例: likeRight(&quot;name&quot;, &quot;王&quot;)—&gt;name like &#39;王%&#39; isNull12isNull(R column)isNull(boolean condition, R column) 字段 IS NULL 例: isNull(&quot;name&quot;)—&gt;name is null isNotNull12isNotNull(R column)isNotNull(boolean condition, R column) 字段 IS NULL 例: isNotNull(&quot;name&quot;)—&gt;name is not null in12in(R column, Collection&lt;?&gt; value)in(boolean condition, R column, Collection&lt;?&gt; value) 字段 IN (value.get(0), value.get(1), …) 例: in(&quot;age&quot;,{1,2,3})—&gt;age in (1,2,3) 12in(R column, Object... values)in(boolean condition, R column, Object... values) 字段 IN (v0, v1, …) 例: in(&quot;age&quot;, 1, 2, 3)—&gt;age in (1,2,3) notIn12notIn(R column, Collection&lt;?&gt; value)notIn(boolean condition, R column, Collection&lt;?&gt; value) 字段 IN (value.get(0), value.get(1), …) 例: notIn(&quot;age&quot;,{1,2,3})—&gt;age not in (1,2,3) 12notIn(R column, Object... values)notIn(boolean condition, R column, Object... values) 字段 NOT IN (v0, v1, …) 例: notIn(&quot;age&quot;, 1, 2, 3)—&gt;age not in (1,2,3) inSql12inSql(R column, String inValue)inSql(boolean condition, R column, String inValue) 字段 IN ( sql语句 ) 例: inSql(&quot;age&quot;, &quot;1,2,3,4,5,6&quot;)—&gt;age in (1,2,3,4,5,6) 例: inSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)—&gt;id in (select id from table where id &lt; 3) notInSql12notInSql(R column, String inValue)notInSql(boolean condition, R column, String inValue) 字段 NOT IN ( sql语句 ) 例: notInSql(&quot;age&quot;, &quot;1,2,3,4,5,6&quot;)—&gt;age not in (1,2,3,4,5,6) 例: notInSql(&quot;id&quot;, &quot;select id from table where id &lt; 3&quot;)—&gt;age not in (select id from table where id &lt; 3) groupBy12groupBy(R... columns)groupBy(boolean condition, R... columns) 分组：GROUP BY 字段, … 例: groupBy(&quot;id&quot;, &quot;name&quot;)—&gt;group by id,name orderByAsc12orderByAsc(R... columns)orderByAsc(boolean condition, R... columns) 排序：ORDER BY 字段, … ASC 例: orderByAsc(&quot;id&quot;, &quot;name&quot;)—&gt;order by id ASC,name ASC orderByDesc12orderByDesc(R... columns)orderByDesc(boolean condition, R... columns) 排序：ORDER BY 字段, … DESC 例: orderByDesc(&quot;id&quot;, &quot;name&quot;)—&gt;order by id DESC,name DESC orderBy1orderBy(boolean condition, boolean isAsc, R... columns) 排序：ORDER BY 字段, … 例: orderBy(true, true, &quot;id&quot;, &quot;name&quot;)—&gt;order by id ASC,name ASC having12having(String sqlHaving, Object... params)having(boolean condition, String sqlHaving, Object... params) HAVING ( sql语句 ) 例: having(&quot;sum(age) &gt; 10&quot;)—&gt;having sum(age) &gt; 10 例: having(&quot;sum(age) &gt; {0}&quot;, 11)—&gt;having sum(age) &gt; 11 or12or()or(boolean condition) 拼接 OR 注意事项: 主动调用or表示紧接着下一个方法不是用and连接!(不调用or则默认为使用and连接) 例: eq(&quot;id&quot;,1).or().eq(&quot;name&quot;,&quot;老王&quot;)—&gt;id = 1 or name = &#39;老王&#39; 12or(Function&lt;This, This&gt; func)or(boolean condition, Function&lt;This, This&gt; func) OR 嵌套 例: or(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))—&gt;or (name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;) and12and(Function&lt;This, This&gt; func)and(boolean condition, Function&lt;This, This&gt; func) AND 嵌套 例: and(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))—&gt;and (name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;) apply12apply(String sqlHaving, Object... params)apply(boolean condition, String sqlHaving, Object... params) 拼接 sql 注意事项: 该方法可用于数据库函数动态入参的params对应前面sqlHaving内部的{index}部分.这样是不会有sql注入风险的,反之会有! 例: apply(&quot;id = 1&quot;)—&gt;having sum(age) &gt; 10 例: apply(&quot;date_format(dateColumn,&#39;%Y-%m-%d&#39;) = &#39;2008-08-08&#39;&quot;)—&gt;date_format(dateColumn,&#39;%Y-%m-%d&#39;) = &#39;2008-08-08&#39;&quot;) 例: apply(&quot;date_format(dateColumn,&#39;%Y-%m-%d&#39;) = {0}&quot;, &quot;2008-08-08&quot;)—&gt;date_format(dateColumn,&#39;%Y-%m-%d&#39;) = &#39;2008-08-08&#39;&quot;) last12last(String lastSql)last(boolean condition, String lastSql) 无视优化规则直接拼接到 sql 的最后 注意事项: 只能调用一次,多次调用以最后一次为准有sql注入的风险,请谨慎使用 例: last(&quot;limit 1&quot;) exists12exists(String existsSql)exists(boolean condition, String existsSql) 拼接 EXISTS ( sql语句 ) 例: exists(&quot;select id from table where age = 1&quot;)—&gt;exists (select id from table where age = 1) notExists12notExists(String existsSql)notExists(boolean condition, String existsSql) 拼接 NOT EXISTS ( sql语句 ) 例: notExists(&quot;select id from table where age = 1&quot;)—&gt;not exists (select id from table where age = 1) nested12nested(Function&lt;This, This&gt; func)nested(boolean condition, Function&lt;This, This&gt; func) 正常嵌套 不带 AND 或者 OR 例: nested(i -&gt; i.eq(&quot;name&quot;, &quot;李白&quot;).ne(&quot;status&quot;, &quot;活着&quot;))—&gt;(name = &#39;李白&#39; and status &lt;&gt; &#39;活着&#39;) QueryWrapper说明: 继承自 AbstractWrapper ,自身的内部属性 entity 也用于生成 where 条件及 LambdaQueryWrapper, LambdaQueryWrapper 不能 new 出来,只能通过 new QueryWrapper().lambda() 方法获取! select12select(String... sqlSelect)select(Predicate&lt;TableFieldInfo&gt; predicate) 设置查询字段 说明: 以上方法为2个方法.第二个方法为:过滤查询字段(主键除外),调用前需要wrapper内的entity属性有值!3.0.3开始,使用第二个方法优先级最高,同一方法重复调用只有最后一次有效!两个方法都调用以第二个方法为准!预计3.0.8及之后,两个方法重复调用只有最后一次有效! 例: select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;) 例: select(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;) UpdateWrapper说明: 继承自 AbstractWrapper ,自身的内部属性 entity 也用于生成 where 条件及 LambdaUpdateWrapper, LambdaUpdateWrapper 不能 new 出来,只能通过 new UpdateWrapper().lambda() 方法获取! set12set(String column, Object val)set(boolean condition, String column, Object val) SQL SET 字段 例: set(&quot;name&quot;, &quot;老李头&quot;) 例: set(&quot;name&quot;, &quot;&quot;)—&gt;数据库字段值变为空字符串 例: set(&quot;name&quot;, null)—&gt;数据库字段值变为null setSql1setSql(String sql) 设置 SET 部分 SQL 例: set(&quot;name = &#39;老李头&#39;) lambda 获取 LambdaWrapper在QueryWrapper中是获取LambdaQueryWrapper在UpdateWrapper中是获取LambdaUpdateWrapper]]></content>
      <categories>
        <category>mybatis-plus</category>
      </categories>
      <tags>
        <tag>mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis-PlusCRUD操作]]></title>
    <url>%2F2018%2F09%2F30%2FMyBatis-PlusCRUD%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[Mapper CRUD 接口 通用 CRUD 封装BaseMapper 接口，为 Mybatis-Plus 启动时自动解析实体表关系映射转换为 Mybatis 内部对象注入容器 泛型 T 为任意实体对象 参数 Serializable 为任意类型主键 Mybatis-Plus 不推荐使用复合主键约定每一张表都有自己的唯一 id 主键 对象 Wrapper 为 条件构造器 insert123456789/** * &lt;p&gt; * 插入一条记录 * &lt;/p&gt; * * @param entity 实体对象 * @return 插入成功记录数 */int insert(T entity); deleteById123456789/** * &lt;p&gt; * 根据 ID 删除 * &lt;/p&gt; * * @param id 主键ID * @return 删除成功记录数 */int deleteById(Serializable id); deleteByMap123456789/** * &lt;p&gt; * 根据 columnMap 条件，删除记录 * &lt;/p&gt; * * @param columnMap 表字段 map 对象 * @return 删除成功记录数 */int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); delete123456789/** * &lt;p&gt; * 根据 entity 条件，删除记录 * &lt;/p&gt; * * @param queryWrapper 实体对象封装操作类（可以为 null） * @return 删除成功记录数 */int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); deleteBatchIds123456789/** * &lt;p&gt; * 删除（根据ID 批量删除） * &lt;/p&gt; * * @param idList 主键ID列表(不能为 null 以及 empty) * @return 删除成功记录数 */int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList); updateById123456789/** * &lt;p&gt; * 根据 ID 修改 * &lt;/p&gt; * * @param entity 实体对象 * @return 修改成功记录数 */int updateById(@Param(Constants.ENTITY) T entity); update12345678910/** * &lt;p&gt; * 根据 whereEntity 条件，更新记录 * &lt;/p&gt; * * @param entity 实体对象 (set 条件值,不能为 null) * @param updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where 语句） * @return 修改成功记录数 */int update(@Param(Constants.ENTITY) T entity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; updateWrapper); selectById123456789/** * &lt;p&gt; * 根据 ID 查询 * &lt;/p&gt; * * @param id 主键ID * @return 实体 */T selectById(Serializable id); selectBatchIds123456789/** * &lt;p&gt; * 查询（根据ID 批量查询） * &lt;/p&gt; * * @param idList 主键ID列表(不能为 null 以及 empty) * @return 实体集合 */List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList); selectByMap123456789/** * &lt;p&gt; * 查询（根据 columnMap 条件） * &lt;/p&gt; * * @param columnMap 表字段 map 对象 * @return 实体集合 */List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); selectOne123456789/** * &lt;p&gt; * 根据 entity 条件，查询一条记录 * &lt;/p&gt; * * @param queryWrapper 实体对象 * @return 实体 */T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); selectCount123456789/** * &lt;p&gt; * 根据 Wrapper 条件，查询总记录数 * &lt;/p&gt; * * @param queryWrapper 实体对象 * @return 满足条件记录数 */Integer selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); selectList123456789/** * &lt;p&gt; * 根据 entity 条件，查询全部记录 * &lt;/p&gt; * * @param queryWrapper 实体对象封装操作类（可以为 null） * @return 实体集合 */List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); selectMaps123456789/** * &lt;p&gt; * 根据 Wrapper 条件，查询全部记录 * &lt;/p&gt; * * @param queryWrapper 实体对象封装操作类（可以为 null） * @return 字段映射对象 Map 集合 */List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); selectObjs12345678910/** * &lt;p&gt; * 根据 Wrapper 条件，查询全部记录 * 注意： 只返回第一个字段的值 * &lt;/p&gt; * * @param queryWrapper 实体对象封装操作类（可以为 null） * @return 字段映射对象集合 */List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); selectPage12345678910/** * &lt;p&gt; * 根据 entity 条件，查询全部记录（并翻页） * &lt;/p&gt; * * @param page 分页查询条件（可以为 RowBounds.DEFAULT） * @param queryWrapper 实体对象封装操作类（可以为 null） * @return 实体分页对象 */IPage&lt;T&gt; selectPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); selectMapsPage12345678910/** * &lt;p&gt; * 根据 Wrapper 条件，查询全部记录（并翻页） * &lt;/p&gt; * * @param page 分页查询条件 * @param queryWrapper 实体对象封装操作类 * @return 字段映射对象 Map 分页对象 */IPage&lt;Map&lt;String, Object&gt;&gt; selectMapsPage(IPage&lt;T&gt; page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper)]]></content>
      <categories>
        <category>mybatis-plus</category>
      </categories>
      <tags>
        <tag>mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Springboot结合Swagger2构建RESTfulAPI文档]]></title>
    <url>%2F2018%2F09%2F28%2FSpringboot%E7%BB%93%E5%90%88Swagger2%E6%9E%84%E5%BB%BARESTfulAPI%E6%96%87%E6%A1%A3%2F</url>
    <content type="text"><![CDATA[Swagger2类该类要和springboot类同级 12345678910111213141516171819202122@Configuration//让Spring来加载该类配置@EnableSwagger2//注解来启用Swagger2。public class Swagger2 &#123; @Bean public Docket createRestApi() &#123;//通过createRestApi函数创建Docket的Bean return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .select()//select()函数返回一个ApiSelectorBuilder实例用来控制哪些接口暴露给Swagger来展现 .apis(RequestHandlerSelectors.basePackage("springboot.demo.controller"))//扫描的包路径 .paths(PathSelectors.any()) .build(); &#125; //创建该Api的基本信息 private ApiInfo apiInfo() &#123; return new ApiInfoBuilder() .title("RESTful APIs") .description("Springboot中使用Swagger2构建RESTful APIs") .contact("天下不易其乐") .version("1.0") .build(); &#125;&#125; 修改controller代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546@RestController@RequestMapping("/student")public class RestFulController &#123; @Autowired private StudentService studentService; @ApiOperation(value="获取学生列表", notes="获取学生列表") @RequestMapping(method = RequestMethod.GET) public List&lt;Student&gt; getStudentList()&#123; return studentService.getStudentList(); &#125; @ApiOperation(value="保存学生", notes="根据Student对象保存学生") @ApiImplicitParam(name = "student", value = "学生详细实体student", required = true, dataType = "Student") @RequestMapping(method = RequestMethod.POST) public String postStudent(Student student)&#123; //System.out.println(student); studentService.save(student); return "success"; &#125; @ApiOperation(value="获取学生信息", notes="根据id获得学生详细信息") @ApiImplicitParam(name = "id", value = "学生id", required = true, dataType = "Integer") @RequestMapping(value = "/&#123;id&#125;",method = RequestMethod.GET) public Student getStudent(@PathVariable Integer id)&#123; return studentService.getStudent(id); &#125; @ApiOperation(value="更新学生信息", notes="根据id更新学生详细信息") @ApiImplicitParam(name = "id", value = "学生id", required = true, dataType = "Integer") @RequestMapping(value = "/&#123;id&#125;",method = RequestMethod.PUT) public String putStudent(@PathVariable Integer id,Student student)&#123; studentService.updateStudnet(id,student); return "success"; &#125; @ApiOperation(value="删除学生", notes="根据id删除学生") @ApiImplicitParam(name = "id", value = "学生id", required = true, dataType = "Integer") @RequestMapping(value = "/&#123;id&#125;",method = RequestMethod.DELETE) public String deleteStudent(@PathVariable Integer id)&#123; studentService.deleteStudent(id); return "success"; &#125;&#125; 启动Spring Boot程序访问：http://localhost:8080/swagger-ui.html 下面截取几个方法说明。]]></content>
      <categories>
        <category>swagger2</category>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>swagger2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结合Project Structure理解idea部署web项目]]></title>
    <url>%2F2018%2F09%2F13%2F%E7%BB%93%E5%90%88Project%20Structure%E7%90%86%E8%A7%A3idea%E9%83%A8%E7%BD%B2web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[idea的部署方式1.编译，IDEA在保存/自动保存后不会做编译，不像Eclipse的保存即编译，因此在运行server前会做一次编译。编译后class文件存放在指定的module编译输出目录下。2.根据artifact中的设定对目录结构进行创建；3.拷贝web资源的根目录下的所有文件到artifact的目录下；4.拷贝编译输出目录下的classes目录到artifact下的WEB-INF下；5.拷贝lib目录下所需的jar包到artifact下的WEB_INF下；6.运行server，运行成功后，如有需要，会自动打开浏览器访问指定url。以这个demo为例：artifact的打包输出路径是： 项目运行时： 找到对应文件夹]]></content>
      <categories>
        <category>原理</category>
      </categories>
      <tags>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解SSM框架搭建3]]></title>
    <url>%2F2018%2F09%2F08%2F%E6%B3%A8%E8%A7%A3SSM%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA3%2F</url>
    <content type="text"><![CDATA[在用注解代替了spring-mybatis.xml配置和springmvc配置后，剩下的就是web.xml了web.xml的代替比较复杂。 web.xml的代替javax.servlet.ServletContainerInitializer接口:在servlet3.0规范中，提供了一个 javax.servlet.ServletContainerInitializer接口，来帮助我们做web应用的初始化操作，例如动态注册Servelt、Filter、Listener等 servlet3.0规范中， web容器在启动时可以通过 ServletContainerInitializer进行第三方组件初始化工作。 这个接口是javax.servlet下的。官方的解释是这样的：为了支持可以不使用web.xml。提供了ServletContainerInitializer，它可以通过SPI机制，当启动web容器的时候，会自动到添加的相应jar包下找到META-INF/services下以ServletContainerInitializer的全路径名称命名的文件，它的内容为ServletContainerInitializer实现类的全路径，将它们实例化。 当框架要使用 ServletContainerInitializer 就必须在对应的jar包的METAINF/services 目录创建一个名为 javax.servlet.ServletContainerInitializer 的文件。文件内容指定具体的ServletContainerInitializer实现类。 spring的ServletContainerInitializer实现类在springmvc中使用的是SpringServletContainerInitializer。 SpringServletContainerInitializer所在包内也有javax.servlet.ServletContainerInitializer 的文件。 所以顺序是：web容器加载=》spring-web下的javax.servlet.ServletContainerInitializer，文件内容为其实现类即 SpringServletContainerInitializer。然后就会调用SpringServletContainerInitializer的onStartup。 123456789101112131415161718192021222324252627282930313233343536373839@HandlesTypes(WebApplicationInitializer.class)public class SpringServletContainerInitializer implements ServletContainerInitializer &#123; public void onStartup(@Nullable Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext) throws ServletException &#123; List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;&gt;(); //判断set集合是否为空 if (webAppInitializerClasses != null) &#123; for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123; // Be defensive: Some servlet containers provide us with invalid classes, // no matter what @HandlesTypes says... //如果不为空的话，找到这个set中不是接口，不是抽象类，并且是WebApplicationInitializer接口实现类的类，将它们保存到list中。 if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp; WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123; try &#123; initializers.add((WebApplicationInitializer) ReflectionUtils.accessibleConstructor(waiClass).newInstance()); &#125; catch (Throwable ex) &#123; throw new ServletException("Failed to instantiate WebApplicationInitializer class", ex); &#125; &#125; &#125; &#125;//如果没有实现类可以存储，写错误日志 if (initializers.isEmpty()) &#123; servletContext.log("No Spring WebApplicationInitializer types detected on classpath"); return; &#125; servletContext.log(initializers.size() + " Spring WebApplicationInitializers detected on classpath"); AnnotationAwareOrderComparator.sort(initializers); ////便利集合中的实现类，调用实现类的onStartup进行初始化 for (WebApplicationInitializer initializer : initializers) &#123; initializer.onStartup(servletContext); &#125;&#125; &#125; 那么SpringServletContainerInitializer的onStartup做了什么呢？： @HandlesTypes，它的作用是将感兴趣的一些类注入到ServletContainerInitializerde。所以SpringServletContainerInitializer将WebApplicationInitializer进行了注入。 onStartup方法其实就是对注入的WebApplicationInitializer集合中，取出所有WebApplicationInitializer的实现类并且执行他们的onStartup方法。 综上我们可以吧WebApplicationInitializer当做Web.xml的替代，通过实现WebApplicationInitializer，在其中可以添加servlet，listener等，在加载Web项目的时候会加载这个接口实现类，从而起到web.xml相同的作用。 网上有些案例用的是XmlWebApplicationContext，这是配置xml文件的方式由于我们已经把spring的xml换成了java类所以用AnnotationConfigWebApplicationContext看表面意思就是有注解的ApplicationContext配置类。注解应该指的就是@Configuration 123456789101112131415161718192021222324252627282930313233343536public class AppConfig implements WebApplicationInitializer &#123; @Override public void onStartup(ServletContext servletContext) throws ServletException &#123; //1.1创建AnnotationConfigWebApplicationContext //网上有些案例用的是XmlWebApplicationContext，这是配置xml文件的方式 //由于我们已经把spring的xml换成了java类所以用AnnotationConfigWebApplicationContext //看表面意思就是有注解的ApplicationContext配置类。注解应该指的就是@Configuration AnnotationConfigWebApplicationContext MvcContext = new AnnotationConfigWebApplicationContext(); //1.2springMVC的注册配置类 MvcContext.register(SpringMvcConfig.class); //1.3创建mvc核心控制器,并将注册的springMVC配置类传入 ServletRegistration.Dynamic dispatcherServlet = servletContext.addServlet("dispatcherServlet", new DispatcherServlet(MvcContext)); //1.4为核心控制器配置拦截路径 dispatcherServlet.addMapping(""); //2.1创建AnnotationConfigWebApplicationContext AnnotationConfigWebApplicationContext springContext = new AnnotationConfigWebApplicationContext(); //2.2spring的配置类 springContext.register(SpringConfig.class); //2.3创建初始化spring容器的监听器,并将注册的spring配置类传入 servletContext.addListener(new ContextLoaderListener(springContext)); //3.1注册解决乱码过滤器,设置字符集utf-8 javax.servlet.FilterRegistration.Dynamic encodingFilter = servletContext.addFilter("characterFilter",new CharacterEncodingFilter("utf-8")); //3.2添加拦截的类型 EnumSet&lt;DispatcherType&gt; enumSet = EnumSet.noneOf(DispatcherType.class); enumSet.add(DispatcherType.REQUEST); enumSet.add(DispatcherType.FORWARD); //3.3添加拦截路径 encodingFilter.addMappingForUrlPatterns(enumSet, true,"/*"); &#125;&#125; 删除web.xml，启动项目访问网址： 参考博文网址https://blog.csdn.net/houysx/article/details/80197344 https://blog.csdn.net/zq17865815296/article/details/79464403]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解SSM框架搭建2]]></title>
    <url>%2F2018%2F09%2F08%2F%E6%B3%A8%E8%A7%A3SSM%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA2%2F</url>
    <content type="text"><![CDATA[紧接注解SSM框架搭建1的service层测试service实现类123456789@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override public User queryUserByName(String name) &#123; return userDao.queryUserByName(name); &#125;&#125; 测试类父类12345@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = &#123;SpringConfig.class&#125;)public class AnnotationSSMTest &#123;&#125; service测试类继承测试类父类123456789public class ServiceTest extends AnnotationSSMTest&#123; @Autowired private UserService userService; @Test public void serviceTest()&#123; User user = userService.queryUserByName("haha"); System.out.println(user); &#125;&#125; 代替springmvc.xml123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"&gt; &lt;!-- 扫描controller --&gt; &lt;context:component-scan base-package="controller"/&gt; &lt;!-- 解除servlet对静态资源文件访问的限制 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 开启SpringMVC注解模式 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &amp;lt;!&amp;ndash; 前缀 &amp;ndash;&amp;gt; &lt;property name="prefix" value="" /&gt;&amp;lt;!&amp;ndash;这里根据自己的建包自己配置&amp;ndash;&amp;gt; &amp;lt;!&amp;ndash; 后缀 &amp;ndash;&amp;gt; &lt;property name="suffix" value=".html" /&gt;&amp;lt;!&amp;ndash;这里根据自己的建包自己配置&amp;ndash;&amp;gt; &lt;/bean&gt;&lt;/beans&gt; SpringMvcConfig代替xml@Configuration代替 1&lt;beans&gt;&lt;/beans&gt; @ComponentScan代替 1&lt;context:component-scan base-package="controller"/&gt; @Bean InternalResourceViewResolver代替 123456&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; //前缀 &lt;property name="prefix" value="" /&gt;//这里根据自己的建包自己配置 //后缀 &lt;property name="suffix" value=".html" /&gt;//这里根据自己的建包自己配置 &lt;/bean&gt; 12345678910111213@Configuration//声明配置类@ComponentScan(basePackages="controller")//扫描controller层@EnableWebMvc//开启处理器映射器、映射器解析器public class SpringMvcConfig &#123; @Bean public InternalResourceViewResolver getInternalResourceViewResolver() &#123; InternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); viewResolver.setSuffix(".html"); viewResolver.setPrefix(""); return viewResolver; &#125;&#125; Controller层测试修改父类测试类如果对ssm单元测试不太了解的话，可以查看我的其他单元测试博文，springboot单元测试以及ssm单元测试等，方法是差不多一样的。 12345678910111213@WebAppConfiguration@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = &#123;SpringConfig.class, SpringMvcConfig.class&#125;)public class AnnotationSSMTest &#123; public MockMvc mockMvc; @Autowired private WebApplicationContext wac; @Before public void setup() &#123; mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); //初始化MockMvc对象 &#125;//这个方法在每个方法执行之前都会执行一遍&#125; Controller层代码1234567891011121314@Controller@RequestMapping("/user")public class UserController &#123; @Autowired private UserService userService; @ResponseBody @RequestMapping("/queryUser/&#123;name&#125;") public User queryUser(@PathVariable String name)&#123; User user = userService.queryUserByName(name); return user; &#125;&#125; Controller单元测试123456789101112131415public class ControllerTest extends AnnotationSSMTest&#123; @Test public void controllerTest() throws Exception &#123; String result = super.mockMvc.perform( MockMvcRequestBuilders.post("http://127.0.0.1:8080/user/queryUser/haha")//请求的url,请求的方法是post ) .andExpect(status().isOk())//返回的状态是200 .andDo(print())//打印出请求和相应的内容 .andReturn().getResponse().getContentAsString();//将相应的数据转换为字符串 System.out.println(result); &#125;&#125; 测试结果 /* {“age”:15,”name”:”haha”} */]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[注解SSM框架搭建1]]></title>
    <url>%2F2018%2F09%2F08%2F%E6%B3%A8%E8%A7%A3SSM%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA1%2F</url>
    <content type="text"><![CDATA[传统的SSM框架要写很多xml和配置文件，使用注解搭建的SSM框架网上资料很少。本人去看了几篇博文，然后根据自己的理解结合xml说明注解搭建SSM框架。对比xml可以比较直观的看出那个注解代替了xml中的那些配置。可能篇幅较长，所以分了几篇来写，这是第一篇。 代替spring-mybatis.xml文件下面是一个常规的spring-mybatis.xml，我们将会用注解去替代他 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package="service"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置数据库properties位置 --&gt; &lt;!--这个配置会报错，注释掉了用下面的--&gt; &lt;!--&lt;context:property-placeholder location="classpath:dbconfig.properties"&gt;&lt;/context:property-placeholder&gt;--&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:dbconfig.properties&lt;/value&gt; &lt;!--dbconfig.properties 数据库连接信息--&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean class="com.alibaba.druid.pool.DruidDataSource" id="dataSource"&gt; &lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;username&#125;"&gt;&lt;/property&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;url&#125;"&gt;&lt;/property&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 如果Mapper.xml与Mapper.class在同一个包下且同名，spring扫描Mapper.class的同时会自动扫描同名的Mapper.xml并装配到Mapper.class。 如果Mapper.xml与Mapper.class不在同一个包下或者不同名，就必须使用配置mapperLocations指定mapper.xml的位置。--&gt; &lt;!--此时spring是通过识别mapper.xml中的 namespace的值来确定对应的Mapper.class的--&gt; &lt;!-- 配置SqlSessionFactory对象 --&gt; &lt;bean class="org.mybatis.spring.SqlSessionFactoryBean" id="sqlSessionFactory"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml"&gt;&lt;/property&gt; &lt;!-- 扫描model包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="entity"&gt;&lt;/property&gt; &lt;!--配置使用pageHelper--&gt; &lt;/bean&gt; &lt;!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="dao"/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;&lt;/beans&gt; dbconfig.properties文件1234567url=jdbc:mysql:///test01driverClassName=com.mysql.jdbc.Driverusername=rootpassword=123maxActive=20minIdle=10maxWait=60000 下面的即为代替spring-mybatis.xml的java类。@Configuration作用是声明配置类，代替的其实是xml中的 1&lt;beans&gt;&lt;/beans&gt; @MapperScan(“dao”)扫描dao层代替 123456&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="dao"/&gt; &lt;/bean&gt; @ComponentScan({“service”,”dao”})代替，这里可以不用扫描dao层，因为已经通过@MapperScan扫描了，但是测试时使用@Autowired当时是报红了，认为dao没有注入ioc，但是测试运行是正确的。让后我这里就扫描了到层并且dao用@Repository注解，红线就消失了。不在意红线的话可以不加dao扫描。 1&lt;context:component-scan base-package="service"&gt;&lt;/context:component-scan&gt; @EnableTransactionManagement相当于 1&lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; @PropertySource配置数据源连接，相当于 1234567&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:dbconfig.properties&lt;/value&gt; &lt;!--dbconfig.properties 数据库连接信息--&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; @Bean DataSource相当于 123456789&lt;bean class="com.alibaba.druid.pool.DruidDataSource" id="dataSource"&gt; &lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;username&#125;"&gt;&lt;/property&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;url&#125;"&gt;&lt;/property&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; @Bean SqlSessionFactoryBean相当于，不过java代码中没有关于别名的处理 123456789&lt;bean class="org.mybatis.spring.SqlSessionFactoryBean" id="sqlSessionFactory"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml"&gt;&lt;/property&gt; &lt;!-- 扫描model包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="entity"&gt;&lt;/property&gt; &lt;!--配置使用pageHelper--&gt; &lt;/bean&gt; @Bean DataSourceTransactionManager相当于 12345&lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@Configuration//声明配置类@MapperScan("dao")//扫描dao层@ComponentScan(&#123;"service","dao"&#125;)//扫描service层@EnableTransactionManagement//开启事务管理@PropertySource("classpath:dbconfig.properties")//配置数据库properties位置public class SpringConfig &#123; /** * 提供数据源 * @param driver * @param url * @param username * @param password * @return */ @Bean public DataSource getDataSource( @Value("$&#123;driverClassName&#125;")String driver, @Value("$&#123;url&#125;")String url, @Value("$&#123;username&#125;")String username, @Value("$&#123;password&#125;")String password, @Value("$&#123;maxWait&#125;")Long maxWait )&#123; DruidDataSource druidDataSource=new DruidDataSource(); druidDataSource.setDriverClassName(driver); druidDataSource.setUrl(url); druidDataSource.setUsername("root"); //上面直接写root是因为如果填username，debug是发现变成了Administrator //猜想是root这个定义冲突了，反正没想明白，直接改为字符串注入就好了。 druidDataSource.setPassword(password); druidDataSource.setMaxWait(maxWait); return druidDataSource; &#125; /** * 创建SqlSessionFactoryBean工厂 * @param dataSource * @return * @throws IOException */ @Bean public SqlSessionFactoryBean getSqlSessionFactoryBean(DataSource dataSource) throws IOException &#123; SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean(); factoryBean.setDataSource( dataSource); ResourcePatternResolver resolver=new PathMatchingResourcePatternResolver(); Resource[] mapperLocations=resolver.getResources("classpath:mapper/*.xml"); factoryBean.setMapperLocations(mapperLocations); return factoryBean; &#125; /** * 声明事务管理器 * @param dataSource * @return */ @Bean public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource) &#123; DataSourceTransactionManager dm = new DataSourceTransactionManager(); dm.setDataSource(dataSource); return dm; &#125;&#125; 测试上面的方法行不行的通我们要测试一下： dao层1234@Repositorypublic interface UserDao &#123; User queryUserByName(String name);&#125; 实体类1234567@Getter@Setter@ToStringpublic class User &#123; private Integer age; private String name;&#125; UserMapper.xml123456789&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.UserDao"&gt; &lt;select id="queryUserByName" resultType="entity.User" parameterType="String"&gt; SELECT * from users where name = #&#123;name&#125; &lt;/select&gt;&lt;/mapper&gt; 为了方便以后的测试我们写一个父类测试类123456@RunWith(SpringJUnit4ClassRunner.class)//这里测试要配置SpringConfig，之前都是配置xml位置，现在就改为配置代替xml的对应类了。@ContextConfiguration(classes = &#123;SpringConfig.class&#125;)public class AnnotationSSMTest &#123;&#125; dao测试类继承父类测试类123456789public class DaoTest extends AnnotationSSMTest &#123; @Autowired private UserDao userDao; @Test public void userDaoTest()&#123; User user = userDao.queryUserByName("haha"); System.out.println(user); &#125;&#125; 数据库数据就是很简单的名字有年龄 控制台打印,说明是有效的了。 /* User(age=15, name=haha) */]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot单元测试继承优化]]></title>
    <url>%2F2018%2F09%2F07%2Fspringboot%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%BB%A7%E6%89%BF%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[基于之前的springboot单元测试，使用继承，减少不必要的重复操作。父类测试类，有springboot默认创建，我们做一些修改。 123456789101112131415@WebAppConfiguration//用来声明加载的类是一个WebApplicationContext@RunWith(SpringRunner.class)@SpringBootTest@MapperScan("springboot.demo.dao")//扫描dao层public class DemoApplicationTests &#123; protected MockMvc mockMvc; @Autowired private WebApplicationContext wac; @Before public void setup() &#123; mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); &#125;//这个方法在每个方法执行之前都会执行一遍 &#125; Dao层测试相比之前简化很多，只需要专注与测试就好了。 12345678910public class DaoExtendsTest extends DemoApplicationTests &#123; @Autowired private UserDao userDao; @Test public void daoTest()&#123; User user = userDao.queryUserByName("haha"); System.out.println(user); &#125; // User(name=haha, age=15)&#125; Service层测试相比之前简化很多，只需要专注与测试就好了。 1234567891011public class ServiceExtendsTest extends DemoApplicationTests &#123; @Autowired private UserService userService; @Test public void serviceTest()&#123; User user = userService.queryUserByName("haha"); System.out.println(user); &#125; //User(name=haha, age=15)&#125; Controller层测试 mockMvc在父类已经完成初始化 这里的super.mockMvc要写到@Test方法里面。因为初始化是在@Before中完成的，如果定义在成员变量则mockMvc其实在父类没有完成初始化为null，然后报空指针异常。 12345678910111213141516public class ControllerExtendsTest extends DemoApplicationTests&#123; @Test public void controllerTest() throws Exception &#123; String result = super.mockMvc.perform( MockMvcRequestBuilders.post("http://127.0.0.1:8080/user/queryUser/haha")//请求的url,请求的方法是post ) .andExpect(status().isOk())//返回的状态是200 .andDo(print())//打印出请求和相应的内容 .andReturn().getResponse().getContentAsString();//将相应的数据转换为字符串 System.out.println(result); &#125;&#125;]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http请求和响应]]></title>
    <url>%2F2018%2F09%2F07%2Fhttp%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[请求请求行 请求方式 HTTP协议有7中请求方式，常用的有2种 GET： 请求参数在请求行中，在url后。 请求的url长度有限制的 不太安全 POST： 请求参数在请求体中 请求的url长度没有限制的 相对安全 请求行对应request方法如果请求行为：GET /demo/demo1?name=zhangsan HTTP/1.1 获取请求方式 ：String getMethod() // get 获取虚拟目录 ：String getContextPath() // /demo 获取Servlet路径 ：String getServletPath() // /demo1 获取get方式请求参数 : String getQueryString() // name=zhangsan 获取请求URI : String getRequestURI(): // /demo/demo1 ​ StringBuffer getRequestURL() // http://localhost:8080/demo/demo1 获取协议及版本 : String getProtocol() // HTTP/1.1 获取客户机的IP地址 : String getRemoteAddr() 请求头1234567Host: localhost:8888User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:61.0) Gecko/20100101 Firefox/61.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateConnection: keep-aliveUpgrade-Insecure-Requests: 1 User-Agent 浏览器告诉服务器，我访问你使用的浏览器版本信息，可以在服务器端获取该头的信息，解决浏览器的兼容性问题。 Accept 指定客户端能够接收的内容类型。 Accept-Language 接受响应语言。 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接）。 Referer 先前网页的地址，告诉服务器，我(当前请求)从哪里来。 Content-Type 请求的与实体对应的MIME信息 请求头对应request方法String getHeader(String name)：通过请求头的名称获取请求头的值。 Enumeration getHeaderNames():获取所有的请求头名称。 请求空行空行，就是用于分割POST请求的请求头，和请求体的。 请求体(正文)封装POST请求消息的请求参数的。 请求体对应request方法 获取流对象 BufferedReader getReader()：获取字符输入流，只能操作字符数据。 ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 再从流对象中拿数据 其他request方法 获取请求参数通用方式：不论get还是post请求方式都可以使用下列方法来获取请求参数 String getParameter(String name):根据参数名称获取参数值 username=zs&amp;password=123 String[] getParameterValues(String name):根据参数名称获取参数值的数组 hobby=xx&amp;hobby=game Enumeration getParameterNames():获取所有请求的参数名称 Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 中文乱码问题 get方式：tomcat 8 已经将get方式乱码问题解决了 request.setCharacterEncoding(“utf-8”) 请求转发 getRequestDispatcher(String path).forward(ServletRequest request, ServletResponse response) 共享数据,域对象 void setAttribute(String name,Object obj):存储数据 Object getAttitude(String name):通过键获取值 void removeAttribute(String name):通过键移除键值对 获取ServletContext ServletContext getServletContext() 响应响应行组成：协议/版本 响应状态码 状态码描述 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态。 状态码都是3位数字 分类： ​ 1xx：服务器就收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 ​ 2xx：成功。代表：200 ​ 3xx：重定向。代表：302(重定向)，304(访问缓存) ​ 4xx：客户端错误。 ​ 代表： ​ 404（请求路径没有对应的资源） ​ 405：请求方式没有对应的doXxx方法 ​ 5xx：服务器端错误。代表：500(服务器内部出现异常) 响应行对应方法设置状态码：setStatus(int sc) 响应头12345HTTP/1.1 200 Content-Type: text/html;charset=UTF-8Content-Language: zh-CNTransfer-Encoding: chunkedDate: Fri, 07 Sep 2018 02:51:46 GMT Content-Type 服务器告诉客户端本次响应体数据格式以及编码格式 Content-Language 响应语言 Content-disposition 服务器告诉客户端以什么格式打开响应体数据 in-line:默认值,在当前页面内打开 attachment;filename=xxx：以附件形式打开响应体。文件下载 Date 响应时间 Transfer-Encoding 是一个 HTTP 头部字段（响应头域），字面意思是「传输编码」。最新的 HTTP 规范里，只定义了一种编码传输：分块编码(chunked)。 响应头对应方法setHeader(String name, String value) response.setHead(“Context-type”,”text/html;charset=UTF-8”);和下面的方法是一样的 response.setContentType(“text/html;charset=UTF-8”); 响应空行响应体:传输的数据1234567891011121314响应字符串格式 HTTP/1.1 200 OK Content-Type: text/html;charset=UTF-8 Content-Length: 101 Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;html&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt; &lt;/html&gt; 响应体对应方法字符输出流：PrintWriter getWriter() ServletOutputStream getOutputStream() 重定向方法response.sendRedirect(path); ServletContext对象 概念：代表整个web应用，可以和程序的容器(服务器)来通信 获取： 通过request对象获取：request.getServletContext(); 通过HttpServlet获取：this.getServletContext(); 功能： 获取MIME类型：String getMimeType(String file) 域对象：setAttribute(String name,Object value) ​ getAttribute(String name) ​ removeAttribute(String name) ​ ServletContext对象范围：所有用户所有请求的数据 获取文件的真实(服务器)路径： ​ String getRealPath(String path) ​ String b = context.getRealPath(“/b.txt”);//web目录下资源访问 ​ String c = context.getRealPath(“/WEB-INF/c.txt”);//WEB-INF目录下的资源访问 ​ String a = context.getRealPath(“/WEB-INF/classes/a.txt”);//src目录下的资源访问 ​]]></content>
      <categories>
        <category>javaweb</category>
      </categories>
      <tags>
        <tag>javaweb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot单元测试]]></title>
    <url>%2F2018%2F09%2F06%2Fspringboot%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[springboot的单元测试可以参考ssm框架的测试方法 Dao层单元测试12345678910111213141516@WebAppConfiguration//用来声明加载的类是一个WebApplicationContext@RunWith(SpringRunner.class)@SpringBootTest@MapperScan("springboot.demo.dao")//扫描dao层public class DaoTest &#123; @Autowired private UserDao userDao; @Test public void UserDaoTest()&#123; User user = userDao.queryUserByName("东西"); System.out.println(user); //User(name=东西, age=10) &#125;&#125; 在这个demo测试中，我把mybatis的mapper.xml放在了resources目录下的mapper文件夹中。 所以要想让dao层能匹配带对应的xml文件，需要在application.properties中配置 1234567#datasourcespring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.url=jdbc:mysql://localhost:3306/test01?useUnicode=true&amp;characterEncoding=utf-8spring.datasource.username=rootspring.datasource.password=123#配置mybatis的mapper.xml位置mybatis.mapper-locations=mapper/*.xml 而且需要在dao类上加入@Repository注解，注入ioc容器。 1234@Repositorypublic interface UserDao &#123; User queryUserByName(String name);&#125; 实体类，推荐使用lombok使代码更加简洁。 1234567@Getter@Setter@ToStringpublic class User &#123; private String name; private Integer age;&#125; UserMapper.xml 123456789&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="springboot.demo.dao.UserDao"&gt; &lt;select id="queryUserByName" resultType="springboot.demo.entity.User" parameterType="String"&gt; SELECT * from users where name = #&#123;name&#125; &lt;/select&gt;&lt;/mapper&gt; 测试运行结果：User(name=东西, age=10) Service层单元测试123public interface UserService &#123; User queryUserByName(String name);&#125; 123456789@Servicepublic class UserServiceImpl implements UserService &#123; @Autowired private UserDao userDao; @Override public User queryUserByName(String name) &#123; return userDao.queryUserByName(name); &#125;&#125; 好像和dao层的单元测试区别不大，但是注意到一个问题：service层的单元测试不需要扫描service层，即不需要 @ComponentScan注解来指定扫描service层，但是dao层确实需要@MapperScan注解。 原因是：@SpringBootTest 能够测试你的SpringApplication，因为SpringBoot程序的入口是SpringApplication，基本的所有配置都会通过入口类去加载，而注解可以引用入口类的配置。 简单说：@SpringBootTest会通过SpringApplication启动类去加载配置，由于SpringApplication的@SpringBootApplication与其所被建议的特殊位置关系，就不需要用@ComponentScan因为SpringApplication已经帮我们解决了。 12345678910111213@WebAppConfiguration//用来声明加载的类是一个WebApplicationContext@RunWith(SpringRunner.class)@SpringBootTest@MapperScan("springboot.demo.dao")//扫描dao层public class ServiceTest &#123; @Autowired private UserService userService; @Test public void UserServiceTest()&#123; User user = userService.queryUserByName("东西"); System.out.println(user); &#125;&#125; Controller层单元测试controller代码 12345678910111213@Controller@RequestMapping("/user")public class UserController &#123; @Autowired private UserService userService; @ResponseBody @RequestMapping("/queryUser/&#123;name&#125;") public User queryUserByName(@PathVariable String name)&#123; User user = userService.queryUserByName(name); return user; &#125;&#125; ControllerTest 这里的传参用的是@PathVariable。 123456789101112131415161718192021222324252627282930@WebAppConfiguration//用来声明加载的类是一个WebApplicationContext@RunWith(SpringRunner.class)@SpringBootTest@MapperScan("springboot.demo.dao")//扫描dao层public class ControllerTest &#123; private MockMvc mockMvc; @Autowired private WebApplicationContext wac; @Autowired private UserController userController; @Before public void setup() &#123; //mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); //初始化MockMvc对象 mockMvc = MockMvcBuilders.standaloneSetup(userController).build();//两种方式都可以初始化mockMvc，推荐用这种，上面的会自动跳转地址status判断方法无效 &#125;//这个方法在每个方法执行之前都会执行一遍 @Test public void controllerTest() throws Exception &#123; String result = mockMvc.perform( MockMvcRequestBuilders.post("http://127.0.0.1:8080/user/queryUser/haha")//请求的url,请求的方法是post ) .andExpect(status().isOk())//返回的状态是200 .andDo(print())//打印出请求和相应的内容 .andReturn().getResponse().getContentAsString();//将相应的数据转换为字符串 System.out.println(result); &#125;&#125; 输出结果 /* {“name”:”haha”,”age”:15} */]]></content>
      <categories>
        <category>springboot</category>
      </categories>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cglib动态代理]]></title>
    <url>%2F2018%2F09%2F06%2Fcglib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[cglib是针对类来实现代理的，原理是对指定的目标类生成一个子类，并覆盖其中业务方法实现代理。因为采用的是继承，所以不能对final修饰的类进行代理。 下面是一个简单的例子： 目标类： 12345public class ServiceImpl &#123; public void serviceFunction()&#123; System.out.println("service方法执行"); &#125;&#125; 代理类： 需要实现MethodInterceptor enhancer.create();方法生成代理类，由于cglib是用继承实现代理，所以需要传入目标类this.target = target;和设置父类即setSuperclass。 代理类上所有方法的调用，都会调用CallBack,而Callback则需要实现intercept()方法进行拦截，因此实现了代理增强。 1234567891011121314151617181920public class ServiceImplCglib implements MethodInterceptor &#123; private Object target;//目标类对象 //定义获得代理类方法 public Object getProxy(Object target)&#123; this.target = target;//传入目标类 Enhancer enhancer = new Enhancer(); //创建加强器，用来创建动态代理类 enhancer.setSuperclass(this.target.getClass());//为下面生成的代理类指定父类 //设置回调：对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept()方法进行拦截 enhancer.setCallback(this); // 创建动态代理类对象并返回 return enhancer.create(); &#125; @Override public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable &#123; System.out.println("方法调用前"); methodProxy.invokeSuper(o, objects); //调用父类中的方法 System.out.println("方法调用后"); return null; &#125;&#125; 测试类： 12345678public class CglibTest &#123; public static void main(String[] args) &#123; ServiceImpl service = new ServiceImpl(); ServiceImplCglib serviceCglib = new ServiceImplCglib(); ServiceImpl proxy = (ServiceImpl) serviceCglib.getProxy(service); proxy.serviceFunction(); &#125;&#125; 控制台打印： /* 方法调用前service方法执行方法调用后 */]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm框架单元测试]]></title>
    <url>%2F2018%2F09%2F05%2Fssm%E6%A1%86%E6%9E%B6%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[数据层的测试12345678910111213@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123; "classpath:spring/spring-mybatis.xml" &#125;)public class UserDaoTest &#123; // 注入Dao实现类依赖 @Resource private UserDao userDao; @Test public void testUserDao() &#123; User user = userDao.findById(1); System.out.println(user); &#125;&#125; 业务层测试业务层会涉及到多表的操作，因此需要引入事务，添加回滚功能。 1234567891011121314151617181920@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123; "classpath:spring/spring-mybatis.xml", "classpath:spring/spring-service.xml" &#125;)/*@TransactionConfiguration(transactionManager = "transactionManager", defaultRollback = true)@Transactional*///上面的已经过时了@Transactional(transactionManager = "transactionManager")@Rollback(value = false)public class UserServiceTest &#123; @Autowired private UserService userService; @Test public void test() &#123; User user = new User(); user.setName("东西"); userService.save(user) &#125;&#125; 控制层测试控制层主要模拟用户请求，这里涉及到http请求，我们可以使用mock测试 需要引入servlet依赖,不然会报 Caused by: java.util.MissingResourceException: Can’t find bundle for base name javax.servlet.LocalStrings, locale zh_CN junit版本要在4.12以上 123456&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324252627282930313233@WebAppConfiguration//告诉junit spring的配置文件@ContextConfiguration(&#123; "classpath:spring-mybatis.xml", "classpath:spring-mvc.xml"&#125;)//配置spring和junit整合，这样junit在启动时就会加载spring容器@RunWith(SpringJUnit4ClassRunner.class)//事务@Transactional(transactionManager = "transactionManager")@Rollback(value = false)public class UserControllerTest &#123; private MockMvc mockMvc; @Autowired private WebApplicationContext wac;// @Autowired private UserController userController;//注入要测试的Controller @Before public void setup() &#123; //mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); //初始化MockMvc对象 mockMvc = MockMvcBuilders.standaloneSetup(userController).build();//两种方式都可以初始化mockMvc，推荐用这种，上面的会自动跳转地址status判断方法无效 &#125;//这个方法在每个方法执行之前都会执行一遍 @Test public void userControllerTest() throws Exception &#123; String result = mockMvc.perform( MockMvcRequestBuilders.post("http://127.0.0.1:8888/user/checkUserName")//请求的url,请求的方法是post .param("username","1377262954")) .andExpect(status().isOk())//返回的状态是200 .andDo(print())//打印出请求和相应的内容 .andReturn().getResponse().getContentAsString();//将相应的数据转换为字符串 System.out.println(result); &#125;&#125; 继承方式的单元测试示例 要点是扫描spring-mvc.xml。可见单元测试并不会经过web.xml 12345678910111213@WebAppConfiguration@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123; "classpath:spring-mybatis.xml","classpath:spring-mvc.xml" &#125;)public class ItcastSSMTest &#123; protected MockMvc mockMvc; @Autowired private WebApplicationContext wac; @Before public void setup() &#123; mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); &#125;//这个方法在每个方法执行之前都会执行一遍&#125; 1234567891011121314public class ControllerTest extends ItcastSSMTest&#123; @Test public void fun1() throws Exception &#123; String result = super.mockMvc.perform( MockMvcRequestBuilders.post("http://127.0.0.1:8888/product/findAllProducts")//请求的url,请求的方法是post ) .andExpect(status().isOk())//返回的状态是200 .andDo(print())//打印出请求和相应的内容 .andReturn().getResponse().getContentAsString();//将相应的数据转换为字符串 System.out.println(result); &#125;&#125;]]></content>
      <categories>
        <category>spring</category>
        <category>单元测试</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己编写PageBean结合Thymeleaf实现分页]]></title>
    <url>%2F2018%2F09%2F05%2F%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99PageBean%E7%BB%93%E5%90%88Thymeleaf%E5%AE%9E%E7%8E%B0%E5%88%86%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[当使用thymeleaf页面模板的时候不能使用jstl标签和jsp的循环和取值方式。 所以对PageBean进行了一定处理，当然html页面很不同。 引入thymeleaf依赖123456789101112&lt;!-- 引入thymeleaf --&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt; &lt;version&gt;3.0.9.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.9.RELEASE&lt;/version&gt;&lt;/dependency&gt; 修改spring-mvc.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"&gt; &lt;!-- 扫描controller --&gt; &lt;context:component-scan base-package="controller"/&gt; &lt;!-- 解除servlet对静态资源文件访问的限制 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 开启SpringMVC注解模式 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 配置视图解析器 --&gt; &lt;!-- &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &amp;lt;!&amp;ndash; 前缀 &amp;ndash;&amp;gt; &lt;property name="prefix" value="" /&gt;&amp;lt;!&amp;ndash;这里根据自己的建包自己配置&amp;ndash;&amp;gt; &amp;lt;!&amp;ndash; 后缀 &amp;ndash;&amp;gt; &lt;property name="suffix" value=".html" /&gt;&amp;lt;!&amp;ndash;这里根据自己的建包自己配置&amp;ndash;&amp;gt; &lt;/bean&gt;--&gt; &lt;!--使用thymeleaf，上面的视图解析器注释掉--&gt; &lt;!-- 使用thymeleaf解析 --&gt; &lt;bean id="templateResolver" class="org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver"&gt; &lt;property name="prefix" value="" /&gt; &lt;property name="suffix" value=".html" /&gt; &lt;property name="templateMode" value="HTML" /&gt; &lt;property name="cacheable" value="false" /&gt; &lt;property name="characterEncoding" value="UTF-8"/&gt;&lt;!--不加会乱码--&gt; &lt;/bean&gt; &lt;bean id="templateEngine" class="org.thymeleaf.spring5.SpringTemplateEngine"&gt; &lt;property name="templateResolver" ref="templateResolver" /&gt; &lt;/bean&gt; &lt;bean class="org.thymeleaf.spring5.view.ThymeleafViewResolver"&gt; &lt;property name="templateEngine" ref="templateEngine" /&gt; &lt;!--解决中文乱码--&gt; &lt;property name="characterEncoding" value="UTF-8"/&gt; &lt;/bean&gt; &lt;!--文件上传配置--&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 设定默认编码 --&gt; &lt;property name="defaultEncoding" value="UTF-8" /&gt; &lt;!-- 设定文件上传的最大值5MB，5*1024*1024 --&gt; &lt;property name="maxUploadSize" value="5242880" /&gt; &lt;property name="maxInMemorySize" value="4096" /&gt; &lt;/bean&gt;&lt;/beans&gt; 修改web.xml1234567891011121314151617181920212223&lt;!-- 配置SpringMVC --&gt;&lt;servlet&gt; &lt;servlet-name&gt;MavenProject&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置springmvc什么时候启动，参数必须为整数 --&gt; &lt;!-- 如果为0或者大于0，则springMVC随着容器启动而启动 --&gt; &lt;!-- 如果小于0，则在第一次请求进来的时候启动 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;MavenProject&lt;/servlet-name&gt; &lt;!-- 所有的请求都进入springMVC --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;MavenProject&lt;/servlet-name&gt; &lt;url-pattern&gt;*.html&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 编写PageBean12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788@Getter@Setter@ToStringpublic class PageBean&lt;T&gt; &#123; private Integer totalCount; private Integer totalPage; private Integer currentPage; private Integer pageSize; private List&lt;T&gt; list; private Integer start; //导航页号 private int[] navigatePageNums;//下面定义了两个初始化方法init是考虑到controller层接受参数如下需要默认的空参构造。//public String list(PageBean&lt;Route&gt; pageBean, HttpServletRequest request)如果默认构造被重写就会无法自动封装属性。debug后发现都会空，所以这里选择了折中的方式，保留默认构造，在方法中调用init方法初始化。 public PageBean() &#123; &#125; //在pageBean中初始化pageSize，currentPage和start。 public void init()&#123; this.pageSize = 10; if(this.currentPage==null)&#123; this.currentPage = 1; &#125; this.start = (this.currentPage-1)*pageSize; &#125; //初始化 int[] navigatePageNums; //navigatePageNums封装的是每次请求后需要显示在前台的导航页号数组 //导航页号的方式是前5后4例如 //当前也为3时&#123;1,2,3，。。。10&#125; //当前页为10时&#123;5,6,7,8,9,10,11,12,13,14&#125; //当前页不够5个，后边补齐10个 //如果后边不足4个，前边补齐10个 public void initNavigatePages()&#123; int begin = 0; int end = 0; if(this.totalPage&lt;10)&#123; //总页码不够10页 begin = 1; end = this.totalPage; &#125;else &#123; //总页码超过10页 begin = this.currentPage - 5 ; end = this.currentPage + 4 ; //2.如果前边不够5个，后边补齐10个 if(begin &lt; 1)&#123; begin = 1; end = begin + 9; &#125; //3.如果后边不足4个，前边补齐10个 if(end &gt; this.totalPage)&#123; end = this.totalPage; begin = end - 9 ; &#125; &#125; //将要显示的导航页号封装到navigatePageNums数组 this.navigatePageNums = new int[end+1 - begin]; for (int i = begin; i &lt;=end; i++) &#123; navigatePageNums[i-begin] = i; //System.out.println(navigatePageNums[i-begin]); &#125; //System.out.println(); &#125; /*表达式如果属性是boolean类型，那么就会自动调用isXXX方法了,所以一定是is开头的*/ //是否有前页 public boolean isHasPreviouse()&#123; if(start==0) return false; return true; &#125; //是否有后页 public boolean isHasNext()&#123; if(start==getLast()) return false; return true; &#125; public int getLast()&#123; int last; if (0 == totalCount % pageSize) last = totalCount - pageSize; else last = totalCount - totalCount % pageSize; last = last&lt;0?0:last; return last; &#125;&#125; controller层代码dao和service代码省略，因为重点在pageBean和前端的thymeleaf。 123456789101112131415161718192021@Controller@RequestMapping("/route")public class RouteController &#123; @Autowired private RouteService routeService; @RequestMapping("/list") public String list(PageBean&lt;Route&gt; pageBean, HttpServletRequest request)&#123; Integer cid = Integer.parseInt(request.getParameter("cid")); String searchName = request.getParameter("searchName"); //初始化pageSize，currentPage和start。 pageBean.init(); //根据id和查询条件分页查询 PageBean&lt;Route&gt; pageInfo = routeService.getPageInfoByNameWithId(pageBean, cid, searchName); //初始化navigatePageNums，initNavigatePages();需要最终的totalPage参数所以在调用service层方法后在初始化，获得最终要显示在前端的导航页数组。 pageInfo.initNavigatePages(); request.setAttribute("pageInfo",pageInfo); request.setAttribute("cid",cid); request.setAttribute("searchName",searchName); return "forward:/for/route_list"; &#125;&#125; 前端分页导航栏部分注意thymeleaf需要命名空间： 1xmlns:th="http://www.thymeleaf.org" 123456789101112131415161718&lt;div class="pageNum"&gt; &lt;ul&gt; &lt;li&gt;&lt;a th:href="@&#123;/route/list(currentPage=1,cid=$&#123;cid&#125;,rname=$&#123;rname&#125;)&#125;"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li th:if="$&#123;pageInfo.currentPage&gt;1&#125;"&gt;&lt;a th:href="@&#123;/route/list(currentPage=$&#123;pageInfo.currentPage-1&#125;,cid=$&#123;cid&#125;,rname=$&#123;rname&#125;)&#125;"&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;!--如果是第一页，前一页无法跳转--&gt; &lt;li th:if="$&#123;pageInfo.currentPage&lt;=1&#125;"&gt;&lt;a href="javascript:void(0)"&gt;上一页&lt;/a&gt;&lt;/li&gt; &lt;!--遍历navigatePageNums数组--&gt; &lt;th:block th:each="nav : $&#123;pageInfo.navigatePageNums&#125;"&gt; &lt;!--如果是当前页，class属性为curPage，且无法跳转--&gt; &lt;li th:if="$&#123;nav==pageInfo.currentPage&#125;" class="curPage"&gt;&lt;a href="javascript:void(0)" th:text="$&#123;nav&#125;"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li th:if="$&#123;nav!=pageInfo.currentPage&#125;"&gt;&lt;a th:href="@&#123;/route/list(currentPage=$&#123;nav&#125;,cid=$&#123;cid&#125;,rname=$&#123;rname&#125;)&#125;" th:text="$&#123;nav&#125;"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/th:block&gt; &lt;li th:if="$&#123;pageInfo.currentPage&lt;pageInfo.totalPage&#125;"&gt;&lt;a th:href="@&#123;/route/list(currentPage=$&#123;pageInfo.currentPage+1&#125;,cid=$&#123;cid&#125;,rname=$&#123;rname&#125;)&#125;"&gt;下一页&lt;/a&gt;&lt;/li&gt; &lt;!--如果为末页无法跳转下一页--&gt; &lt;li th:if="$&#123;pageInfo.currentPage&lt;=pageInfo.totalPage&#125;"&gt;&lt;a href="javascript:void(0)"&gt;下一页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a th:href="@&#123;/route/list(currentPage=$&#123;pageInfo.totalPage&#125;,cid=$&#123;cid&#125;,rname=$&#123;rname&#125;)&#125;"&gt;末页&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;]]></content>
      <categories>
        <category>thymeleaf</category>
      </categories>
      <tags>
        <tag>thymeleaf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fileupload文件上传]]></title>
    <url>%2F2018%2F09%2F05%2Ffileupload%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[前端代码12345678910111213141516171819&lt;form method="post" id="addForm" action="/tmall/admin/category/add" enctype="multipart/form-data"&gt; &lt;table class="addTable"&gt; &lt;tr&gt; &lt;td&gt;分类名称&lt;/td&gt; &lt;td&gt;&lt;input id="name" name="name" type="text" class="form-control"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;分类圖片&lt;/td&gt; &lt;td&gt; &lt;input id="categoryPic" accept="image/*" type="file" name="multipartFile" /&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr class="submitTR"&gt; &lt;td colspan="2" align="center"&gt; &lt;button type="submit" class="btn btn-success"&gt;提 交&lt;/button&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/form&gt; 设置表单提交：enctype=”multipart/form-data” 设置 input 属性 : accept=”image/*” 引入依赖123456789101112&lt;!--上传文件需要依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; 修改spring-mvc.xml文件12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"&gt; &lt;!-- 扫描controller --&gt; &lt;context:component-scan base-package="controller"/&gt; &lt;!-- 解除servlet对静态资源文件访问的限制 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 开启SpringMVC注解模式 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 前缀 --&gt; &lt;property name="prefix" value="" /&gt;&lt;!--这里根据自己的建包自己配置--&gt; &lt;!-- 后缀 --&gt; &lt;property name="suffix" value=".jsp" /&gt;&lt;!--这里根据自己的建包自己配置--&gt; &lt;/bean&gt; &lt;!--文件上传配置--&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 设定默认编码 --&gt; &lt;property name="defaultEncoding" value="UTF-8" /&gt; &lt;!-- 设定文件上传的最大值5MB，5*1024*1024 --&gt; &lt;property name="maxUploadSize" value="5242880" /&gt; &lt;property name="maxInMemorySize" value="4096" /&gt; &lt;/bean&gt;&lt;/beans&gt; 编写代码这里只提供了方法的代码 12345678910111213141516171819202122232425@RequestMapping("/add")public String add(HttpServletRequest request,MultipartFile multipartFile,Category category)&#123; service.save(category); Integer id = category.getId(); //这个方法用来获取上传文件原始名。 //String filename = multipartFile.getOriginalFilename(); //System.out.println(filename); //83.jpg //idea的request.getServletContext().getRealPath("/")和eclipse不同获得的目录是项目设置中的Output directory String realPath = request.getServletContext().getRealPath("/"); //D:\ideawork\ssm_tmall\target\tmall\ String webapp = realPath.replace("target\\tmall\\", "src\\main\\webapp\\img\\category\\"); //System.out.println(webapp); File imageFolder = new File(webapp); File file = new File(imageFolder,id+".jpg"); try &#123; //上传文件 multipartFile.transferTo(file); &#125; catch (IOException e) &#123; e.printStackTrace(); throw new RuntimeException(); &#125; return "redirect:list";&#125;]]></content>
      <categories>
        <category>fileupload</category>
      </categories>
      <tags>
        <tag>fileupload</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm框架优化BaseService]]></title>
    <url>%2F2018%2F09%2F05%2Fssm%E6%A1%86%E6%9E%B6%E4%BC%98%E5%8C%96BaseService%2F</url>
    <content type="text"><![CDATA[ssm框架的BaseService优化BaseService需要基于BaseDao。 编写BaseService接口，定义了一些常用的方法，项目中servic层遇到频繁的方法可以抽取到BaseService。下面的针对PageBean的方法是我自己加的。 123456789101112131415public interface BaseService&lt;T&gt; &#123; void save(T entity);// 保存 void delete(T entity);// 删除 void update(T entity);// 更新 T findById(Serializable id);// 根据主键查找 List&lt;T&gt; getAll();// 查看所有 PageBean&lt;T&gt; getPageInfo(PageBean&lt;T&gt; pageBean); PageBean&lt;T&gt; getPageInfoWithId(PageBean&lt;T&gt; pageBean,Integer id);&#125; BaseService实现类编写。下面的针对PageBean的方法是我自己加的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495@Servicepublic class BaseServiceImpl&lt;T&gt; implements BaseService&lt;T&gt; &#123; private BaseDao&lt;T&gt; baseDao; /** * 保存 * @param entity */ @Override public void save(T entity) &#123; baseDao.save(entity); &#125; /** * 删除 * @param entity */ @Override public void delete(T entity) &#123; baseDao.delete(entity); &#125; /** * 更新 * @param entity */ @Override public void update(T entity) &#123; baseDao.update(entity); &#125; /** * 根据id查询 * @param id * @return */ @Override public T findById(Serializable id) &#123; return baseDao.findById(id); &#125; /** * 查询所有 * @return */ @Override public List&lt;T&gt; getAll() &#123; return baseDao.getAll(); &#125; /** * 无查询条件分页 * @param pageBean * @return */ @Override public PageBean&lt;T&gt; getPageInfo(PageBean&lt;T&gt; pageBean) &#123; //总条数 Integer totalCount = baseDao.getTotalCount(); //总页数 Integer totalPage = (totalCount+ pageBean.getPageSize()-1)/pageBean.getPageSize(); //分页查询数据 List&lt;T&gt; list = baseDao.list(pageBean.getStart(), pageBean.getPageSize()); //封装数据 pageBean.setTotalCount(totalCount); pageBean.setTotalPage(totalPage); pageBean.setList(list); return pageBean; &#125; /** * 通过外键id分页查询 * @param pageBean * @param id * @return */ @Override public PageBean&lt;T&gt; getPageInfoWithId(PageBean&lt;T&gt; pageBean, Integer id) &#123; //总条数 Integer totalCount = baseDao.getTotalCountWithId(id); //总页数 Integer totalPage = (totalCount+ pageBean.getPageSize()-1)/pageBean.getPageSize(); //分页查询数据 List&lt;T&gt; list = baseDao.listWithId(pageBean.getStart(), pageBean.getPageSize(), id); //封装数据 pageBean.setTotalCount(totalCount); pageBean.setTotalPage(totalPage); pageBean.setList(list); return pageBean; &#125; //这里很重要。 public void setBaseDao(BaseDao&lt;T&gt; baseDao) &#123; this.baseDao = baseDao; &#125;&#125; 编写测试的Service代码 可以看到接口不需要定义同用方法 12345import entity.User;public interface UserService extends BaseService&lt;User&gt; &#123;&#125; 这里的注入方式@Autowired要加在setter方法上，不能放在private UserDao userDao上。 注入时会把继承了BaseDao的UserDao传到BaseServiceImpl，那么其中的通用方法其实由UserDao调用而不是BaseDao。后面就是dao层的代码，只需要UserDao继承BaseDao，然后编写UserMapper.xml文件就好了。 这样在实现User对应通用功能时，只需要编写controller层代码和UserMapper.xml就好了dao层与service层就可以不用编写。 1234567891011@Servicepublic class UserServiceImpl extends BaseServiceImpl&lt;User&gt; implements UserService &#123; private UserDao userDao; @Autowired //这里的@Autowired不能加在成员变量上，而要在setter方法上, //否则不会执行下面的setUserDao方法。 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; super.setBaseDao(userDao); &#125;&#125; 测试代码 123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123;"classpath:spring-mybatis.xml","classpath:spring-mvc.xml"&#125;)public class BaseServiceTest &#123; @Autowired private UserService userService; @Test public void fun1()&#123; User user = userService.findById(1); System.out.println(user); //User(id=1, name=测试用户1, password=password1) &#125;&#125;]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm框架优化BaseDao]]></title>
    <url>%2F2018%2F09%2F05%2Fssm%E6%A1%86%E6%9E%B6%E4%BC%98%E5%8C%96BaseDao%2F</url>
    <content type="text"><![CDATA[ssm框架的BaseDao下面的BaseDao举例了几种常用方法，如果在项目过程中，有使用比较频繁的dao代码，就可抽取到BaseDao中。 12345678910111213141516public interface BaseDao&lt;T&gt; &#123; void save(T entity);// 保存 void delete(T entity);// 删除 void update(T entity);// 更新 T findById(Serializable id);// 根据主键查找 List&lt;T&gt; getAll();// 查看所有 Integer getTotalCount(); List&lt;T&gt; list(@Param("start") Integer start, @Param("pageSize") Integer pageSize);&#125; 有了BaseDao后在编写dao层代码时只需要继承BaseDao就好了 12345package dao;//使用BaseDao,抽取dao的crud。public interface UserDao&lt;User&gt; extends BaseDao&lt;User&gt;&#123;&#125; 但是即使继承了BaseDao，mapper.xml文件还是需要编写。 123456789&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.UserDao"&gt; &lt;select id="findById" resultType="user" parameterType="Integer"&gt; SELECT * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; ssm单元测试，数据库事先准备了测试数据：123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(&#123;"classpath:spring-mybatis.xml"&#125;)public class UserDaoTest &#123; @Autowired private UserDao&lt;User&gt; userDao; @Test public void fun1()&#123; User user = userDao.findById(1); System.out.println(user); //User(id=1, name=测试用户1, password=password1) &#125;&#125; 总结：如果BaseDao中有需要的方法的话，就可以选择继承BaseDao，这样在xxxDao中就无需编写代码，但是仍然需要编写mapper.xml。每一个xxxDao对应一个xxxMapper.xml就行了。特殊方法可以不抽取到BaseDao中。]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手实现简单的事务管理（动态代理+注解）二]]></title>
    <url>%2F2018%2F09%2F05%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%88%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-%E6%B3%A8%E8%A7%A3%EF%BC%89%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[上一篇介绍了ThreadLocalJDBCUtils（用于获得与线程绑定的connection的工具类）。动态代理不做赘述。 我们用一个简单的保存用户说明问题： service层代码如下，这里不贴UserService接口的代码了。 1234567public class UserServiceImpl implements UserService &#123; private UserDao dao = new UserDaoImpl(); @Override public void saveUser(User user) &#123; dao.saveUser(user); &#125;&#125; User实体类如下 12345678910111213141516171819202122232425262728public class User &#123; private String name; private Integer age; @Override public String toString() &#123; return "User&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125; 动态代理管理事务类 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TransactionProxyManager &#123; public Object proxyFor(Object object)&#123; /* 三个参数： 1. 类加载器：真实对象.getClass().getClassLoader() 2. 接口数组：真实对象.getClass().getInterfaces() 3. 处理器：new InvocationHandler() */ return Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), new InvocationHandler() &#123; /* 1. proxy:代理对象 2. method：代理对象的方法，被封装成为对象 3. args:代理对象调用的方法时，传递的实际参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //如果没有被注解的话，直接执行方法，不进行事务管理。 Method originalMethod = object.getClass().getMethod(method.getName(), method.getParameterTypes()); if(!originalMethod.isAnnotationPresent(MyTransactional.class))&#123; return method.invoke(object, args); &#125; //开启事务 ThreadLocalJDBCUtils.beginTransaction(); System.out.println("开启事务"); Object result = null; try &#123; //顺利的话就提交事务 result = method.invoke(object, args); ThreadLocalJDBCUtils.commit(); System.out.println("提交事务"); &#125;catch (Exception e)&#123; //出错就回滚事务 ThreadLocalJDBCUtils.rollback(); System.out.println("回滚事务"); &#125;finally &#123; //释放资源 ThreadLocalJDBCUtils.close(); System.out.println("释放资源"); &#125; return result; &#125; &#125;); &#125;&#125; 注解代码如下，指定使用在方法上.。 1234@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyTransactional &#123;&#125; 测试代码： 1234567891011public class UserTest &#123; public static void main(String[] args) &#123; UserService userService = new UserServiceImpl(); TransactionProxyManager manager = new TransactionProxyManager(); UserService proxyUserService = (UserService) manager.proxyFor(userService); User user = new User(); user.setName("东西"); user.setAge(10); proxyUserService.saveUser(user); &#125;&#125; service代码处理异常，在方法上加上自定义注解 123456789101112public class UserServiceImpl implements UserService &#123; private UserDao dao = new UserDaoImpl(); @Override @MyTransactional public void saveUser(User user) &#123; try &#123; dao.saveUser(user); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; dao层代码 12345678910public class UserDaoImpl implements UserDao &#123; @Override public void saveUser(User user) throws SQLException &#123; QueryRunner qr = new QueryRunner(); String sql = "insert into users values (?,?)"; Integer age = user.getAge(); String name = user.getName(); int row = qr.update(ThreadLocalJDBCUtils.getCurrentConnection(), sql, age, name); &#125;&#125; 运行结果如下： 查看数据库有没有更新： 当我们取消在方法上的自定义注解@MyTransactional，运行UserTest。 可见事务并没有进行处理，但是数据库又插入了一条数据。我们知道查询是不用进行事务处理的，在我们处理查询方法时，就可以不加自定义的注解，从而不对其进行事务管理。 下面我们在UserServiceImpl加入int i = 1/0;使其报异常 12345678910111213public class UserServiceImpl implements UserService &#123; private UserDao dao = new UserDaoImpl(); @Override @MyTransactional public void saveUser(User user) &#123; try &#123; dao.saveUser(user); int i = 1/0; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 运行结果： 且数据没有插入。 这里提一个踩到的巨坑。如果回滚事务后仍然插入了数据，那么大概率是数据库引擎问题。之前遇到过这个问题，看了一下表的引擎是MyISAM，好像不支持事务，改成InnoDB就好了。]]></content>
      <categories>
        <category>事务</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自己动手实现简单的事务管理（动态代理+注解）一]]></title>
    <url>%2F2018%2F09%2F05%2F%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%EF%BC%88%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86-%E6%B3%A8%E8%A7%A3%EF%BC%89%E4%B8%80%2F</url>
    <content type="text"><![CDATA[使用原生的servlet，没有使用框架。运用动态代理技术手动实现service层的事务管理。并增加注解功能，用于查询时无需事务管理。 事务管理需要保证连接Connection的一致，即dao层和service层的connection是同一个，这就需要用到ThreadLocal处理。直接上代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class ThreadLocalJDBCUtils &#123; private static ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;&gt;(); private static DataSource dataSource; static&#123; try &#123; //手动加载配置文件，初始化druid连接池 Properties pro = new Properties(); InputStream in = ThreadLocalJDBCUtils.class.getClassLoader().getResourceAsStream("druid.properties"); pro.load(in); dataSource = DruidDataSourceFactory.createDataSource(pro); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 获得连接池方法 * @return 数据连接池 */ public static DataSource getDataSource()&#123; return dataSource; &#125; /** * 获得连接对象方法 * @return 连接对象 */ public static Connection getConnection() &#123; try &#123; return dataSource.getConnection(); &#125; catch (SQLException e) &#123; throw new RuntimeException("获取连接失败"); &#125; &#125; /** * 获得与线程绑定的connection * @return connection */ public static Connection getCurrentConnection() &#123; Connection connection = threadLocal.get(); if(connection==null)&#123; connection = getConnection(); threadLocal.set(connection); &#125; return connection; &#125; /** * 开启事务 */ public static void beginTransaction()&#123; try &#123; getCurrentConnection().setAutoCommit(false); &#125; catch (SQLException e) &#123; throw new RuntimeException("开启事务失败"); &#125; &#125; /** * 回滚事务 */ public static void rollback()&#123; try &#123; getCurrentConnection().rollback(); &#125; catch (SQLException e) &#123; throw new RuntimeException("回滚事务失败"); &#125; &#125; /** * 提交事务 */ public static void commit()&#123; try &#123; getCurrentConnection().commit();//事务提交 &#125; catch (SQLException e) &#123; throw new RuntimeException("提交事务失败"); &#125; &#125; /** * 释放资源 */ public static void close()&#123; Connection currentConnection = getCurrentConnection(); try &#123; currentConnection.close(); threadLocal.remove();//从线程中删除 &#125; catch (SQLException e) &#123; throw new RuntimeException("释放资源失败"); &#125; &#125;&#125; 使用了druid连接池，druid.properties 配置如下： 1234567driverClassName=com.mysql.jdbc.Driverurl=jdbc:mysql:///test01username=rootpassword=123initialSize=5maxActive=10maxWait=3000 说明：每次使用此工具类时使用getCurrentConnection()，获得与线程绑定的连接对象。第一次，线程中没有connection时从连接池中获得连接并存到线程中。释放资源时把连接从线程中移除。重点不在于此，工具类直接复制也行。注意配置好自己的数据库。 测试utils，打印connection，没有报错打印出地址说明是成功的 123456public class UtilsTest &#123; public static void main(String[] args) &#123; Connection connection = ThreadLocalJDBCUtils.getCurrentConnection(); System.out.println(connection); &#125;&#125;]]></content>
      <categories>
        <category>事务</category>
      </categories>
      <tags>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2F2018%2F09%2F05%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[直接用代码说明问题这是一个售卖手机的接口。 123public interface SalePhones &#123; String salePhones(Double money);&#125; 小米手机实现了接口，就可以卖手机了。但是是直接销售没有代理，价格虽然便宜确需要顾客自己来生产地买手机，车费自理。 12345678public class XiaoMi implements SalePhones&#123; @Override public String salePhones(Double money) &#123; System.out.println("价格为："+money); return "小米s8"; &#125;&#125; 123456public class ProxyTest &#123; public static void main(String[] args) &#123; XiaoMi xiaoMi = new XiaoMi(); System.out.println(xiaoMi.salePhones(2000.0)); &#125;&#125; 下面我们用动态代理： 12345678910111213141516171819202122232425262728293031323334public class ProxyXiaoMi &#123; public Object doForProxy(Object object)&#123; /* 三个参数： 1. 类加载器：真实对象.getClass().getClassLoader() 2. 接口数组：真实对象.getClass().getInterfaces() 3. 处理器：new InvocationHandler() */ return Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), new InvocationHandler() &#123; /* 1. proxy:代理对象 2. method：代理对象的方法，被封装成为对象 3. args:代理对象调用的方法时，传递的实际参数 */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //方法体增强 if(method.getName().equals("salePhones"))&#123; //参数增强 double money = (double) args[0]; money = money * 1.25; System.out.println("全国包邮"); String invoke = (String) method.invoke(object, money); //返回值增强 return invoke+"+免费手机壳"; &#125; Object invoke = method.invoke(object, args); return invoke; &#125; &#125;); &#125;&#125; 12345678910public class ProxyTest &#123; public static void main(String[] args) &#123; XiaoMi xiaoMi = new XiaoMi(); System.out.println(xiaoMi.salePhones(2000.0)); System.out.println("---------------------------------------"); ProxyXiaoMi proxyXiaoMi = new ProxyXiaoMi(); SalePhones salePhonesByProxy = (SalePhones) proxyXiaoMi.doForProxy(xiaoMi); System.out.println(salePhonesByProxy.salePhones(2000.0)); &#125;&#125; 对参数，方法体，和返回值都进行了增强。 代理后，价格增加了，但是客户省了车费和奔波，还包邮亲+送手机壳! 代理其实就是为了增强方法，在方法执行前和执行后都可以对其进行处理，用代理的模式就可以自己写一个事务的处理。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态代理]]></title>
    <url>%2F2018%2F09%2F05%2F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%2F</url>
    <content type="text"><![CDATA[直接上代码。假设有一个接口StringUtils，在里面定义两个方法用于将字符串转为大写和转为小写如下。 1234public interface StringUtils &#123; String toUpperCase(String s); String toLowerCase(String s);&#125; 实现接口 1234567891011public class StringUtilsImpl implements StringUtils &#123; @Override public String toUpperCase(String s) &#123; return s.toUpperCase(); &#125; @Override public String toLowerCase(String s) &#123; return s.toLowerCase(); &#125;&#125; 进行测试 12345678public class StringUtilsTest &#123; @Test public void stringUtilsTest() &#123; StringUtilsImpl impl = new StringUtilsImpl(); String s1 = impl.toLowerCase(" abcDE f GH"); System.out.println(s1); &#125;&#125; 测试结果并不能除去字符串中的空格。如果我想要取出字符串中的空格后在转为小写输出，那么就可以用静态代理。 1234567891011121314151617public class ProxyStringUtilsImpl implements StringUtils &#123; private StringUtilsImpl impl; public ProxyStringUtilsImpl() &#123; impl = new StringUtilsImpl(); &#125; @Override public String toUpperCase(String s) &#123; return impl.toUpperCase(s.replace(" ","")); &#125; @Override public String toLowerCase(String s) &#123; return impl.toLowerCase(s.replace(" ","")); &#125;&#125; 需要维护一个被代理的类，并实现同一个接口。在方法的具体实现中可以先进行去空格的操作然后在调用被代理对象方法。 测试结果如下 123456789101112public class StringUtilsTest &#123; @Test public void stringUtilsTest() &#123; StringUtilsImpl impl = new StringUtilsImpl(); String s1 = impl.toLowerCase(" abcDE f GH"); System.out.println(s1); ProxyStringUtilsImpl proxyImpl = new ProxyStringUtilsImpl(); String s2 = proxyImpl.toLowerCase(" abcDE f GH"); System.out.println(s2); &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot异常处理]]></title>
    <url>%2F2018%2F09%2F05%2Fspringboot%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[看了好几篇关于springboot异常处理的文章，总结一下springboot异常处理。1.使用@ControllerAdvice和@ExceptionHandler 这种方式的话我们可以自定义异常和通过注解选择性的标注需要被处理的类。 1234567891011121314151617181920212223@Slf4j//全局异常处理@ControllerAdvice(annotations = MyExceptionHandle.class)//这里可以指定注解,被指定注解标注的类产生异常才会进处理。//而且是个数组，可以传多个,这里的是自定义的注解。public class GlobalDefaultExceptionHandler &#123; @ExceptionHandler(Exception.class)//捕获异常 public String globalDefaultExceptionHandler(Exception e, HttpServletRequest request)&#123; log.info("异常",e); //异常日志打印，否则没有控制台异常信息。这里使用了lombok简化了异常打印 //这里可以对exception分类处理。可以传自定义异常。 //这里是举例一种异常情况，在异常类已知情况下建议用这种方法具体处理。 if(e instanceof LoginException)&#123; LoginException loginException = (LoginException)e; String message = e.getMessage(); request.setAttribute("loginInfo",message); return "login"; &#125; request.setAttribute("unKnowException","为知错误异常"); return "/error"; &#125;&#125; 123456789@Getter@Setter//自定义异常。选择继承了RuntimeExceptionpublic class LoginException extends RuntimeException &#123; private String message; public LoginException(String message) &#123; this.message = message; &#125;&#125; 自定义的注解 12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Documentedpublic @interface MyExceptionHandle &#123;&#125; 测试：只上传controller代码进行说明 123456789101112131415161718@MyExceptionHandle@Controller@RequestMapping("/user")public class UserController &#123; @Resource(name = "userServiceImpl") private UserService userService = new UserServiceImpl(); @RequestMapping("/loginAction") public String loginAction(User user, HttpServletRequest request)&#123; User u = userService.FindUser(user); //System.out.println("登录校验"+u); if(u==null)&#123; request.setAttribute("user",user); throw new LoginException("用户名或者密码错误"); &#125; request.getSession().setAttribute("user",u); return "index"; &#125; 这是一个简单的登录校验，当返回user对象为空，代表没有对应信息，抛出了自定义异常LoginException(“用户名或者密码错误”);由于被自定义注解@MyExceptionHandle标注，该类产生异常会被GlobalDefaultExceptionHandler处理。这里用了themeleaf模板，具体不赘述，所以会携带异常message到登录页面回显。如图 1234567891011@RequestMapping("/loginAction") public String loginAction(User user, HttpServletRequest request)&#123; User u = userService.FindUser(user); int i= 1/0； if(u==null)&#123; request.setAttribute("user",user); throw new LoginException("用户名或者密码错误"); &#125; request.getSession().setAttribute("user",u); return "index"; &#125; 在代码上加入int i= 1/0；如上图则抛出异常会被当做为知异常。 12request.setAttribute("unKnowException","为知错误异常"); return "/error"; 携带信息转发到error.html页面。如图 2.实现 ErrorController 针对SpringMvc错误的Mapping进行处理123456789101112131415@Controllerpublic class HttpErrorController implements ErrorController &#123; private static final String ERROR_PATH = "error"; @RequestMapping(value=ERROR_PATH) public String handleError(HttpServletRequest request)&#123; request.setAttribute("httpError","地址异常,请输入正确地址!"); return "error"; &#125; @Override public String getErrorPath() &#123; return ERROR_PATH; &#125;&#125;]]></content>
      <categories>
        <category>springboot</category>
        <category>异常</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理死循环可能的原因]]></title>
    <url>%2F2018%2F09%2F04%2F%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%8F%AF%E8%83%BD%E7%9A%84%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[最近用原生servlet写小demo，想用动态代理实现事务处理。结果编写的动态代理陷入死循环。找了很久才找到原因。 123456789101112131415161718192021222324252627public class TransactionInvocationHandler implements InvocationHandler &#123; //这是需要被代理的对象 private Object proxy; //通过构造传参方式，传递需要被代理对象 public TransactionInvocationHandler(Object proxy) &#123; this.proxy = proxy; &#125; @Override public Object invoke(Object proxy, Method method, Object[] objects) throws Throwable &#123; ThreadLocalJDBCUtils.beginTransaction(); System.out.println("开启事务"); Object result = null; try &#123; result = method.invoke(proxy, objects); ThreadLocalJDBCUtils.commit(); System.out.println("提交事务"); &#125;catch (Exception e)&#123; ThreadLocalJDBCUtils.rollback(); System.out.println("回滚事务"); &#125;finally &#123; ThreadLocalJDBCUtils.close(); System.out.println("释放资源"); &#125; return result; &#125;&#125; 123456public class TransactionProxyManager &#123; public Object proxyFor(Object object)&#123; return Proxy.newProxyInstance(object.getClass().getClassLoader(),object.getClass().getInterfaces(),new TransactionInvocationHandler(object)); &#125;&#125; 是不是乍一看没毛病。问题在下面两个代码片。 123public TransactionInvocationHandler(Object proxy) &#123; this.proxy = proxy; &#125; 123456public Object invoke(Object proxy, Method method, Object[] objects) throws Throwable &#123; ThreadLocalJDBCUtils.beginTransaction(); System.out.println("开启事务"); Object result = null; try &#123; result = method.invoke(proxy, objects); 我自己的理解是构造方法传递的被代理对象和形式参数同名了。执行invoke方法时就先找形式参数而不会去找成员对象。而invoke方法中的proxy是需要外部传入的，不然就会陷入死循环。修改后代码如下，修改的4个地方用 包含。 123456789101112131415161718192021222324252627public class TransactionInvocationHandler implements InvocationHandler &#123; //这是需要被代理的对象 private Object *object*; //通过构造传参方式，传递需要被代理对象 public TransactionInvocationHandler(*Object object*) &#123; *this.object = object;* &#125; @Override public Object invoke(Object proxy, Method method, Object[] objects) throws Throwable &#123; ThreadLocalJDBCUtils.beginTransaction(); System.out.println("开启事务"); Object result = null; try &#123; result = method.invoke(*object*, objects); ThreadLocalJDBCUtils.commit(); System.out.println("提交事务"); &#125;catch (Exception e)&#123; ThreadLocalJDBCUtils.rollback(); System.out.println("回滚事务"); &#125;finally &#123; ThreadLocalJDBCUtils.close(); System.out.println("释放资源"); &#125; return result; &#125;&#125;]]></content>
      <categories>
        <category>异常</category>
      </categories>
      <tags>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA部署tomcat原理小解]]></title>
    <url>%2F2018%2F09%2F04%2FIDEA%E9%83%A8%E7%BD%B2tomcat%E5%8E%9F%E7%90%86%E5%B0%8F%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1.tomcat部署项目的三种方式在纯tomcat环境下，不使用开发工具tomcat部署项目有三种方式。 ①把html放到tomcat的webapps目录下的hello文件夹中，如下图。 启动tomcat访问http://localhost:8080/hello/hello.html就能够连接到hello.html了。这里稍微提一下虚拟路径即web项目中ContextPath，servlet中配置的是ServletPath。上面这种方式配置的虚拟路径”/hello”和项目路径是相等的。但是这个方法配置的web项目都要在webapps的目录下。eclipse的web项目部署方法应该就是这种。 ②第二种方式如下图： 区别与第一种方式，第二种的项目放在了d盘，没有在webapps的目录下。那么tomcat如何访问里面的资源呢？见下图 在tomcat的conf下有一个server.xml文件打开编辑文件在上图所圈位置加入了一段代码。 1&lt;Context docBase = "D:\hello" path = "/hi" /&gt; 不难发现，其中docBase指的是项目路径，path为虚拟路径。这里项目路径就和虚拟路径不一致了。大家可以联想到一个点：request有一个很常用的方法，就是request.getContextPath()，其实获取的就是这里的Context标签中属性名为path的值。启动tomcat，访问http://localhost:8080/hi/hello.html即能正确连接资源hello.html。使用eclipse的同学不妨去看一下自己的conf下的server.xml，会发现之前的web项目都有在context标签内配置。 ③以上两种都不是idea的部署方式，idea的部署方式是第三种.。在tomcat的conf\Catalina\localhost新建一个xml文件如下图 还是熟悉的配置，但是不需要在server.xml中修改，防止手残，把主要配置改了。访问http://localhost:8080/hey/hello.html即可访问到资源。这里要说明一下，第三章方法的虚拟路径为xml文件名字，而不是xml中配置的path，当你修改xml文件中的path与xml文件名字不一致时，以xml文件名字作为虚拟路径可以访问到资源，而用path中配置作为虚拟路径则访问不到资源。 2.idea的部署方式在idea中启动tomcat时会看到下面这段日志 这里使用的是之前做的小demo，不用在意。我们把路径复制在计算机中打开 打开下图的xml文件 可以从配置中看出虚拟路径配置的和xml文件的名称一致。这个虚拟路径是我在idea的tomcat配置中的部署选项中配置的如下图而项目的文件路径则在D:\ideawork\mycrm\out\artifacts\mycrm_war_exploded。 这里有一个点蛮有意思：idea采用的是上面说的第三种部署方式，而第三种部署的虚拟路径其实是xml文件名就算不配置Context标签中的Path也能访问到资源，那么idea为什么多此一举配置了path而且path中的值和xml文件名一致，是单纯的巧合吗，有什么意义？其实很简单，前面提到request.getContextPath获得的是Context标签中属性名为path的值。但是第三种部署的虚拟路径其实是xml文件名，保持一致可以认为获得的COntextPath就是虚拟路径。这样就可以访问到资源页面 END！]]></content>
      <categories>
        <category>原理</category>
      </categories>
      <tags>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BaseServlet应用原理]]></title>
    <url>%2F2018%2F09%2F03%2FBaseServlet%E5%BA%94%E7%94%A8%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[BaseServlet可以根据method参数通过反射调用相应的方法，然后根据方法产生的结果判断转发或者重定向到相应页面。结合web.xml 和 和测试用TestServlet说明继承BaseServlet后请求的处理。 ①http://localhost:8080/MyCrm/testServlet?method=queryUser请求必须带有一个method的参数，如果是表单提交的话，可以增加一个input标签设置为隐藏的模式，并附带一个method参数。method的value值为继承了BaseServlet的Servlet中要调用的方法名。 ② 123456789&lt;servlet&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;servlet.TestServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/testServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 请求被拦截会寻找一个servlet包下的TestServlet类，如下。 ③ 12345678public class TestServlet extends BaseServlet &#123; public String queryUser(HttpServletRequest request, HttpServletResponse response)&#123; String name = "东西"; //存到request域 request.setAttribute("name",name); return "/test.jsp"; &#125;&#125; 请求会被service方法处理，TestServlet没有次方法，但是他的父类BaseServlet重写了service方法所以会执行下面的service方法。让我们看看他怎么处理的。④ 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class BaseServlet extends HttpServlet &#123; @Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String methodName = request.getParameter("method"); //获得method的value值，就是要执行的方法的名字，这里获得的值为queryUser。所以上面说需要method参数。 Method method = null; try &#123; //根据方法名,参数的class反射获得方法（Method类） method = this.getClass().getMethod(methodName, HttpServletRequest.class, HttpServletResponse.class); //如果没有这个方法就抛出RuntimeException。 &#125; catch (NoSuchMethodException e) &#123; throw new RuntimeException("您要调用的方法：" + methodName + "它不存在！"); &#125; try &#123; //反射执行方法，这里执行名为queryUse的方法返回的result为“/test.jsp” String result = (String)method.invoke(this, request, response); //判断执行结果是否包含"：",结合下面可以知道，继承BaseServlet处理请求的方法转发和重定向页面是有固定格式的。 //转发为f：或者没有前缀+"/xxx.jsp" //重定向为r:+"/xxx.jsp" if (result != null &amp;&amp; !result.trim().isEmpty()) &#123; int index = result.indexOf(":"); //如果没有"："就转发到相应页面 if (index == -1) &#123; request.getRequestDispatcher(result).forward(request, response); &#125; else &#123; String start = result.substring(0, index); String path = result.substring(index + 1); //"f:"开头就转发到相应页面 if (start.equals("f")) &#123; request.getRequestDispatcher(path).forward(request, response); //"r:"开头就重定向到相应页面 &#125; else if (start.equals("r")) &#123; response.sendRedirect(request.getContextPath() + path); &#125; &#125; &#125; &#125; catch (Exception var9) &#123; throw new RuntimeException(var9); &#125; &#125;&#125; 经过上面的处理就会转发到test.jsp页面。 12345678910&lt;html&gt;&lt;head&gt; &lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt; $&#123;requestScope.name&#125; &lt;%--获得request域的name--%&gt; &lt;%--页面会显示TestServlet存的“东西”--%&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>原理</category>
      </categories>
      <tags>
        <tag>原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pom配置]]></title>
    <url>%2F2018%2F09%2F03%2Fpom%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[pom.xml常用得到ssm框架的pom.xml配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;ssm&lt;/groupId&gt; &lt;artifactId&gt;heimatravel&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;heimatravel Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.34&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt; &lt;/dependency&gt; &lt;!-- javaee依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加日志相关jar包 --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--lombok依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.18&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 添加spring核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-oxm&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context-support&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.0.8.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mybatis依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 添加mybatis/spring整合包依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--上传文件需要依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;!-- json数据 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--javaMail--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.mail&lt;/groupId&gt; &lt;artifactId&gt;javax.mail-api&lt;/artifactId&gt; &lt;version&gt;1.5.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.mail&lt;/groupId&gt; &lt;artifactId&gt;javax.mail&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--jedis--&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--servlet依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 引入thymeleaf --&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf&lt;/artifactId&gt; &lt;version&gt;3.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.9.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;heimatravel&lt;/finalName&gt; &lt;pluginManagement&gt;&lt;!-- lock down plugins versions to avoid using Maven defaults (may be moved to parent pom) --&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-clean-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.0&lt;/version&gt; &lt;/plugin&gt; &lt;!-- see http://maven.apache.org/ref/current/maven-core/default-bindings.html#Plugin_bindings_for_war_packaging --&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-resources-plugin&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;3.7.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt; &lt;version&gt;2.20.1&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-install-plugin&lt;/artifactId&gt; &lt;version&gt;2.5.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;artifactId&gt;maven-deploy-plugin&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;!-- tomcat7的插件， 不同tomcat版本这个也不一样 --&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;configuration&gt; &lt;!-- 通过maven tomcat7:run运行项目时，访问项目的端口号 --&gt; &lt;port&gt;8888&lt;/port&gt; &lt;!-- 项目访问路径 本例：localhost:9090, 如果配置的aa， 则访问路径为localhost:9090/aa--&gt; &lt;path&gt;/travel&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;/build&gt;&lt;/project&gt;]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssm配置]]></title>
    <url>%2F2018%2F09%2F03%2Fssm%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[常用的ssm配置文件包括数据库连接的properties，日志和xml文件配置等。 dbconfig.properties:1234567url=jdbc:mysql:///tmalldriverClassName=com.mysql.jdbc.Driverusername=rootpassword=123maxActive=20minIdle=10maxWait=60000 log4j.properties：12345678910111213141516171819202122232425log4j.rootLogger=INFO,Console,File #控制台日志log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.Target=System.out log4j.appender.Console.layout=org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=[%p][%t][%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;][%C] - %m%n #普通文件日志log4j.appender.File=org.apache.log4j.RollingFileAppender log4j.appender.File.File=D:/log/ssm.log log4j.appender.File.MaxFileSize=10MB #输出日志，如果换成DEBUG表示输出DEBUG以上级别日志log4j.appender.File.Threshold=ALL log4j.appender.File.layout=org.apache.log4j.PatternLayout log4j.appender.File.layout.ConversionPattern=[%p][%t][%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;][%C] - %m%n #mybatis日志配置 需要将日志的输出级别调为debuglog4j.logger.com.ibatis=DEBUGlog4j.logger.com.ibatis.common.jdbc.SimpleDataSource=DEBUGlog4j.logger.com.ibatis.common.jdbc.ScriptRunner=DEBUGlog4j.logger.com.ibatis.sqlmap.engine.impl.SqlMapClientDelegate=DEBUG#与sql相关log4j.logger.java.sql.Connection=DEBUGlog4j.logger.java.sql.Statement=DEBUGlog4j.logger.java.sql.PreparedStatement=DEBUG spring-mvc.xml：12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd"&gt; &lt;!-- 扫描controller --&gt; &lt;context:component-scan base-package="controller"/&gt; &lt;!-- 解除servlet对静态资源文件访问的限制 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 开启SpringMVC注解模式 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!-- 前缀 --&gt; &lt;property name="prefix" value="" /&gt;&lt;!--这里根据自己的建包自己配置--&gt; &lt;!-- 后缀 --&gt; &lt;property name="suffix" value=".jsp" /&gt;&lt;!--这里根据自己的建包自己配置--&gt; &lt;/bean&gt; &lt;!--文件上传配置--&gt; &lt;bean id="multipartResolver" class="org.springframework.web.multipart.commons.CommonsMultipartResolver"&gt; &lt;!-- 设定默认编码 --&gt; &lt;property name="defaultEncoding" value="UTF-8" /&gt; &lt;!-- 设定文件上传的最大值5MB，5*1024*1024 --&gt; &lt;property name="maxUploadSize" value="5242880" /&gt; &lt;property name="maxInMemorySize" value="4096" /&gt; &lt;/bean&gt;&lt;/beans&gt; spring-mybatis.xml：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!-- 扫描service包下所有使用注解的类型 --&gt; &lt;context:component-scan base-package="service"&gt;&lt;/context:component-scan&gt; &lt;!-- 配置数据库properties位置 --&gt; &lt;!--这个配置会报错，注释掉了用下面的--&gt; &lt;!--&lt;context:property-placeholder location="classpath:dbconfig.properties"&gt;&lt;/context:property-placeholder&gt;--&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:dbconfig.properties&lt;/value&gt; &lt;!--dbconfig.properties 数据库连接信息--&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean class="com.alibaba.druid.pool.DruidDataSource" id="dataSource"&gt; &lt;property name="password" value="$&#123;password&#125;"&gt;&lt;/property&gt; &lt;property name="username" value="$&#123;username&#125;"&gt;&lt;/property&gt; &lt;property name="driverClassName" value="$&#123;driverClassName&#125;"&gt;&lt;/property&gt; &lt;property name="url" value="$&#123;url&#125;"&gt;&lt;/property&gt; &lt;property name="maxActive" value="$&#123;maxActive&#125;"&gt;&lt;/property&gt; &lt;property name="minIdle" value="$&#123;minIdle&#125;"&gt;&lt;/property&gt; &lt;property name="maxWait" value="$&#123;maxWait&#125;"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 如果Mapper.xml与Mapper.class在同一个包下且同名，spring扫描Mapper.class的同时会自动扫描同名的Mapper.xml并装配到Mapper.class。 如果Mapper.xml与Mapper.class不在同一个包下或者不同名，就必须使用配置mapperLocations指定mapper.xml的位置。--&gt; &lt;!--此时spring是通过识别mapper.xml中的 namespace的值来确定对应的Mapper.class的--&gt; &lt;!-- 配置SqlSessionFactory对象 --&gt; &lt;bean class="org.mybatis.spring.SqlSessionFactoryBean" id="sqlSessionFactory"&gt; &lt;!-- 自动扫描mybatis配置文件 --&gt; &lt;property name="configLocation" value="classpath:mybatis-config.xml"&gt;&lt;/property&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name="mapperLocations" value="classpath:mapper/*.xml"&gt;&lt;/property&gt; &lt;!-- 扫描model包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="entity"&gt;&lt;/property&gt; &lt;!--配置使用pageHelper--&gt; &lt;/bean&gt; &lt;!-- 配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory"/&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="dao"/&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 配置基于注解的声明式事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;&lt;/beans&gt; mybatis-config.xml：12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--用于配合log4j在控制台打印sql语句--&gt; &lt;settings&gt; &lt;setting name="logImpl" value="STDOUT_LOGGING" /&gt; &lt;/settings&gt;&lt;/configuration&gt; web.xml：第二个web.xml是maven生成的，不完整用第一个命名空间。 1234567&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt;&lt;/web-app&gt;用这个哦！！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- 读取配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- 配置监听器加载spring --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 配置SpringMVC --&gt; &lt;servlet&gt; &lt;servlet-name&gt;MavenProject&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置springmvc什么时候启动，参数必须为整数 --&gt; &lt;!-- 如果为0或者大于0，则springMVC随着容器启动而启动 --&gt; &lt;!-- 如果小于0，则在第一次请求进来的时候启动 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;MavenProject&lt;/servlet-name&gt; &lt;!-- 所有的请求都进入springMVC --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
</search>
